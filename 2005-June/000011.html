<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [nmodule-commits] r26 - in trunk: . src src/antlr-runtime src/antlr-runtime/antlr src/antlr-runtime/antlr.collections src/antlr-runtime/antlr.collections.impl src/antlr-runtime/antlr.debug
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/nmodule-commits/2005-June/index.html" >
   <LINK REL="made" HREF="mailto:nmodule-commits%40lists.berlios.de?Subject=Re%3A%20%5Bnmodule-commits%5D%20r26%20-%20in%20trunk%3A%20.%20src%20src/antlr-runtime%20src/antlr-runtime/antlr%20src/antlr-runtime/antlr.collections%20src/antlr-runtime/antlr.collections.impl%20src/antlr-runtime/antlr.debug&In-Reply-To=%3C200506240409.j5O49dIL028980%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000010.html">
   <LINK REL="Next"  HREF="000012.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[nmodule-commits] r26 - in trunk: . src src/antlr-runtime src/antlr-runtime/antlr src/antlr-runtime/antlr.collections src/antlr-runtime/antlr.collections.impl src/antlr-runtime/antlr.debug</H1>
    <B>Michael Tindal at BerliOS</B> 
    <A HREF="mailto:nmodule-commits%40lists.berlios.de?Subject=Re%3A%20%5Bnmodule-commits%5D%20r26%20-%20in%20trunk%3A%20.%20src%20src/antlr-runtime%20src/antlr-runtime/antlr%20src/antlr-runtime/antlr.collections%20src/antlr-runtime/antlr.collections.impl%20src/antlr-runtime/antlr.debug&In-Reply-To=%3C200506240409.j5O49dIL028980%40sheep.berlios.de%3E"
       TITLE="[nmodule-commits] r26 - in trunk: . src src/antlr-runtime src/antlr-runtime/antlr src/antlr-runtime/antlr.collections src/antlr-runtime/antlr.collections.impl src/antlr-runtime/antlr.debug">urilith at sheep.berlios.de
       </A><BR>
    <I>Fri Jun 24 06:09:39 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000010.html">[nmodule-commits] r25 - tags
</A></li>
        <LI>Next message: <A HREF="000012.html">[nmodule-commits] r27 - in trunk: . src/NModule.Core.Loader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11">[ date ]</a>
              <a href="thread.html#11">[ thread ]</a>
              <a href="subject.html#11">[ subject ]</a>
              <a href="author.html#11">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: urilith
Date: 2005-06-24 06:09:17 +0200 (Fri, 24 Jun 2005)
New Revision: 26

Added:
   trunk/Buildfile
   trunk/Buildfile.config
   trunk/INSTALL
   trunk/NEWS
   trunk/TODO
   trunk/src/Buildfile
   trunk/src/NModule.Core.Loader.dll.sources
   trunk/src/NModule.Core.Module.dll.sources
   trunk/src/NModule.Core.dll.sources
   trunk/src/NModule.Dependency.Core.dll.sources
   trunk/src/NModule.Dependency.Parser.dll.sources
   trunk/src/antlr-runtime.dll.sources
   trunk/src/antlr-runtime/
   trunk/src/antlr-runtime/AssemblyInfo.cs
   trunk/src/antlr-runtime/SupportClass.cs
   trunk/src/antlr-runtime/antlr.collections.impl/
   trunk/src/antlr-runtime/antlr.collections.impl/ASTArray.cs
   trunk/src/antlr-runtime/antlr.collections.impl/BitSet.cs
   trunk/src/antlr-runtime/antlr.collections/
   trunk/src/antlr-runtime/antlr.collections/AST.cs
   trunk/src/antlr-runtime/antlr.debug/
   trunk/src/antlr-runtime/antlr.debug/ANTLREventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/DebuggingCharScanner.cs
   trunk/src/antlr-runtime/antlr.debug/DebuggingInputBuffer.cs
   trunk/src/antlr-runtime/antlr.debug/DebuggingParser.cs
   trunk/src/antlr-runtime/antlr.debug/GuessingEventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/ICharScannerDebugSubject.cs
   trunk/src/antlr-runtime/antlr.debug/IDebugSubject.cs
   trunk/src/antlr-runtime/antlr.debug/IParserDebugSubject.cs
   trunk/src/antlr-runtime/antlr.debug/InputBufferEventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/InputBufferEventSupport.cs
   trunk/src/antlr-runtime/antlr.debug/InputBufferListener.cs
   trunk/src/antlr-runtime/antlr.debug/InputBufferListenerBase.cs
   trunk/src/antlr-runtime/antlr.debug/InputBufferReporter.cs
   trunk/src/antlr-runtime/antlr.debug/LLkDebuggingParser.cs
   trunk/src/antlr-runtime/antlr.debug/Listener.cs
   trunk/src/antlr-runtime/antlr.debug/MessageEventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/MessageListener.cs
   trunk/src/antlr-runtime/antlr.debug/MessageListenerBase.cs
   trunk/src/antlr-runtime/antlr.debug/NewLineEventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/NewLineListener.cs
   trunk/src/antlr-runtime/antlr.debug/ParseTreeDebugParser.cs
   trunk/src/antlr-runtime/antlr.debug/ParserController.cs
   trunk/src/antlr-runtime/antlr.debug/ParserEventSupport.cs
   trunk/src/antlr-runtime/antlr.debug/ParserListener.cs
   trunk/src/antlr-runtime/antlr.debug/ParserListenerBase.cs
   trunk/src/antlr-runtime/antlr.debug/ParserMatchEventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/ParserMatchListener.cs
   trunk/src/antlr-runtime/antlr.debug/ParserMatchListenerBase.cs
   trunk/src/antlr-runtime/antlr.debug/ParserReporter.cs
   trunk/src/antlr-runtime/antlr.debug/ParserTokenEventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/ParserTokenListener.cs
   trunk/src/antlr-runtime/antlr.debug/ParserTokenListenerBase.cs
   trunk/src/antlr-runtime/antlr.debug/ScannerEventSupport.cs
   trunk/src/antlr-runtime/antlr.debug/SemanticPredicateEventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListener.cs
   trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListenerBase.cs
   trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateEventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListener.cs
   trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListenerBase.cs
   trunk/src/antlr-runtime/antlr.debug/TraceEventArgs.cs
   trunk/src/antlr-runtime/antlr.debug/TraceListener.cs
   trunk/src/antlr-runtime/antlr.debug/TraceListenerBase.cs
   trunk/src/antlr-runtime/antlr.debug/Tracer.cs
   trunk/src/antlr-runtime/antlr/
   trunk/src/antlr-runtime/antlr/ANTLRException.cs
   trunk/src/antlr-runtime/antlr/ANTLRPanicException.cs
   trunk/src/antlr-runtime/antlr/ASTFactory.cs
   trunk/src/antlr-runtime/antlr/ASTNULLType.cs
   trunk/src/antlr-runtime/antlr/ASTNodeCreator.cs
   trunk/src/antlr-runtime/antlr/ASTPair.cs
   trunk/src/antlr-runtime/antlr/ASTVisitor.cs
   trunk/src/antlr-runtime/antlr/BaseAST.cs
   trunk/src/antlr-runtime/antlr/ByteBuffer.cs
   trunk/src/antlr-runtime/antlr/CharBuffer.cs
   trunk/src/antlr-runtime/antlr/CharQueue.cs
   trunk/src/antlr-runtime/antlr/CharScanner.cs
   trunk/src/antlr-runtime/antlr/CharStreamException.cs
   trunk/src/antlr-runtime/antlr/CharStreamIOException.cs
   trunk/src/antlr-runtime/antlr/CommonAST.cs
   trunk/src/antlr-runtime/antlr/CommonASTWithHiddenTokens.cs
   trunk/src/antlr-runtime/antlr/CommonHiddenStreamToken.cs
   trunk/src/antlr-runtime/antlr/CommonToken.cs
   trunk/src/antlr-runtime/antlr/DefaultFileLineFormatter.cs
   trunk/src/antlr-runtime/antlr/DumpASTVisitor.cs
   trunk/src/antlr-runtime/antlr/FileLineFormatter.cs
   trunk/src/antlr-runtime/antlr/IHiddenStreamToken.cs
   trunk/src/antlr-runtime/antlr/IToken.cs
   trunk/src/antlr-runtime/antlr/InputBuffer.cs
   trunk/src/antlr-runtime/antlr/LLkParser.cs
   trunk/src/antlr-runtime/antlr/LexerSharedInputState.cs
   trunk/src/antlr-runtime/antlr/MismatchedCharException.cs
   trunk/src/antlr-runtime/antlr/MismatchedTokenException.cs
   trunk/src/antlr-runtime/antlr/NoViableAltException.cs
   trunk/src/antlr-runtime/antlr/NoViableAltForCharException.cs
   trunk/src/antlr-runtime/antlr/ParseTree.cs
   trunk/src/antlr-runtime/antlr/ParseTreeRule.cs
   trunk/src/antlr-runtime/antlr/ParseTreeToken.cs
   trunk/src/antlr-runtime/antlr/Parser.cs
   trunk/src/antlr-runtime/antlr/ParserSharedInputState.cs
   trunk/src/antlr-runtime/antlr/RecognitionException.cs
   trunk/src/antlr-runtime/antlr/SemanticException.cs
   trunk/src/antlr-runtime/antlr/StringUtils.cs
   trunk/src/antlr-runtime/antlr/Token.cs
   trunk/src/antlr-runtime/antlr/TokenBuffer.cs
   trunk/src/antlr-runtime/antlr/TokenCreator.cs
   trunk/src/antlr-runtime/antlr/TokenQueue.cs
   trunk/src/antlr-runtime/antlr/TokenStream.cs
   trunk/src/antlr-runtime/antlr/TokenStreamBasicFilter.cs
   trunk/src/antlr-runtime/antlr/TokenStreamException.cs
   trunk/src/antlr-runtime/antlr/TokenStreamHiddenTokenFilter.cs
   trunk/src/antlr-runtime/antlr/TokenStreamIOException.cs
   trunk/src/antlr-runtime/antlr/TokenStreamRecognitionException.cs
   trunk/src/antlr-runtime/antlr/TokenStreamRetryException.cs
   trunk/src/antlr-runtime/antlr/TokenStreamRewriteEngine.cs
   trunk/src/antlr-runtime/antlr/TokenStreamSelector.cs
   trunk/src/antlr-runtime/antlr/TokenWithIndex.cs
   trunk/src/antlr-runtime/antlr/TreeParser.cs
   trunk/src/antlr-runtime/antlr/TreeParserSharedInputState.cs
   trunk/src/nmodule.snk
Removed:
   trunk/lib/
Modified:
   trunk/
   trunk/ChangeLog
Log:
 <A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">r122 at dreamshadow</A>:  urilith | 2005-06-23 21:53:44 -0500
 2005-06-23 Michael Tindal &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">urilith at gentoo.org</A>&gt;
 
   * src/Buildfile: New build file for mbuild system.
   * src/NModule.Core.Loader.dll.sources: Response file.
   * src/NModule.Core.Module.dll.sources: Response file.
   * src/NModule.Core.dll.sources: Response file.
   * src/NModule.Dependency.Core.dll.sources: Response file.
   * src/NModule.Dependency.Parser.dll.sources: Response file.
   * src/antlr-runtime: Imported just the runtime stuff from antlr.
   * src/antlr-runtime.dll.sources: Response file.
   * src/nmodule.snk: New keyfile for signing.
   * Buildfile: New build for mbuild system.
   * Buildfile.config: Configuration file for mbuild.
   * INSTALL: New file, nothing in here yet.
   * NEWS: New file, nothing in here yet.
   * TODO: New file, nothing in here yet.
   * lib: Removed the lib stuff since its no longer needed.
 



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - b743595e-7af7-0310-b020-feacd67de632:/local/nmodule/trunk:119
   + b743595e-7af7-0310-b020-feacd67de632:/local/nmodule/trunk:122

Added: trunk/Buildfile
===================================================================
--- trunk/Buildfile	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/Buildfile	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,70 @@
+using [ Core
+	Core.Clr
+	Core.Install
+	Languages.CSharp
+	Tools.Bundlegen
+]
+
+# information about this project
+
+project [ 
+	name = nmodule
+	version = 0.1.0.0
+
+	# This is a 'compatibility code'; a standard piece
+	# of text that should be munged into names
+	# of installed files if you want to be able
+	# to do parallel installs. For instance, header files
+	# should be installed into ${includedir}/${name}-${compat-code}.
+	# More to the point, there should be infrastructure
+	# to make this easy. More useful is /config/env/compat_name,
+	# which is the string &quot;${name}-${compat-code}&quot;. For instance,
+	# our assemblies are installed with a Mono gacutil 'package'
+	# of compat_name. Anyway, typically this should be the upper
+	# two pieces of the version number, but you can choose
+	# something else if you want.
+
+	compat-code = 0.1
+
+	# Versioned assembly references pulled
+	# from the GAC. No more aclocal hell!
+
+	ref [ 
+		Languages.CSharp = 0.0.4.0
+		Tools.Jay = 0.0.4.0
+		Tools.PkgConfig = 0.0.4.0
+		Tools.Bundlegen = 0.0.4.0
+		Tools.Monodoc = 0.0.4.0
+	]
+]
+
+# Load a separate file of configuration options
+# in a virtual prefix
+
+load Buildfile.config inside config/nmodule
+
+# There are also Buildfiles in these
+# subdirectories.
+
+subdirs [
+	src
+]
+
+# Back to regular compiles. Monkeywrench is the on-disk implementation
+# of mbuild logic: it has the parser for this file, code to cache results
+# in files, etc.
+ 
+# for now, this is how we do our version of EXTRA_DIST
+
+TODO = TextSource[] 
+	with [ install = /config/nmodule/doc_installer ]
+README = TextSource[] 
+	with [ install = /config/nmodule/doc_installer ]
+INSTALL = TextSource[] 
+	with [ install = /config/nmodule/doc_installer ]
+NEWS = TextSource[] 
+	with [ install = /config/nmodule/doc_installer ]
+COPYING = TextSource[]
+	with [ install = /config/nmodule/doc_installer ]
+AUTHORS = TextSource[]
+	with [ install = /config/nmodule/doc_installer ]

Added: trunk/Buildfile.config
===================================================================
--- trunk/Buildfile.config	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/Buildfile.config	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,47 @@
+using [ 
+	Core
+	Core.Config 
+	Core.Clr 
+	Core.Install
+	Languages.CSharp
+	Tools.PkgConfig 
+]
+
+# Dll dependencies
+
+# Define our gac installer: use our &quot;compat name&quot; as package name,
+# which looks something like &quot;mbuild-1.0&quot;
+# defaults to rootdir /config/install/libdir and 
+# program /config/clr/gacutil
+
+gac_installer = MakeGacutilInstaller [ /config/env/compat_name ]
+
+#good_example = ConfigBool[true] with [
+#	prompt = &quot;This is an example configuration option. Ok?&quot;
+#]
+
+# Document installing: {prefix}/share/doc/{compat-name}
+
+docdir = JoinPath [ 
+	/config/install/prefix_dir 
+	{ &quot;share&quot;, &quot;doc&quot;, /config/env/compat_name } 
+]
+
+doc_installer = MakeCopyInstaller [ docdir ]
+
+# Exe installing: {libdir}/{compat-name}
+# (The default exe installer puts them in {bindir}, which
+# we don't want -- wrappers go there.
+
+exe_installer = Clone [ /config/lang/csharp/dll_installer ]
+
+# Our compiler options
+
+# no prompt! Bad programmer!
+#bad_example = ConfigBool[false]
+
+#test_pkgconfig = PkgConfig[&quot;gtk+-2.0&quot;]
+
+# would use with [ default = false ], but
+# this breaks when we make dist
+# nopkg = PkgConfig[&quot;donthavethis&quot;]

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/ChangeLog	2005-06-24 04:09:17 UTC (rev 26)
@@ -1,5 +1,23 @@
 2005-06-23 Michael Tindal &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">urilith at gentoo.org</A>&gt;
 
+	* src/Buildfile: New build file for mbuild system.
+	* src/NModule.Core.Loader.dll.sources: Response file.
+	* src/NModule.Core.Module.dll.sources: Response file.
+	* src/NModule.Core.dll.sources: Response file.
+	* src/NModule.Dependency.Core.dll.sources: Response file. 
+	* src/NModule.Dependency.Parser.dll.sources: Response file. 
+	* src/antlr-runtime: Imported just the runtime stuff from antlr.
+	* src/antlr-runtime.dll.sources: Response file.
+	* src/nmodule.snk: New keyfile for signing.
+	* Buildfile: New build for mbuild system.
+	* Buildfile.config: Configuration file for mbuild.
+	* INSTALL: New file, nothing in here yet.
+	* NEWS: New file, nothing in here yet.
+	* TODO: New file, nothing in here yet.
+	* lib: Removed the lib stuff since its no longer needed.
+
+2005-06-23 Michael Tindal &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">urilith at gentoo.org</A>&gt;
+
 	*******************
         ***** RELEASE *****
         *******************

Added: trunk/INSTALL
===================================================================

Added: trunk/NEWS
===================================================================

Added: trunk/TODO
===================================================================

Added: trunk/src/Buildfile
===================================================================
--- trunk/src/Buildfile	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/Buildfile	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,82 @@
+using [ Core
+        Core.Clr
+        Core.Install
+        Languages.CSharp
+        Tools.Bundlegen
+]
+
+# Instead of creating mostly-blank Buildfiles
+# in these directories, we can implicitly define
+# their contents.
+
+inside [ 
+	NModule.Core
+	NModule.Dependency.Core
+	antlr-runtime
+	antlr-runtime/antlr
+	antlr-runtime/antlr.collections
+	antlr-runtime/antlr.collections.impl
+	antlr-runtime/antlr.debug
+	NModule.Dependency.Parser
+	NModule.Core.Module
+	NModule.Core.Loader
+] [
+	using [ Core
+		Core.Clr
+		Languages.CSharp
+		Tools.Bundlegen # for Core
+	]
+]
+
+# Load a response file to get the list of sources
+# Use a custom installer that installs the DLL into
+# the GAC, not just libdir. Also use a set of compiler
+# options defined in Buildfile.config
+
+# Now we declare &quot;bundles&quot;, sets of rules used by mbuild. They
+# are generated with a special tool called mb-bundlegen.exe.
+# Bundlegen makes it so you don't need to worry about writing a 
+# lot of boilerplate code to create new build rules.
+
+# Now, declare all the bundles. Again, install them into
+# the GAC, not into libdir
+
+NModule.Core.dll = [
+	@NModule.Core.dll.sources
+	nmodule.snk
+] with [ install = /config/nmodule/gac_installer ]
+
+NModule.Dependency.Core.dll = [
+	@NModule.Dependency.Core.dll.sources
+	NModule.Core.dll
+	nmodule.snk
+] with [ install = /config/nmodule/gac_installer ]
+
+antlr-runtime.dll = [
+	@antlr-runtime.dll.sources
+	nmodule.snk
+] with [ install = /config/nmodule/gac_installer ]
+
+NModule.Dependency.Parser.dll = [
+	@NModule.Dependency.Parser.dll.sources
+	NModule.Core.dll
+	NModule.Dependency.Core.dll
+	antlr-runtime.dll
+	nmodule.snk
+] with [ install = /config/nmodule/gac_installer ]
+
+NModule.Core.Module.dll = [
+	@NModule.Core.Module.dll.sources
+	NModule.Core.dll
+	NModule.Dependency.Core.dll
+	NModule.Dependency.Parser.dll
+	nmodule.snk
+] with [ install = /config/nmodule/gac_installer ]
+
+NModule.Core.Loader.dll = [
+	@NModule.Core.Loader.dll.sources
+	NModule.Core.dll
+	NModule.Core.Module.dll
+	NModule.Dependency.Core.dll
+	nmodule.snk
+] with [ install = /config/nmodule/gac_installer ]

Added: trunk/src/NModule.Core.Loader.dll.sources
===================================================================
--- trunk/src/NModule.Core.Loader.dll.sources	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/NModule.Core.Loader.dll.sources	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,10 @@
+NModule.Core.Loader/AssemblyInfo.cs
+NModule.Core.Loader/CircularDependencyException.cs
+NModule.Core.Loader/UnresolvedDependencyException.cs
+NModule.Core.Loader/ModuleController.cs
+NModule.Core.Loader/DepResolver.cs
+NModule.Core.Loader/ModuleImageException.cs
+NModule.Core.Loader/DomainStillReferencedException.cs
+NModule.Core.Loader/ModuleLoader.cs
+NModule.Core.Loader/ModuleNotFoundException.cs
+NModule.Core.Loader/InvalidModuleException.cs

Added: trunk/src/NModule.Core.Module.dll.sources
===================================================================
--- trunk/src/NModule.Core.Module.dll.sources	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/NModule.Core.Module.dll.sources	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,4 @@
+NModule.Core.Module/AssemblyInfo.cs
+NModule.Core.Module/ModuleRole.cs
+NModule.Core.Module/ModuleInfo.cs
+NModule.Core.Module/ModuleInfoException.cs

Added: trunk/src/NModule.Core.dll.sources
===================================================================
--- trunk/src/NModule.Core.dll.sources	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/NModule.Core.dll.sources	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,4 @@
+NModule.Core/AssemblyInfo.cs
+NModule.Core/IModule.cs
+NModule.Core/ModuleDependencyAttribute.cs
+NModule.Core/ModuleRoleAttribute.cs

Added: trunk/src/NModule.Dependency.Core.dll.sources
===================================================================
--- trunk/src/NModule.Dependency.Core.dll.sources	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/NModule.Dependency.Core.dll.sources	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,5 @@
+NModule.Dependency.Core/DepConstraint.cs
+NModule.Dependency.Core/AssemblyInfo.cs
+NModule.Dependency.Core/DepNode.cs
+NModule.Dependency.Core/DepOps.cs
+NModule.Dependency.Core/DepVersion.cs

Added: trunk/src/NModule.Dependency.Parser.dll.sources
===================================================================
--- trunk/src/NModule.Dependency.Parser.dll.sources	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/NModule.Dependency.Parser.dll.sources	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,4 @@
+NModule.Dependency.Parser/AssemblyInfo.cs
+NModule.Dependency.Parser/DepParser.cs
+NModule.Dependency.Parser/DepLexer.cs
+NModule.Dependency.Parser/DepParserTokenTypes.cs

Added: trunk/src/antlr-runtime/AssemblyInfo.cs
===================================================================
--- trunk/src/antlr-runtime/AssemblyInfo.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/AssemblyInfo.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,32 @@
+using System;
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+
+// TODO: Review the values of the assembly attributes
+
+[assembly: AssemblyTitle(&quot;antlr.runtime&quot;)]
+[assembly: AssemblyDescription(&quot;ANTLR Runtime for .NET&quot;)]
+[assembly: AssemblyCompany(&quot;www.antlr.org&quot;)]
+[assembly: AssemblyProduct(&quot;&quot;)]
+[assembly: AssemblyCopyright(&quot;&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+[assembly: AssemblyVersion(&quot;2.7.5.02&quot;)]
+
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Revision
+//      Build Number
+//
+// You can specify all the values or you can default the Revision and Build Numbers
+// by using the '*' as shown below:
+
+[assembly: CLSCompliantAttribute(true)]


Property changes on: trunk/src/antlr-runtime/AssemblyInfo.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/SupportClass.cs
===================================================================
--- trunk/src/antlr-runtime/SupportClass.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/SupportClass.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,29 @@
+using System;
+internal class SupportClass
+{
+	public static int URShift(int number, int bits)
+	{
+		if ( number &gt;= 0)
+			return number &gt;&gt; bits;
+		else
+			return (number &gt;&gt; bits) + (2 &lt;&lt; ~bits);
+	}
+
+	public static int URShift(int number, long bits)
+	{
+		return URShift(number, (int)bits);
+	}
+
+	public static long URShift(long number, int bits)
+	{
+		if ( number &gt;= 0)
+			return number &gt;&gt; bits;
+		else
+			return (number &gt;&gt; bits) + (2L &lt;&lt; ~bits);
+	}
+
+	public static long URShift(long number, long bits)
+	{
+		return URShift(number, (int)bits);
+	}
+}


Property changes on: trunk/src/antlr-runtime/SupportClass.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/ANTLRException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ANTLRException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ANTLRException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,35 @@
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	using System;
+	
+	[Serializable]
+	public class ANTLRException : Exception
+	{
+		public ANTLRException() : base() 
+		{
+		}
+
+		public ANTLRException(string s) : base(s) 
+		{
+		}
+
+		public ANTLRException(string s, Exception inner) : base(s, inner)
+		{
+		}
+	}
+}


Property changes on: trunk/src/antlr-runtime/antlr/ANTLRException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/ANTLRPanicException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ANTLRPanicException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ANTLRPanicException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,35 @@
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	using System;
+	
+	[Serializable]
+	public class ANTLRPanicException : ANTLRException 
+	{
+		public ANTLRPanicException() : base() 
+		{
+		}
+
+		public ANTLRPanicException(string s) : base(s)
+		{
+		}
+
+		public ANTLRPanicException(string s, Exception inner) : base(s, inner)
+		{
+		}
+	}
+}


Property changes on: trunk/src/antlr-runtime/antlr/ANTLRPanicException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/ASTFactory.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ASTFactory.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ASTFactory.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,696 @@
+using System;
+using System.Collections;
+using Assembly			= System.Reflection.Assembly;
+using ArrayList			= System.Collections.ArrayList;
+using Debug				= System.Diagnostics.Debug;
+using AST				= antlr.collections.AST;
+using ASTArray			= antlr.collections.impl.ASTArray;
+using ANTLRException	= antlr.ANTLRException;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+
+	// HISTORY:
+	//
+	// 19-Aug-2002 kunle    Augmented the basic flexibility of the default ASTFactory with a map
+	//                      of TokenID-to-NodeTypeName. It's now a proper GoF-style Factory ;-)
+	//
+
+	/// &lt;summary&gt;
+	/// AST Support code shared by TreeParser and Parser.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	/// &lt;para&gt;
+	/// We use delegation to share code (and have only one 
+	/// bit of code to maintain) rather than subclassing
+	/// or superclassing (forces AST support code to be
+	/// loaded even when you don't want to do AST stuff).
+	/// &lt;/para&gt;
+	/// &lt;para&gt;
+	/// Typically, &lt;see cref=&quot;setASTNodeType&quot;/&gt;  is used to specify the
+	/// homogeneous type of node to create, but you can override
+	/// &lt;see cref=&quot;create&quot;/&gt;  to make heterogeneous nodes etc...
+	/// &lt;/para&gt;
+	/// &lt;/remarks&gt;
+	public class ASTFactory
+	{
+		//---------------------------------------------------------------------
+		// CONSTRUCTORS
+		//---------------------------------------------------------------------
+
+		/// &lt;summary&gt;
+		/// Constructs an &lt;c&gt;ASTFactory&lt;/c&gt; with the default AST node type of
+		/// &lt;see cref=&quot;antlr.CommonAST&quot;/&gt;.
+		/// &lt;/summary&gt;
+		public ASTFactory() : this(&quot;antlr.CommonAST&quot;)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Constructs an &lt;c&gt;ASTFactory&lt;/c&gt; and use the specified AST node type
+		/// as the default.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;nodeTypeName&quot;&gt;
+		///		Name of default AST node type for this factory.
+		/// &lt;/param&gt;
+		public ASTFactory(string nodeTypeName)
+		{
+			heteroList_					= new FactoryEntry[Token.MIN_USER_TYPE+1];
+			defaultASTNodeTypeObject_	= loadNodeTypeObject(nodeTypeName);
+			defaultCreator_				= null;
+			typename2creator_			= new Hashtable(32, (float) 0.3);
+			typename2creator_[&quot;antlr.CommonAST&quot;]					= CommonAST.Creator;
+			typename2creator_[&quot;antlr.CommonASTWithHiddenTokens&quot;]	= CommonASTWithHiddenTokens.Creator;
+
+		}
+		
+		//---------------------------------------------------------------------
+		// DATA MEMBERS
+		//---------------------------------------------------------------------
+
+		/// &lt;summary&gt;
+		/// Stores the Type of the default AST node class to be used during tree construction.
+		/// &lt;/summary&gt;
+		protected Type				defaultASTNodeTypeObject_;
+		protected ASTNodeCreator	defaultCreator_;
+
+		/// &lt;summary&gt;
+		/// Stores the mapping between custom AST NodeTypes and their NodeTypeName/NodeTypeClass
+		/// and ASTNodeCreator.
+		/// &lt;/summary&gt;
+		protected FactoryEntry[]	heteroList_;
+
+		/// &lt;summary&gt;
+		/// Stores the mapping between AST node typenames and their token ID.
+		/// &lt;/summary&gt;
+		protected Hashtable			typename2creator_;
+
+		//---------------------------------------------------------------------
+		// FUNCTION MEMBERS
+		//---------------------------------------------------------------------
+
+		/// &lt;summary&gt;
+		/// Specify an &quot;override&quot; for the &lt;see cref=&quot;AST&quot;/&gt; type created for
+		/// the specified Token type.
+		/// &lt;/summary&gt;
+		/// &lt;remarks&gt;
+		/// This method is useful for situations that ANTLR cannot oridinarily deal 
+		/// with (i.e., when you  create a token based upon a nonliteral token symbol 
+		/// like #[LT(1)].  This is a runtime value and ANTLR cannot determine the token 
+		/// type (and hence the AST) statically.
+		/// &lt;/remarks&gt;
+		/// &lt;param name=&quot;tokenType&quot;&gt;Token type to override.&lt;/param&gt;
+		/// &lt;param name=&quot;NodeTypeName&quot;&gt;
+		///		Fully qualified AST typename (or null to specify 
+		///		the factory's default AST type).
+		/// &lt;/param&gt;
+		public void setTokenTypeASTNodeType(int tokenType, string NodeTypeName)
+		{
+			// check validity of arguments...
+			if( tokenType &lt; Token.MIN_USER_TYPE )
+				throw new ANTLRException(&quot;Internal parser error: Cannot change AST Node Type for Token ID '&quot; + tokenType + &quot;'&quot;);
+
+			// resize up to and including 'type' and initialize any gaps to default
+			// factory.
+			if (tokenType &gt; (heteroList_.Length+1))
+				setMaxNodeType(tokenType);
+			// And add new thing..
+			if (heteroList_[tokenType] == null)
+                heteroList_[tokenType] = new FactoryEntry(loadNodeTypeObject(NodeTypeName));
+			else
+				heteroList_[tokenType].NodeTypeObject = loadNodeTypeObject(NodeTypeName);
+		}
+
+		/// &lt;summary&gt;
+		/// Register an AST Node Type for a given Token type ID.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;NodeType&quot;&gt;The Token type ID.&lt;/param&gt;
+		/// &lt;param name=&quot;NodeTypeName&quot;&gt;The AST Node Type to register.&lt;/param&gt;
+		[Obsolete(&quot;Replaced by setTokenTypeASTNodeType(int, string) since version 2.7.2.6&quot;, true)]
+		public void registerFactory(int NodeType, string NodeTypeName)
+		{
+			setTokenTypeASTNodeType(NodeType, NodeTypeName);
+		}
+
+		/// &lt;summary&gt;
+		/// Register an ASTNodeCreator for a given Token type ID.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;NodeType&quot;&gt;The Token type ID.&lt;/param&gt;
+		/// &lt;param name=&quot;creator&quot;&gt;The creater to register.&lt;/param&gt;
+		public void setTokenTypeASTNodeCreator(int NodeType, ASTNodeCreator creator)
+		{
+			// check validity of arguments...
+			if( NodeType &lt; Token.MIN_USER_TYPE )
+				throw new ANTLRException(&quot;Internal parser error: Cannot change AST Node Type for Token ID '&quot; + NodeType + &quot;'&quot;);
+
+			// resize up to and including 'type' and initialize any gaps to default
+			// factory.
+			if (NodeType &gt; (heteroList_.Length+1))
+				setMaxNodeType(NodeType);
+			// And add new thing..
+			if (heteroList_[NodeType] == null)
+				heteroList_[NodeType] = new FactoryEntry(creator);
+			else
+				heteroList_[NodeType].Creator = creator;
+
+			//typename2creator_[NodeType.ToString()]		= creator;
+			typename2creator_[creator.ASTNodeTypeName]	= creator;
+		}
+
+		/// &lt;summary&gt;
+		/// Register an ASTNodeCreator to be used for creating node by default.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;creator&quot;&gt;The ASTNodeCreator.&lt;/param&gt;
+		public void setASTNodeCreator(ASTNodeCreator creator)
+		{
+			defaultCreator_ = creator;
+		}
+
+		/// &lt;summary&gt;
+		/// Pre-expands the internal list of TokenTypeID-to-ASTNodeType mappings
+		/// to the specified size.
+		/// This is primarily a convenience method that can be used to prevent 
+		/// unnecessary and costly re-org of the mappings list.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;NodeType&quot;&gt;Maximum Token Type ID.&lt;/param&gt;
+		public void setMaxNodeType( int NodeType )
+		{
+			//Debug.WriteLine(this, &quot;NodeType = &quot; + NodeType + &quot; and NodeList.Length = &quot; + nodeTypeList_.Length);
+			if (heteroList_ == null)
+			{
+				heteroList_ = new FactoryEntry[NodeType+1];
+			}
+			else
+			{
+				int length = heteroList_.Length;
+
+				if ( NodeType &gt; (length + 1) )
+				{
+					FactoryEntry[] newList = new FactoryEntry[NodeType+1];
+					Array.Copy(heteroList_, 0, newList, 0, heteroList_.Length);
+					heteroList_ = newList;
+				}
+				else if ( NodeType &lt; (length + 1) )
+				{
+					FactoryEntry[] newList = new FactoryEntry[NodeType+1];
+					Array.Copy(heteroList_, 0, newList, 0, (NodeType+1));
+					heteroList_ = newList;
+				}
+			}
+			//Debug.WriteLine(this, &quot;NodeType = &quot; + NodeType + &quot; and NodeList.Length = &quot; + nodeTypeList_.Length);
+		}
+
+		/// &lt;summary&gt;
+		/// Add a child to the current AST
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;currentAST&quot;&gt;The AST to add a child to&lt;/param&gt;
+		/// &lt;param name=&quot;child&quot;&gt;The child AST to be added&lt;/param&gt;
+		public virtual void  addASTChild(ASTPair currentAST, AST child)
+		{
+			if (child != null)
+			{
+				if (currentAST.root == null)
+				{
+					// Make new child the current root
+					currentAST.root = child;
+				}
+				else
+				{
+					if (currentAST.child == null)
+					{
+						// Add new child to current root
+						currentAST.root.setFirstChild(child);
+					}
+					else
+					{
+						currentAST.child.setNextSibling(child);
+					}
+				}
+				// Make new child the current child
+				currentAST.child = child;
+				currentAST.advanceChildToEnd();
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// Creates a new uninitialized AST node. Since a specific AST Node Type
+		/// wasn't indicated, the new AST node is created using the current default
+		/// AST Node type - &lt;see cref=&quot;defaultASTNodeTypeObject_&quot;/&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;An uninitialized AST node object.&lt;/returns&gt;
+		public virtual AST create()
+		{
+			AST newNode;
+			
+			if (defaultCreator_ == null)
+				newNode = createFromNodeTypeObject(defaultASTNodeTypeObject_);
+			else
+				newNode = defaultCreator_.Create();
+
+			return newNode;
+		}
+		
+		/// &lt;summary&gt;
+		/// Creates and initializes a new AST node using the specified Token Type ID.
+		/// The &lt;see cref=&quot;System.Type&quot;/&gt; used for creating this new AST node is 
+		/// determined by the following:
+		/// &lt;list type=&quot;bullet&quot;&gt;
+		///		&lt;item&gt;the current TokenTypeID-to-ASTNodeType mapping (if any) or,&lt;/item&gt;
+		///		&lt;item&gt;the &lt;see cref=&quot;defaultASTNodeTypeObject_&quot;/&gt; otherwise&lt;/item&gt;
+		/// &lt;/list&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;type&quot;&gt;Token type ID to be used to create new AST Node.&lt;/param&gt;
+		/// &lt;returns&gt;An initialized AST node object.&lt;/returns&gt;
+		public virtual AST create(int type)
+		{
+			AST newNode = createFromNodeType(type);
+			newNode.initialize(type, &quot;&quot;);
+			return newNode;
+		}
+		
+		/// &lt;summary&gt;
+		/// Creates and initializes a new AST node using the specified Token Type ID.
+		/// The &lt;see cref=&quot;System.Type&quot;/&gt; used for creating this new AST node is 
+		/// determined by the following:
+		/// &lt;list type=&quot;bullet&quot;&gt;
+		///		&lt;item&gt;the current TokenTypeID-to-ASTNodeType mapping (if any) or,&lt;/item&gt;
+		///		&lt;item&gt;the &lt;see cref=&quot;defaultASTNodeTypeObject_&quot;/&gt; otherwise&lt;/item&gt;
+		/// &lt;/list&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;type&quot;&gt;Token type ID to be used to create new AST Node.&lt;/param&gt;
+		/// &lt;param name=&quot;txt&quot;&gt;Text for initializing the new AST Node.&lt;/param&gt;
+		/// &lt;returns&gt;An initialized AST node object.&lt;/returns&gt;
+		public virtual AST create(int type, string txt)
+		{
+			AST newNode = createFromNodeType(type);
+			newNode.initialize(type, txt);
+			return newNode;
+		}
+		
+		/// &lt;summary&gt;
+		/// Creates a new AST node using the specified AST Node Type name. Once created,
+		/// the new AST node is initialized with the specified Token type ID and string.
+		/// The &lt;see cref=&quot;System.Type&quot;/&gt; used for creating this new AST node is 
+		/// determined solely by &lt;c&gt;ASTNodeTypeName&lt;/c&gt;.
+		/// The AST Node type must have a default/parameterless constructor.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;type&quot;&gt;Token type ID to be used to create new AST Node.&lt;/param&gt;
+		/// &lt;param name=&quot;txt&quot;&gt;Text for initializing the new AST Node.&lt;/param&gt;
+		/// &lt;param name=&quot;ASTNodeTypeName&quot;&gt;Fully qualified name of the Type to be used for creating the new AST Node.&lt;/param&gt;
+		/// &lt;returns&gt;An initialized AST node object.&lt;/returns&gt;
+		public virtual AST create(int type, string txt, string ASTNodeTypeName)
+		{
+			AST newNode = createFromNodeName(ASTNodeTypeName);
+			newNode.initialize(type, txt);
+			return newNode;
+		}
+		
+		/// &lt;summary&gt;
+		/// Creates a new AST node using the specified AST Node Type name.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;tok&quot;&gt;Token instance to be used to initialize the new AST Node.&lt;/param&gt;
+		/// &lt;param name=&quot;ASTNodeTypeName&quot;&gt;
+		///		Fully qualified name of the Type to be used for creating the new AST Node.
+		///	&lt;/param&gt;
+		/// &lt;returns&gt;A newly created and initialized AST node object.&lt;/returns&gt;
+		/// &lt;remarks&gt;
+		/// Once created, the new AST node is initialized with the specified Token 
+		/// instance. The &lt;see cref=&quot;System.Type&quot;/&gt; used for creating this new AST 
+		/// node is  determined solely by &lt;c&gt;ASTNodeTypeName&lt;/c&gt;.
+		/// &lt;para&gt;The AST Node type must have a default/parameterless constructor.&lt;/para&gt;
+		/// &lt;/remarks&gt;
+		public virtual AST create(IToken tok, string ASTNodeTypeName)
+		{
+			AST newNode = createFromNodeName(ASTNodeTypeName);
+			newNode.initialize(tok);
+			return newNode;
+		}
+		
+		/// &lt;summary&gt;
+		/// Creates and initializes a new AST node using the specified AST Node instance.
+		/// the new AST node is initialized with the specified Token type ID and string.
+		/// The &lt;see cref=&quot;System.Type&quot;/&gt; used for creating this new AST node is 
+		/// determined solely by &lt;c&gt;aNode&lt;/c&gt;.
+		/// The AST Node type must have a default/parameterless constructor.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;aNode&quot;&gt;AST Node instance to be used for creating the new AST Node.&lt;/param&gt;
+		/// &lt;returns&gt;An initialized AST node object.&lt;/returns&gt;
+		public virtual AST create(AST aNode)
+		{
+			AST	newNode;
+
+			if (aNode == null)
+				newNode = null;
+			else
+			{			
+				newNode = createFromAST(aNode);
+				newNode.initialize(aNode);
+			}
+			return newNode;
+		}
+		
+		/// &lt;summary&gt;
+		/// Creates and initializes a new AST node using the specified Token instance.
+		/// The &lt;see cref=&quot;System.Type&quot;/&gt; used for creating this new AST node is 
+		/// determined by the following:
+		/// &lt;list type=&quot;bullet&quot;&gt;
+		///		&lt;item&gt;the current TokenTypeID-to-ASTNodeType mapping (if any) or,&lt;/item&gt;
+		///		&lt;item&gt;the &lt;see cref=&quot;defaultASTNodeTypeObject_&quot;/&gt; otherwise&lt;/item&gt;
+		/// &lt;/list&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;tok&quot;&gt;Token instance to be used to create new AST Node.&lt;/param&gt;
+		/// &lt;returns&gt;An initialized AST node object.&lt;/returns&gt;
+		public virtual AST create(IToken tok)
+		{
+			AST newNode;
+
+			if (tok == null)
+				newNode = null;
+			else
+			{
+				newNode = createFromNodeType(tok.Type);
+				newNode.initialize(tok);
+			}
+			return newNode;
+		}
+		
+		/// &lt;summary&gt;
+		/// Returns a copy of the specified AST Node instance. The copy is obtained by
+		/// using the &lt;see cref=&quot;ICloneable&quot;/&gt; method Clone().
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;t&quot;&gt;AST Node to copy.&lt;/param&gt;
+		/// &lt;returns&gt;An AST Node (or null if &lt;c&gt;t&lt;/c&gt; is null).&lt;/returns&gt;
+		public virtual AST dup(AST t)
+		{
+			// The Java version is implemented using code like this:
+			if (t == null)
+				return null;
+
+			AST dup_edNode = createFromAST(t);
+			dup_edNode.initialize(t);
+			return dup_edNode;
+		}
+		
+		/// &lt;summary&gt;
+		/// Duplicate AST Node tree rooted at specified AST node and all of it's siblings.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;t&quot;&gt;Root of AST Node tree.&lt;/param&gt;
+		/// &lt;returns&gt;Root node of new AST Node tree (or null if &lt;c&gt;t&lt;/c&gt; is null).&lt;/returns&gt;
+		public virtual AST dupList(AST t)
+		{
+			AST result = dupTree(t); // if t == null, then result==null
+			AST nt = result;
+			while (t != null)
+			{
+				// for each sibling of the root
+				t = t.getNextSibling();
+				nt.setNextSibling(dupTree(t)); // dup each subtree, building new tree
+				nt = nt.getNextSibling();
+			}
+			return result;
+		}
+		
+		/// &lt;summary&gt;
+		/// Duplicate AST Node tree rooted at specified AST node. Ignore it's siblings.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;t&quot;&gt;Root of AST Node tree.&lt;/param&gt;
+		/// &lt;returns&gt;Root node of new AST Node tree (or null if &lt;c&gt;t&lt;/c&gt; is null).&lt;/returns&gt;
+		public virtual AST dupTree(AST t)
+		{
+			AST result = dup(t); // make copy of root
+			// copy all children of root.
+			if (t != null)
+			{
+				result.setFirstChild(dupList(t.getFirstChild()));
+			}
+			return result;
+		}
+		
+		/// &lt;summary&gt;
+		/// Make a tree from a list of nodes.  The first element in the
+		/// array is the root.  If the root is null, then the tree is
+		/// a simple list not a tree.  Handles null children nodes correctly.
+		/// For example, build(a, b, null, c) yields tree (a b c).  build(null,a,b)
+		/// yields tree (nil a b).
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;nodes&quot;&gt;List of Nodes.&lt;/param&gt;
+		/// &lt;returns&gt;AST Node tree.&lt;/returns&gt;
+		public virtual AST make(params AST[] nodes)
+		{
+			if (nodes == null || nodes.Length == 0)
+				return null;
+			AST root = nodes[0];
+			AST tail = null;
+			if (root != null)
+			{
+				root.setFirstChild(null); // don't leave any old pointers set
+			}
+			// link in children;
+			for (int i = 1; i &lt; nodes.Length; i++)
+			{
+				if (nodes[i] == null)
+					continue;
+				// ignore null nodes
+				if (root == null)
+				{
+					// Set the root and set it up for a flat list
+					root = (tail = nodes[i]);
+				}
+				else if (tail == null)
+				{
+					root.setFirstChild(nodes[i]);
+					tail = root.getFirstChild();
+				}
+				else
+				{
+					tail.setNextSibling(nodes[i]);
+					tail = tail.getNextSibling();
+				}
+				// Chase tail to last sibling
+				while (tail.getNextSibling() != null)
+				{
+					tail = tail.getNextSibling();
+				}
+			}
+			return root;
+		}
+		
+		/// &lt;summary&gt;
+		/// Make a tree from a list of nodes, where the nodes are contained
+		/// in an ASTArray object.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;nodes&quot;&gt;List of Nodes.&lt;/param&gt;
+		/// &lt;returns&gt;AST Node tree.&lt;/returns&gt;
+		public virtual AST make(ASTArray nodes)
+		{
+			return make(nodes.array);
+		}
+		
+		/// &lt;summary&gt;
+		/// Make an AST the root of current AST.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;currentAST&quot;&gt;&lt;/param&gt;
+		/// &lt;param name=&quot;root&quot;&gt;&lt;/param&gt;
+		public virtual void  makeASTRoot(ASTPair currentAST, AST root)
+		{
+			if (root != null)
+			{
+				// Add the current root as a child of new root
+				root.addChild(currentAST.root);
+				// The new current child is the last sibling of the old root
+				currentAST.child = currentAST.root;
+				currentAST.advanceChildToEnd();
+				// Set the new root
+				currentAST.root = root;
+			}
+		}
+
+		/// &lt;summary&gt;
+		/// Sets the global default AST Node Type for this ASTFactory instance.
+		/// This method also attempts to load the &lt;see cref=&quot;System.Type&quot;/&gt; instance
+		/// for the specified typename.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;t&quot;&gt;Fully qualified AST Node Type name.&lt;/param&gt;
+		public virtual void  setASTNodeType(string t)
+		{
+			if (defaultCreator_ != null)
+			{
+				if (t != defaultCreator_.ASTNodeTypeName)
+				{
+					defaultCreator_ = null;
+				}
+			}
+			defaultASTNodeTypeObject_ = loadNodeTypeObject(t);
+		}
+		
+		/// &lt;summary&gt;
+		/// To change where error messages go, can subclass/override this method
+		/// and then setASTFactory in Parser and TreeParser.  This method removes
+		/// a prior dependency on class antlr.Tool.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
+		public virtual void  error(string e)
+		{
+			Console.Error.WriteLine(e);
+		}
+
+		//---------------------------------------------------------------------
+		// PRIVATE FUNCTION MEMBERS
+		//---------------------------------------------------------------------
+
+		private Type loadNodeTypeObject(string nodeTypeName)
+		{
+			Type	nodeTypeObject	= null;
+			bool	typeCreated		= false;
+
+			if (nodeTypeName != null)
+			{
+				foreach (Assembly assem in AppDomain.CurrentDomain.GetAssemblies())
+				{
+					try
+					{
+						nodeTypeObject = assem.GetType(nodeTypeName);
+						if (nodeTypeObject != null)
+						{
+							typeCreated = true;
+							break;
+						}
+					}
+					catch
+					{
+						typeCreated = false;
+					}
+				}
+			}
+			if (!typeCreated)
+			{
+				throw new TypeLoadException(&quot;Unable to load AST Node Type: '&quot; + nodeTypeName + &quot;'&quot;);
+			}
+			return nodeTypeObject;
+		}
+
+		private AST createFromAST(AST node)
+		{
+			AST		newNode			= null;
+			Type	nodeAsTypeObj	= node.GetType();
+
+			ASTNodeCreator creator = (ASTNodeCreator) typename2creator_[nodeAsTypeObj.FullName];
+			if (creator != null)
+			{
+				newNode = creator.Create();
+				if (newNode == null)
+				{
+					throw new ArgumentException(&quot;Unable to create AST Node Type: '&quot; + nodeAsTypeObj.FullName + &quot;'&quot;);
+				}
+			}
+			else
+			{
+				newNode = createFromNodeTypeObject(nodeAsTypeObj);
+			}
+			return newNode;
+		}
+
+		private AST createFromNodeName(string nodeTypeName)
+		{
+			AST		newNode			= null;
+
+			ASTNodeCreator creator = (ASTNodeCreator) typename2creator_[nodeTypeName];
+			if (creator != null)
+			{
+				newNode = creator.Create();
+				if (newNode == null)
+				{
+					throw new ArgumentException(&quot;Unable to create AST Node Type: '&quot; + nodeTypeName + &quot;'&quot;);
+				}
+			}
+			else
+			{
+				newNode = createFromNodeTypeObject( loadNodeTypeObject(nodeTypeName) );
+			}
+			return newNode;
+		}
+
+		private AST createFromNodeType(int nodeTypeIndex)
+		{
+			Debug.Assert((nodeTypeIndex &gt;= 0) &amp;&amp; (nodeTypeIndex &lt;= heteroList_.Length), &quot;Invalid AST node type!&quot;);
+			AST newNode = null;
+
+			FactoryEntry	entry = heteroList_[nodeTypeIndex];
+			if ((entry != null) &amp;&amp; (entry.Creator != null))
+			{
+				newNode = entry.Creator.Create();
+			}
+			else
+			{
+				if ((entry == null) || (entry.NodeTypeObject == null))
+				{
+					if (defaultCreator_ == null)
+					{
+						newNode = createFromNodeTypeObject(defaultASTNodeTypeObject_);
+					}
+					else
+						newNode = defaultCreator_.Create();
+				}
+				else
+                    newNode = createFromNodeTypeObject( entry.NodeTypeObject );
+			}
+			return newNode;
+		}
+
+		private AST createFromNodeTypeObject(Type nodeTypeObject)
+		{
+			AST		newNode			= null;
+
+			try
+			{
+				newNode = (AST) Activator.CreateInstance(nodeTypeObject);
+				if (newNode == null)
+				{
+					throw new ArgumentException(&quot;Unable to create AST Node Type: '&quot; + nodeTypeObject.FullName + &quot;'&quot;);
+				}
+			}
+			catch(Exception ex)
+			{
+				throw new ArgumentException(&quot;Unable to create AST Node Type: '&quot; + nodeTypeObject.FullName + &quot;'&quot;, ex);
+			}
+			return newNode;
+		}
+
+		protected class FactoryEntry
+		{
+			public FactoryEntry(Type typeObj, ASTNodeCreator creator)
+			{
+				NodeTypeObject	= typeObj;
+				Creator			= creator;
+			}
+
+			public FactoryEntry(Type typeObj)
+			{
+				NodeTypeObject	= typeObj;
+			}
+
+			public FactoryEntry(ASTNodeCreator creator)
+			{
+				Creator			= creator;
+			}
+
+			public Type				NodeTypeObject;
+			public ASTNodeCreator	Creator;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/ASTFactory.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/ASTNULLType.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ASTNULLType.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ASTNULLType.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,123 @@
+using System;
+using IEnumerator		= System.Collections.IEnumerator;
+
+using AST				= antlr.collections.AST;
+using Token				= antlr.Token;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*There is only one instance of this class **/
+	public class ASTNULLType : AST
+	{
+		public virtual void  addChild(AST c) {}
+
+		public virtual bool Equals(AST t)
+		{
+			return false;
+		}
+		public virtual bool EqualsList(AST t)
+		{
+			return false;
+		}
+		public virtual bool EqualsListPartial(AST t)
+		{
+			return false;
+		}
+		public virtual bool EqualsTree(AST t)
+		{
+			return false;
+		}
+		public virtual bool EqualsTreePartial(AST t)
+		{
+			return false;
+		}
+		public virtual IEnumerator findAll(AST tree)
+		{
+			return null;
+		}
+		public virtual IEnumerator findAllPartial(AST subtree)
+		{
+			return null;
+		}
+		public virtual AST getFirstChild()
+		{
+			return this;
+		}
+		public virtual AST getNextSibling()
+		{
+			return this;
+		}
+		public virtual string getText()
+		{
+			return &quot;&lt;ASTNULL&gt;&quot;;
+		}
+		public virtual int Type
+		{
+			get { return Token.NULL_TREE_LOOKAHEAD; }
+			set { ; }
+		}
+		public int getNumberOfChildren() 
+		{
+			return 0;
+		}
+		public virtual void  initialize(int t, string txt)
+		{
+		}
+		public virtual void  initialize(AST t)
+		{
+		}
+		public virtual void  initialize(IToken t)
+		{
+		}
+		public virtual void  setFirstChild(AST c)
+		{
+			;
+		}
+		public virtual void  setNextSibling(AST n)
+		{
+			;
+		}
+		public virtual void  setText(string text)
+		{
+			;
+		}
+		public virtual void  setType(int ttype)
+		{
+			this.Type = ttype;
+		}
+		override public string ToString()
+		{
+			return getText();
+		}
+		public virtual string ToStringList()
+		{
+			return getText();
+		}
+		public virtual string ToStringTree()
+		{
+			return getText();
+		}
+
+		#region Implementation of ICloneable
+		public object Clone()
+		{
+			return MemberwiseClone();
+		}
+		#endregion
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/ASTNULLType.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/ASTNodeCreator.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ASTNodeCreator.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ASTNodeCreator.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,52 @@
+namespace antlr
+{
+	using System;
+	using AST		= antlr.collections.AST;
+
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+
+	/// &lt;summary&gt;
+	/// A creator of AST node instances.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	/// &lt;para&gt;
+	/// This class and it's sub-classes exists primarily as an optimization
+	/// of the reflection-based mechanism(s) previously used exclusively to 
+	/// create instances of AST node objects.
+	/// &lt;/para&gt;
+	/// &lt;para&gt;
+	/// Parsers and TreeParsers already use the ASTFactory class in ANTLR whenever
+	/// they need to create an AST node objeect. What this class does is to support
+	/// performant extensibility of the basic ASTFactory. The ASTFactory can now be
+	/// extnded as run-time to support more new AST node types without using needing
+	/// to use reflection.
+	/// &lt;/para&gt;
+	/// &lt;/remarks&gt;
+	public abstract class ASTNodeCreator
+	{
+		/// &lt;summary&gt;
+		/// Returns the fully qualified name of the AST type that this
+		/// class creates.
+		/// &lt;/summary&gt;
+		public abstract string ASTNodeTypeName
+		{
+			get;
+		}
+
+		/// &lt;summary&gt;
+		/// Constructs an &lt;see cref=&quot;AST&quot;/&gt; instance.
+		/// &lt;/summary&gt;
+		public abstract AST Create();
+	}
+}
\ No newline at end of file

Added: trunk/src/antlr-runtime/antlr/ASTPair.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ASTPair.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ASTPair.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,88 @@
+namespace antlr
+{
+	using System;
+	using Queue = System.Collections.Queue;
+	using AST	= antlr.collections.AST;
+
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+
+	/*ASTPair:  utility class used for manipulating a pair of ASTs
+	* representing the current AST root and current AST sibling.
+	* This exists to compensate for the lack of pointers or 'var'
+	* arguments in Java.
+	*/
+
+	public class ASTPair
+	{
+		static private Queue instancePool_ = new Queue();
+
+		static public ASTPair GetInstance()
+		{
+			if (instancePool_.Count &gt; 0)
+			{
+				return (ASTPair) instancePool_.Dequeue();
+			}
+			return new ASTPair();
+		}
+
+		static public void PutInstance(ASTPair p)
+		{
+			if (p != null)
+			{
+				p.reset();
+				instancePool_.Enqueue(p);
+			}
+		}
+
+		public AST root; // current root of tree
+		public AST child; // current child to which siblings are added
+		
+		/*Make sure that child is the last sibling */
+		public void  advanceChildToEnd()
+		{
+			if (child != null)
+			{
+				while (child.getNextSibling() != null)
+				{
+					child = child.getNextSibling();
+				}
+			}
+		}
+		
+		/*Copy an ASTPair.  Don't call it clone() because we want type-safety */
+		public virtual ASTPair copy()
+		{
+			ASTPair tmp = ASTPair.GetInstance();
+			tmp.root = root;
+			tmp.child = child;
+			return tmp;
+		}
+
+		private void reset()
+		{
+			root  = null;
+			child = null;
+		}
+		
+		override public string ToString()
+		{
+			string r = (root == null) ? &quot;null&quot; : root.getText();
+			string c = (child == null) ? &quot;null&quot; : child.getText();
+			return &quot;[&quot; + r + &quot;,&quot; + c + &quot;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/ASTPair.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/ASTVisitor.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ASTVisitor.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ASTVisitor.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,29 @@
+using System;
+
+using AST		= antlr.collections.AST;
+
+namespace antlr
+{
+	/* ANTLR Translator Generator
+	 * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	 * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	 *
+	 * $Id:$
+	 */
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/// &lt;summary&gt;
+	/// Summary description for ASTVisitor.
+	/// &lt;/summary&gt;
+	public interface ASTVisitor
+	{
+		void visit(AST node);
+	}
+}


Property changes on: trunk/src/antlr-runtime/antlr/ASTVisitor.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/BaseAST.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/BaseAST.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/BaseAST.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,616 @@
+using System;
+using StringBuilder		= System.Text.StringBuilder;
+using ISerializable		= System.Runtime.Serialization.ISerializable;
+using TextWriter		= System.IO.TextWriter;
+using ArrayList			= System.Collections.ArrayList;
+using IEnumerator		= System.Collections.IEnumerator;
+
+using AST				= antlr.collections.AST;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*
+	* A Child-Sibling Tree.
+	*
+	* A tree with PLUS at the root and with two children 3 and 4 is
+	* structured as:
+	*
+	*		PLUS
+	*		  |
+	*		  3 -- 4
+	*
+	* and can be specified easily in LISP notation as
+	*
+	* (PLUS 3 4)
+	*
+	* where every '(' starts a new subtree.
+	*
+	* These trees are particular useful for translators because of
+	* the flexibility of the children lists.  They are also very easy
+	* to walk automatically, whereas trees with specific children
+	* reference fields can't easily be walked automatically.
+	*
+	* This class contains the basic support for an AST.
+	* Most people will create ASTs that are subclasses of
+	* BaseAST or of CommonAST.
+	*/
+	[Serializable()] 
+	public abstract class BaseAST : AST
+	{
+		protected internal BaseAST down;
+		protected internal BaseAST right;
+		
+		private static bool verboseStringConversion = false;
+		private static string[] tokenNames = null;
+
+		/*Add a node to the end of the child list for this node */
+		public virtual void  addChild(AST node)
+		{
+			if (node == null)
+				return ;
+			BaseAST t = this.down;
+			if (t != null)
+			{
+				while (t.right != null)
+				{
+					t = t.right;
+				}
+				t.right = (BaseAST) node;
+			}
+			else
+			{
+				this.down = (BaseAST) node;
+			}
+		}
+		
+		private void  doWorkForFindAll(ArrayList v, AST target, bool partialMatch)
+		{
+			AST sibling;
+			
+			// Start walking sibling lists, looking for matches.
+//siblingWalk: 
+			 for (sibling = this; sibling != null; sibling = sibling.getNextSibling())
+			{
+				if ((partialMatch &amp;&amp; sibling.EqualsTreePartial(target)) || (!partialMatch &amp;&amp; sibling.EqualsTree(target)))
+				{
+					v.Add(sibling);
+				}
+				// regardless of match or not, check any children for matches
+				if (sibling.getFirstChild() != null)
+				{
+					((BaseAST) sibling.getFirstChild()).doWorkForFindAll(v, target, partialMatch);
+				}
+			}
+		}
+		
+		public override bool Equals(object obj) 
+		{      
+			if (obj == null) 
+				return false;       			
+			if (this.GetType() != obj.GetType()) 
+				return false;       			
+			return Equals((AST)obj);       
+		}    
+		
+		/*Is node t equal to this in terms of token type and text? */
+		public virtual bool Equals(AST t)
+		{
+			if (t == null)
+				return false;
+
+			return	(Object.Equals(this.getText(), t.getText())) &amp;&amp; 
+					(this.Type == t.Type);
+		}
+		
+		/*Is t an exact structural and equals() match of this tree.  The
+		*  'this' reference is considered the start of a sibling list.
+		*/
+		public virtual bool EqualsList(AST t)
+		{
+			AST sibling;
+			
+			// the empty tree is not a match of any non-null tree.
+			if (t == null)
+			{
+				return false;
+			}
+			
+			// Otherwise, start walking sibling lists.  First mismatch, return false.
+			 for (sibling = this; sibling != null &amp;&amp; t != null; sibling = sibling.getNextSibling(), t = t.getNextSibling())
+			{
+				// as a quick optimization, check roots first.
+				if (!sibling.Equals(t))
+				{
+					return false;
+				}
+				// if roots match, do full list match test on children.
+				if (sibling.getFirstChild() != null)
+				{
+					if (!sibling.getFirstChild().EqualsList(t.getFirstChild()))
+					{
+						return false;
+					}
+				}
+				else if (t.getFirstChild() != null)
+				{
+					return false;
+				}
+			}
+			if (sibling == null &amp;&amp; t == null)
+			{
+				return true;
+			}
+			// one sibling list has more than the other
+			return false;
+		}
+		
+		/*Is 'sub' a subtree of this list?
+		*  The siblings of the root are NOT ignored.
+		*/
+		public virtual bool EqualsListPartial(AST sub)
+		{
+			AST sibling;
+			
+			// the empty tree is always a subset of any tree.
+			if (sub == null)
+			{
+				return true;
+			}
+			
+			// Otherwise, start walking sibling lists.  First mismatch, return false.
+			 for (sibling = this; sibling != null &amp;&amp; sub != null; sibling = sibling.getNextSibling(), sub = sub.getNextSibling())
+			{
+				// as a quick optimization, check roots first.
+				if (!sibling.Equals(sub))
+					return false;
+				// if roots match, do partial list match test on children.
+				if (sibling.getFirstChild() != null)
+				{
+					if (!sibling.getFirstChild().EqualsListPartial(sub.getFirstChild()))
+						return false;
+				}
+			}
+			if (sibling == null &amp;&amp; sub != null)
+			{
+				// nothing left to match in this tree, but subtree has more
+				return false;
+			}
+			// either both are null or sibling has more, but subtree doesn't
+			return true;
+		}
+		
+		/*Is tree rooted at 'this' equal to 't'?  The siblings
+		*  of 'this' are ignored.
+		*/
+		public virtual bool EqualsTree(AST t)
+		{
+			// check roots first.
+			if (!this.Equals(t))
+				return false;
+			// if roots match, do full list match test on children.
+			if (this.getFirstChild() != null)
+			{
+				if (!this.getFirstChild().EqualsList(t.getFirstChild()))
+					return false;
+			}
+			else if (t.getFirstChild() != null)
+			{
+				return false;
+			}
+			return true;
+		}
+		
+		/*Is 't' a subtree of the tree rooted at 'this'?  The siblings
+		*  of 'this' are ignored.
+		*/
+		public virtual bool EqualsTreePartial(AST sub)
+		{
+			// the empty tree is always a subset of any tree.
+			if (sub == null)
+			{
+				return true;
+			}
+			
+			// check roots first.
+			if (!this.Equals(sub))
+				return false;
+			// if roots match, do full list partial match test on children.
+			if (this.getFirstChild() != null)
+			{
+				if (!this.getFirstChild().EqualsListPartial(sub.getFirstChild()))
+					return false;
+			}
+			return true;
+		}
+		
+		/*Walk the tree looking for all exact subtree matches.  Return
+		*  an IEnumerator that lets the caller walk the list
+		*  of subtree roots found herein.
+		*/
+		public virtual IEnumerator findAll(AST target)
+		{
+			ArrayList roots = new ArrayList(10);
+			//AST sibling;
+			
+			// the empty tree cannot result in an enumeration
+			if (target == null)
+			{
+				return null;
+			}
+			
+			doWorkForFindAll(roots, target, false); // find all matches recursively
+			
+			return roots.GetEnumerator();
+		}
+		
+		/*Walk the tree looking for all subtrees.  Return
+		*  an IEnumerator that lets the caller walk the list
+		*  of subtree roots found herein.
+		*/
+		public virtual IEnumerator findAllPartial(AST sub)
+		{
+			ArrayList roots = new ArrayList(10);
+			//AST sibling;
+			
+			// the empty tree cannot result in an enumeration
+			if (sub == null)
+			{
+				return null;
+			}
+			
+			doWorkForFindAll(roots, sub, true); // find all matches recursively
+			
+			return roots.GetEnumerator();
+		}
+		
+		/*Get the first child of this node; null if not children */
+		public virtual AST getFirstChild()
+		{
+			return down;
+		}
+		
+		/*Get the next sibling in line after this one */
+		public virtual AST getNextSibling()
+		{
+			return right;
+		}
+		
+		/*Get the token text for this node */
+		public virtual string getText()
+		{
+			return &quot;&quot;;
+		}
+		
+		/*Get the token type for this node */
+		public virtual int Type
+		{
+			get { return 0; }
+			set { ; }
+		}
+		
+		/// &lt;summary&gt;
+		/// Get number of children of this node; if leaf, returns 0
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;Number of children&lt;/returns&gt;
+		public int getNumberOfChildren() 
+		{
+			BaseAST t = this.down;
+			int n = 0;
+			if (t != null) 
+			{
+				n = 1;
+				while (t.right != null) 
+				{
+					t = t.right;
+					n++;
+				}
+			}
+			return n;
+		}
+
+		public abstract void  initialize(int t, string txt);
+		
+		public abstract void  initialize(AST t);
+		
+		public abstract void  initialize(IToken t);
+		
+		/*Remove all children */
+		public virtual void  removeChildren()
+		{
+			down = null;
+		}
+		
+		public virtual void  setFirstChild(AST c)
+		{
+			down = (BaseAST) c;
+		}
+		
+		public virtual void  setNextSibling(AST n)
+		{
+			right = (BaseAST) n;
+		}
+		
+		/*Set the token text for this node */
+		public virtual void  setText(string text)
+		{
+			;
+		}
+		
+		/*Set the token type for this node */
+		public virtual void  setType(int ttype)
+		{
+			this.Type = ttype;
+		}
+		
+		public static void  setVerboseStringConversion(bool verbose, string[] names)
+		{
+			verboseStringConversion = verbose;
+			tokenNames = names;
+		}
+		
+		override public string ToString()
+		{
+			StringBuilder b = new StringBuilder();
+			// if verbose and type name not same as text (keyword probably)
+			if (verboseStringConversion &amp;&amp; 
+					(0 != String.Compare(getText(), (tokenNames[Type]), true)) &amp;&amp;
+					(0 != String.Compare(getText(), StringUtils.stripFrontBack(tokenNames[Type], @&quot;&quot;&quot;&quot;, @&quot;&quot;&quot;&quot;), true)))
+			{
+				b.Append('[');
+				b.Append(getText());
+				b.Append(&quot;,&lt;&quot;);
+				b.Append(tokenNames[Type]);
+				b.Append(&quot;&gt;]&quot;);
+				return b.ToString();
+			}
+			return getText();
+		}
+		
+		/*Print out a child-sibling tree in LISP notation */
+		public virtual string ToStringList()
+		{
+			AST t = this;
+			string ts = &quot;&quot;;
+			if (t.getFirstChild() != null)
+				ts += &quot; (&quot;;
+			ts += &quot; &quot; + this.ToString();
+			if (t.getFirstChild() != null)
+			{
+				ts += ((BaseAST) t.getFirstChild()).ToStringList();
+			}
+			if (t.getFirstChild() != null)
+				ts += &quot; )&quot;;
+			if (t.getNextSibling() != null)
+			{
+				ts += ((BaseAST) t.getNextSibling()).ToStringList();
+			}
+			return ts;
+		}
+		
+		public virtual string ToStringTree() 
+		{
+			AST t = this;
+			string ts = &quot;&quot;;
+			if (t.getFirstChild() != null) 
+			{
+				ts += &quot; (&quot;;
+			}
+			ts += &quot; &quot; + this.ToString();
+			if (t.getFirstChild() != null)
+			{
+				ts += ((BaseAST) t.getFirstChild()).ToStringList();
+			}
+			if (t.getFirstChild() != null)
+			{
+				ts += &quot; )&quot;;
+			}
+			return ts;
+		 }
+
+		public virtual string ToTree()
+		{
+			return ToTree(string.Empty);
+		}
+		
+		public virtual string ToTree(string prefix) 
+		{
+			StringBuilder sb = new StringBuilder(prefix);
+		
+			// Replace vertical bar if there is no next sibling.
+			if ( (getNextSibling() == null) )
+				sb.Append(&quot;+--&quot;);
+			else
+				sb.Append(&quot;|--&quot;);
+		
+			sb.Append( ToString() );
+			sb.Append( Environment.NewLine );
+
+			if ( getFirstChild() != null ) 
+			{
+				// Replace vertical bar if there is no next sibling.
+				if ( getNextSibling() == null )
+					sb.Append( ((BaseAST) getFirstChild()).ToTree(prefix + &quot;   &quot;) );
+				else
+					sb.Append( ((BaseAST) getFirstChild()).ToTree(prefix + &quot;|  &quot;) );
+			}
+
+			if ( getNextSibling() != null )
+				sb.Append( ((BaseAST) getNextSibling()).ToTree(prefix) );
+
+			return sb.ToString();
+		}
+
+		public static string decode(string text)
+		{
+			char c, c1, c2, c3, c4, c5;
+			StringBuilder n = new StringBuilder();
+			 for (int i = 0; i &lt; text.Length; i++)
+			{
+				c = text[i];
+				if (c == '&amp;')
+				{
+					c1 = text[i + 1];
+					c2 = text[i + 2];
+					c3 = text[i + 3];
+					c4 = text[i + 4];
+					c5 = text[i + 5];
+					
+					if (c1 == 'a' &amp;&amp; c2 == 'm' &amp;&amp; c3 == 'p' &amp;&amp; c4 == ';')
+					{
+						n.Append(&quot;&amp;&quot;);
+						i += 5;
+					}
+					else if (c1 == 'l' &amp;&amp; c2 == 't' &amp;&amp; c3 == ';')
+					{
+						n.Append(&quot;&lt;&quot;);
+						i += 4;
+					}
+					else if (c1 == 'g' &amp;&amp; c2 == 't' &amp;&amp; c3 == ';')
+					{
+						n.Append(&quot;&gt;&quot;);
+						i += 4;
+					}
+					else if (c1 == 'q' &amp;&amp; c2 == 'u' &amp;&amp; c3 == 'o' &amp;&amp; c4 == 't' &amp;&amp; c5 == ';')
+					{
+						n.Append(&quot;\&quot;&quot;);
+						i += 6;
+					}
+					else if (c1 == 'a' &amp;&amp; c2 == 'p' &amp;&amp; c3 == 'o' &amp;&amp; c4 == 's' &amp;&amp; c5 == ';')
+					{
+						n.Append(&quot;'&quot;);
+						i += 6;
+					}
+					else
+						n.Append(&quot;&amp;&quot;);
+				}
+				else
+					n.Append(c);
+			}
+			return n.ToString();
+		}
+		
+		public static string encode(string text)
+		{
+			char c;
+			StringBuilder n = new StringBuilder();
+			 for (int i = 0; i &lt; text.Length; i++)
+			{
+				c = text[i];
+				switch (c)
+				{
+					case '&amp;': 
+					{
+						n.Append(&quot;&amp;&quot;);
+						break;
+					}
+					
+					case '&lt;': 
+					{
+						n.Append(&quot;&lt;&quot;);
+						break;
+					}
+					
+					case '&gt;': 
+					{
+						n.Append(&quot;&gt;&quot;);
+						break;
+					}
+					
+					case '&quot;': 
+					{
+						n.Append(&quot;&quot;&quot;);
+						break;
+					}
+					
+					case '\'': 
+					{
+						n.Append(&quot;&apos;&quot;);
+						break;
+					}
+					
+					default: 
+					{
+						n.Append(c);
+						break;
+					}
+					
+				}
+			}
+			return n.ToString();
+		}
+		
+		public virtual void  xmlSerializeNode(TextWriter outWriter)
+		{
+			StringBuilder buf = new StringBuilder(100);
+			buf.Append(&quot;&lt;&quot;);
+			buf.Append(GetType().FullName + &quot; &quot;);
+			buf.Append(&quot;text=\&quot;&quot; + encode(getText()) + &quot;\&quot; type=\&quot;&quot; + Type + &quot;\&quot;/&gt;&quot;);
+			outWriter.Write(buf.ToString());
+		}
+		
+		public virtual void  xmlSerializeRootOpen(TextWriter outWriter)
+		{
+			StringBuilder buf = new StringBuilder(100);
+			buf.Append(&quot;&lt;&quot;);
+			buf.Append(GetType().FullName + &quot; &quot;);
+			buf.Append(&quot;text=\&quot;&quot; + encode(getText()) + &quot;\&quot; type=\&quot;&quot; + Type + &quot;\&quot;&gt;\n&quot;);
+			outWriter.Write(buf.ToString());
+		}
+		
+		public virtual void  xmlSerializeRootClose(TextWriter outWriter)
+		{
+			outWriter.Write(&quot;&lt;/&quot; + GetType().FullName + &quot;&gt;\n&quot;);
+		}
+		
+		public virtual void  xmlSerialize(TextWriter outWriter)
+		{
+			// print out this node and all siblings
+			 for (AST node = this; node != null; node = node.getNextSibling())
+			{
+				if (node.getFirstChild() == null)
+				{
+					// print guts (class name, attributes)
+					((BaseAST) node).xmlSerializeNode(outWriter);
+				}
+				else
+				{
+					((BaseAST) node).xmlSerializeRootOpen(outWriter);
+					
+					// print children
+					((BaseAST) node.getFirstChild()).xmlSerialize(outWriter);
+					
+					// print end tag
+					((BaseAST) node).xmlSerializeRootClose(outWriter);
+				}
+			}
+		}
+
+		#region Implementation of ICloneable
+		[Obsolete(&quot;Deprecated since version 2.7.2. Use ASTFactory.dup() instead.&quot;, false)]
+		public virtual object Clone()
+		{
+			return MemberwiseClone();
+		}
+		#endregion
+
+		public override Int32 GetHashCode() 
+		{
+			return base.GetHashCode();
+		}	
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/BaseAST.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/ByteBuffer.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ByteBuffer.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ByteBuffer.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,90 @@
+using System;
+using System.Runtime.InteropServices;
+using Stream		= System.IO.Stream;
+using BinaryReader	= System.IO.BinaryReader;
+using IOException	= System.IO.IOException;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*A Stream of characters fed to the lexer from a InputStream that can
+	* be rewound via mark()/rewind() methods.
+	* &lt;p&gt;
+	* A dynamic array is used to buffer up all the input characters.  Normally,
+	* &quot;k&quot; characters are stored in the buffer.  More characters may be stored during
+	* guess mode (testing syntactic predicate), or when LT(i&gt;k) is referenced.
+	* Consumption of characters is deferred.  In other words, reading the next
+	* character is not done by conume(), but deferred until needed by LA or LT.
+	* &lt;p&gt;
+	*/
+
+	// SAS: added this class to handle Binary input w/ FileInputStream
+	
+	public class ByteBuffer:InputBuffer
+	{
+		
+		// char source
+		[NonSerialized()]
+		internal Stream input;
+		
+		private const int BUF_SIZE = 16;
+		/// &lt;summary&gt;
+		/// Small buffer used to avoid reading individual chars
+		/// &lt;/summary&gt;
+		private byte[] buf = new byte[BUF_SIZE];
+
+		
+		/*Create a character buffer */
+		public ByteBuffer(Stream input_) : base()
+		{
+			input = input_;
+		}
+		
+		/*Ensure that the character buffer is sufficiently full */
+		override public void  fill(int amount)
+		{
+//			try
+//			{
+			syncConsume();
+			// Fill the buffer sufficiently to hold needed characters
+			int bytesToRead = (amount + markerOffset) - queue.Count;
+			int c;
+
+			while (bytesToRead &gt; 0)
+			{
+				// Read a few characters
+				c = input.Read(buf, 0, BUF_SIZE);
+				for (int i = 0; i &lt; c; i++)
+				{
+					// Append the next character
+					queue.Add(unchecked((char) buf[i]));
+				}
+				if (c &lt; BUF_SIZE)
+				{
+					queue.Add(CharScanner.EOF_CHAR);
+					break;
+				}
+				bytesToRead -= c;
+			}
+			//			}
+//			catch (IOException io)
+//			{
+//				throw new CharStreamIOException(io);
+//			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/ByteBuffer.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/CharBuffer.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/CharBuffer.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/CharBuffer.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,89 @@
+using System;
+using System.Runtime.InteropServices;
+using TextReader		= System.IO.TextReader;
+using IOException		= System.IO.IOException;
+
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*A Stream of characters fed to the lexer from a InputStream that can
+	* be rewound via mark()/rewind() methods.
+	* &lt;p&gt;
+	* A dynamic array is used to buffer up all the input characters.  Normally,
+	* &quot;k&quot; characters are stored in the buffer.  More characters may be stored during
+	* guess mode (testing syntactic predicate), or when LT(i&gt;k) is referenced.
+	* Consumption of characters is deferred.  In other words, reading the next
+	* character is not done by conume(), but deferred until needed by LA or LT.
+	* &lt;p&gt;
+	*/
+	
+	// SAS: Move most functionality into InputBuffer -- just the file-specific
+	//      stuff is in here
+	public class CharBuffer : InputBuffer
+	{
+		// char source
+		[NonSerialized()]
+		internal TextReader input;
+
+		private const int BUF_SIZE = 16;
+		/// &lt;summary&gt;
+		/// Small buffer used to avoid reading individual chars
+		/// &lt;/summary&gt;
+		private char[] buf = new char[BUF_SIZE];
+
+		
+		/*Create a character buffer */
+		public CharBuffer(TextReader input_) : base()
+		{ 
+			input = input_;
+		}
+		
+		/*Ensure that the character buffer is sufficiently full */
+		override public void  fill(int amount)
+		{
+			try
+			{
+				syncConsume();
+				// Fill the buffer sufficiently to hold needed characters
+				int charsToRead = (amount + markerOffset) - queue.Count;
+				int c;
+
+				while (charsToRead &gt; 0)
+				{
+					// Read a few characters
+					c = input.Read(buf, 0, BUF_SIZE);
+					for (int i = 0; i &lt; c; i++)
+					{
+						// Append the next character
+						queue.Add(buf[i]);
+					}
+					if (c &lt; BUF_SIZE)
+					{
+						queue.Add(CharScanner.EOF_CHAR);
+						break;
+					}
+					charsToRead -= c;
+				}
+			}
+			catch (IOException io)
+			{
+				throw new CharStreamIOException(io);
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/CharBuffer.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/CharQueue.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/CharQueue.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/CharQueue.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,120 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	/*A circular buffer object used by CharBuffer */
+	public class CharQueue
+	{
+		/*Physical circular buffer of tokens */
+		protected internal char[] buffer;
+		/*buffer.length-1 for quick modulos */
+		private int sizeLessOne;
+		/*physical index of front token */
+		private int offset;
+		/*number of tokens in the queue */
+		protected internal int nbrEntries;
+		
+		public CharQueue(int minSize)
+		{
+			// Find first power of 2 &gt;= to requested size
+			int size;
+			if (minSize &lt; 0)
+			{
+				init(16); // pick some value for them
+				return ;
+			}
+			// check for overflow
+			if (minSize &gt;= (Int32.MaxValue / 2))
+			{
+				init(Int32.MaxValue); // wow that's big.
+				return ;
+			}
+			for (size = 2; size &lt; minSize; size *= 2) 
+			{ 
+				;
+			}
+			init(size);
+		}
+		
+		/*Add token to end of the queue
+		* @param tok The token to add
+		*/
+		public void append(char tok)
+		{
+			if (nbrEntries == buffer.Length)
+			{
+				expand();
+			}
+			buffer[(offset + nbrEntries) &amp; sizeLessOne] = tok;
+			nbrEntries++;
+		}
+		
+		/*Fetch a token from the queue by index
+		* @param idx The index of the token to fetch, where zero is the token at the front of the queue
+		*/
+		public char elementAt(int idx)
+		{
+			return buffer[(offset + idx) &amp; sizeLessOne];
+		}
+		
+		/*Expand the token buffer by doubling its capacity */
+		private void  expand()
+		{
+			char[] newBuffer = new char[buffer.Length * 2];
+			// Copy the contents to the new buffer
+			// Note that this will store the first logical item in the
+			// first physical array element.
+			 for (int i = 0; i &lt; buffer.Length; i++)
+			{
+				newBuffer[i] = elementAt(i);
+			}
+			// Re-initialize with new contents, keep old nbrEntries
+			buffer = newBuffer;
+			sizeLessOne = buffer.Length - 1;
+			offset = 0;
+		}
+		
+		/*Initialize the queue.
+		* @param size The initial size of the queue
+		*/
+		public virtual void  init(int size)
+		{
+			// Allocate buffer
+			buffer = new char[size];
+			// Other initialization
+			sizeLessOne = size - 1;
+			offset = 0;
+			nbrEntries = 0;
+		}
+		
+		/*Clear the queue. Leaving the previous buffer alone.
+		*/
+		public void  reset()
+		{
+			offset = 0;
+			nbrEntries = 0;
+		}
+		
+		/*Remove char from front of queue */
+		public void  removeFirst()
+		{
+			offset = (offset + 1) &amp; sizeLessOne;
+			nbrEntries--;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/CharQueue.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/CharScanner.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/CharScanner.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/CharScanner.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,800 @@
+using System;
+using Stream			= System.IO.Stream;
+using TextReader		= System.IO.TextReader;
+using StringBuilder		= System.Text.StringBuilder;
+using Hashtable			= System.Collections.Hashtable;
+using Assembly			= System.Reflection.Assembly;
+using EventHandlerList	= System.ComponentModel.EventHandlerList;
+
+using BitSet			= antlr.collections.impl.BitSet;
+using antlr.debug;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	public abstract class CharScanner : TokenStream, ICharScannerDebugSubject
+	{
+		internal const char NO_CHAR = (char) (0);
+		public static readonly char EOF_CHAR = Char.MaxValue;
+
+		// Used to store event delegates
+		private EventHandlerList events_ = new EventHandlerList();
+
+		protected internal EventHandlerList Events 
+		{
+			get	{ return events_;	}
+		}
+
+		// The unique keys for each event that CharScanner [objects] can generate
+		internal static readonly object EnterRuleEventKey			= new object();
+		internal static readonly object ExitRuleEventKey			= new object();
+		internal static readonly object DoneEventKey				= new object();
+		internal static readonly object ReportErrorEventKey			= new object();
+		internal static readonly object ReportWarningEventKey		= new object();
+		internal static readonly object NewLineEventKey				= new object();
+		internal static readonly object MatchEventKey				= new object();
+		internal static readonly object MatchNotEventKey			= new object();
+		internal static readonly object MisMatchEventKey			= new object();
+		internal static readonly object MisMatchNotEventKey			= new object();
+		internal static readonly object ConsumeEventKey				= new object();
+		internal static readonly object LAEventKey					= new object();
+		internal static readonly object SemPredEvaluatedEventKey	= new object();
+		internal static readonly object SynPredStartedEventKey		= new object();
+		internal static readonly object SynPredFailedEventKey		= new object();
+		internal static readonly object SynPredSucceededEventKey	= new object();
+
+		protected internal StringBuilder text;				// text of current token
+		
+		protected bool saveConsumedInput = true;	// does consume() save characters?
+
+		/// &lt;summary&gt;Used for creating Token instances.&lt;/summary&gt;
+		protected TokenCreator	tokenCreator;
+
+		/// &lt;summary&gt;Used for caching lookahead characters.&lt;/summary&gt;
+		protected char			cached_LA1;
+		protected char			cached_LA2;
+
+		protected bool caseSensitive = true;
+		protected bool caseSensitiveLiterals = true;
+		protected Hashtable literals; // set by subclass
+		
+		/*Tab chars are handled by tab() according to this value; override
+		*  method to do anything weird with tabs.
+		*/
+		protected internal int tabsize = 8;
+		
+		protected internal IToken returnToken_ = null; // used to return tokens w/o using return val.
+		
+		protected internal LexerSharedInputState inputState;
+		
+		/*Used during filter mode to indicate that path is desired.
+		*  A subsequent scan error will report an error as usual if
+		*  acceptPath=true;
+		*/
+		protected internal bool commitToPath = false;
+		
+		/*Used to keep track of indentdepth for traceIn/Out */
+		protected internal int traceDepth = 0;
+		
+		public CharScanner()
+		{
+			text = new StringBuilder();
+			setTokenCreator(new CommonToken.CommonTokenCreator());
+		}
+		
+		public CharScanner(InputBuffer cb) : this()
+		{
+			inputState = new LexerSharedInputState(cb);
+			cached_LA2 = inputState.input.LA(2);
+			cached_LA1 = inputState.input.LA(1);
+		}
+		
+		public CharScanner(LexerSharedInputState sharedState) : this()
+		{
+			inputState = sharedState;
+			if (inputState != null)
+			{
+				cached_LA2 = inputState.input.LA(2);
+				cached_LA1 = inputState.input.LA(1);
+		}
+	}
+		
+
+		public event TraceEventHandler EnterRule
+		{
+			add		{	Events.AddHandler(EnterRuleEventKey, value);	}
+			remove	{	Events.RemoveHandler(EnterRuleEventKey, value);	}
+		}
+
+		public event TraceEventHandler ExitRule
+		{
+			add		{	Events.AddHandler(ExitRuleEventKey, value);		}
+			remove	{	Events.RemoveHandler(ExitRuleEventKey, value);	}
+		}
+
+		public event TraceEventHandler Done
+		{
+			add		{	Events.AddHandler(DoneEventKey, value);		}
+			remove	{	Events.RemoveHandler(DoneEventKey, value);	}
+		}
+
+		public event MessageEventHandler ErrorReported
+		{
+			add		{	Events.AddHandler(ReportErrorEventKey, value);		}
+			remove	{	Events.RemoveHandler(ReportErrorEventKey, value);	}
+		}
+
+		public event MessageEventHandler WarningReported
+		{
+			add		{	Events.AddHandler(ReportWarningEventKey, value);	}
+			remove	{	Events.RemoveHandler(ReportWarningEventKey, value);	}
+		}
+
+		public event NewLineEventHandler HitNewLine
+		{
+			add		{	Events.AddHandler(NewLineEventKey, value);		}
+			remove	{	Events.RemoveHandler(NewLineEventKey, value);	}
+		}
+
+		public event MatchEventHandler MatchedChar
+		{
+			add		{	Events.AddHandler(MatchEventKey, value);	}
+			remove	{	Events.RemoveHandler(MatchEventKey, value);	}
+		}
+
+		public event MatchEventHandler MatchedNotChar
+		{
+			add		{	Events.AddHandler(MatchNotEventKey, value);		}
+			remove	{	Events.RemoveHandler(MatchNotEventKey, value);	}
+		}
+
+		public event MatchEventHandler MisMatchedChar
+		{
+			add		{	Events.AddHandler(MisMatchEventKey, value);		}
+			remove	{	Events.RemoveHandler(MisMatchEventKey, value);	}
+		}
+
+		public event MatchEventHandler MisMatchedNotChar
+		{
+			add		{	Events.AddHandler(MisMatchNotEventKey, value);		}
+			remove	{	Events.RemoveHandler(MisMatchNotEventKey, value);	}
+		}
+
+		public event TokenEventHandler ConsumedChar
+		{
+			add		{	Events.AddHandler(ConsumeEventKey, value);		}
+			remove	{	Events.RemoveHandler(ConsumeEventKey, value);	}
+		}
+
+		public event TokenEventHandler CharLA
+		{
+			add		{	Events.AddHandler(LAEventKey, value);		}
+			remove	{	Events.RemoveHandler(LAEventKey, value);	}
+		}
+
+		public event SemanticPredicateEventHandler SemPredEvaluated
+		{
+			add		{	Events.AddHandler(SemPredEvaluatedEventKey, value);		}
+			remove	{	Events.RemoveHandler(SemPredEvaluatedEventKey, value);	}
+		}
+
+		public event SyntacticPredicateEventHandler SynPredStarted
+		{
+			add		{	Events.AddHandler(SynPredStartedEventKey, value);		}
+			remove	{	Events.RemoveHandler(SynPredStartedEventKey, value);	}
+		}
+
+		public event SyntacticPredicateEventHandler SynPredFailed
+		{
+			add		{	Events.AddHandler(SynPredFailedEventKey, value);	}
+			remove	{	Events.RemoveHandler(SynPredFailedEventKey, value);	}
+		}
+
+		public event SyntacticPredicateEventHandler SynPredSucceeded
+		{
+			add		{	Events.AddHandler(SynPredSucceededEventKey, value);		}
+			remove	{	Events.RemoveHandler(SynPredSucceededEventKey, value);	}
+		}
+
+		// From interface TokenStream
+		public virtual IToken nextToken() { return null; }
+
+		public virtual void  append(char c)
+		{
+			if (saveConsumedInput)
+			{
+				text.Append(c);
+			}
+		}
+		
+		public virtual void  append(string s)
+		{
+			if (saveConsumedInput)
+			{
+				text.Append(s);
+			}
+		}
+		
+		public virtual void  commit()
+		{
+			inputState.input.commit();
+		}
+		
+		public virtual void  consume()
+		{
+			if (inputState.guessing == 0)
+			{
+				if (caseSensitive)
+				{
+					append(cached_LA1);
+				}
+				else
+				{
+					// use input.LA(), not LA(), to get original case
+					// CharScanner.LA() would toLower it.
+					append(inputState.input.LA(1));
+				}
+				if (cached_LA1 == '\t')
+				{
+					tab();
+				}
+				else
+				{
+					inputState.column++;
+				}
+			}
+			if (caseSensitive)
+			{
+				cached_LA1 = inputState.input.consume();
+				cached_LA2 = inputState.input.LA(2);
+			}
+			else
+			{
+				cached_LA1 = toLower(inputState.input.consume());
+				cached_LA2 = toLower(inputState.input.LA(2));
+			}
+		}
+		
+		/*Consume chars until one matches the given char */
+		public virtual void  consumeUntil(int c)
+		{
+			while ((EOF_CHAR != cached_LA1) &amp;&amp; (c != cached_LA1))
+			{
+				consume();
+			}
+		}
+		
+		/*Consume chars until one matches the given set */
+		public virtual void  consumeUntil(BitSet bset)
+		{
+			while (cached_LA1 != EOF_CHAR &amp;&amp; !bset.member(cached_LA1))
+			{
+				consume();
+			}
+		}
+		
+		public virtual bool getCaseSensitive()
+		{
+			return caseSensitive;
+		}
+		
+		public bool getCaseSensitiveLiterals()
+		{
+			return caseSensitiveLiterals;
+		}
+		
+		public virtual int getColumn()
+		{
+			return inputState.column;
+		}
+		
+		public virtual void  setColumn(int c)
+		{
+			inputState.column = c;
+		}
+		
+		public virtual bool getCommitToPath()
+		{
+			return commitToPath;
+		}
+		
+		public virtual string getFilename()
+		{
+			return inputState.filename;
+		}
+		
+		public virtual InputBuffer getInputBuffer()
+		{
+			return inputState.input;
+		}
+		
+		public virtual LexerSharedInputState getInputState()
+		{
+			return inputState;
+		}
+		
+		public virtual void  setInputState(LexerSharedInputState state)
+		{
+			inputState = state;
+		}
+		
+		public virtual int getLine()
+		{
+			return inputState.line;
+		}
+		
+		/*return a copy of the current text buffer */
+		public virtual string getText()
+		{
+			return text.ToString();
+		}
+		
+		public virtual IToken getTokenObject()
+		{
+			return returnToken_;
+		}
+		
+		public virtual char LA(int i)
+		{
+			if (i == 1)
+			{
+				return cached_LA1;
+			}
+			if (i == 2)
+			{
+				return cached_LA2;
+			}
+			if (caseSensitive)
+			{
+				return inputState.input.LA(i);
+			}
+			else
+			{
+				return toLower(inputState.input.LA(i));
+			}
+		}
+		
+		protected internal virtual IToken makeToken(int t)
+		{
+			IToken	newToken	= null;
+			bool	typeCreated;
+
+			try
+			{
+				newToken = tokenCreator.Create();
+				if (newToken != null)
+				{
+					newToken.Type = t;
+					newToken.setColumn(inputState.tokenStartColumn);
+					newToken.setLine(inputState.tokenStartLine);
+					// tracking real start line now: newToken.setLine(inputState.line);
+					newToken.setFilename(inputState.filename);
+				}
+				typeCreated	= true;
+			}
+			catch
+			{
+				typeCreated = false;
+			}
+
+			if (!typeCreated)
+			{
+				panic(&quot;Can't create Token object '&quot; + tokenCreator.TokenTypeName + &quot;'&quot;);
+				newToken = Token.badToken;
+			}
+			return newToken;
+		}
+		
+		public virtual int mark()
+		{
+			return inputState.input.mark();
+		}
+		
+		public virtual void  match(char c)
+		{
+			match((int) c);
+		}
+
+		public virtual void  match(int c)
+		{
+			if (cached_LA1 != c)
+			{
+				throw new MismatchedCharException(cached_LA1, Convert.ToChar(c), false, this);
+			}
+			consume();
+		}
+		
+		public virtual void  match(BitSet b)
+		{
+			if (!b.member(cached_LA1))
+			{
+				throw new MismatchedCharException(cached_LA1, b, false, this);
+			}
+			consume();
+		}
+		
+		public virtual void  match(string s)
+		{
+			int len = s.Length;
+			 for (int i = 0; i &lt; len; i++)
+			{
+				if (cached_LA1 != s[i])
+				{
+					throw new MismatchedCharException(cached_LA1, s[i], false, this);
+				}
+				consume();
+			}
+		}
+		
+		public virtual void  matchNot(char c)
+		{
+			matchNot((int) c);
+		}
+		
+		public virtual void  matchNot(int c)
+		{
+			if (cached_LA1 == c)
+			{
+				throw new MismatchedCharException(cached_LA1, Convert.ToChar(c), true, this);
+			}
+			consume();
+		}
+		
+		public virtual void  matchRange(int c1, int c2)
+		{
+			if (cached_LA1 &lt; c1 || cached_LA1 &gt; c2)
+			{
+				throw new MismatchedCharException(cached_LA1, Convert.ToChar(c1), Convert.ToChar(c2), false, this);
+			}
+			consume();
+		}
+		
+		public virtual void  matchRange(char c1, char c2)
+		{
+			matchRange((int) c1, (int) c2);
+		}
+		
+		public virtual void  newline()
+		{
+			inputState.line++;
+			inputState.column = 1;
+		}
+		
+		/*advance the current column number by an appropriate amount
+		*  according to tab size. This method is called from consume().
+		*/
+		public virtual void  tab()
+		{
+			int c = getColumn();
+			int nc = (((c - 1) / tabsize) + 1) * tabsize + 1; // calculate tab stop
+			setColumn(nc);
+		}
+		
+		public virtual void  setTabSize(int size)
+		{
+			tabsize = size;
+		}
+		
+		public virtual int getTabSize()
+		{
+			return tabsize;
+		}
+		
+		public virtual void panic()
+		{
+			//Console.Error.WriteLine(&quot;CharScanner: panic&quot;);
+			//Environment.Exit(1);
+			panic(&quot;&quot;);
+
+		}
+		
+		/// &lt;summary&gt;
+		/// This method is executed by ANTLR internally when it detected an illegal
+		/// state that cannot be recovered from.
+		/// The previous implementation of this method called &lt;see cref=&quot;Environment.Exit&quot;/&gt;
+		/// and writes directly to &lt;see cref=&quot;Console.Error&quot;/&gt;, which is usually not 
+		/// appropriate when a translator is embedded into a larger application.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;s&quot;&gt;Error message.&lt;/param&gt;
+		public virtual void panic(string s)
+		{
+			//Console.Error.WriteLine(&quot;CharScanner; panic: &quot; + s);
+			//Environment.Exit(1);
+			throw new ANTLRPanicException(&quot;CharScanner::panic: &quot; + s);
+		}
+		
+		/*Parser error-reporting function can be overridden in subclass */
+		public virtual void  reportError(RecognitionException ex)
+		{
+			Console.Error.WriteLine(ex);
+		}
+		
+		/*Parser error-reporting function can be overridden in subclass */
+		public virtual void  reportError(string s)
+		{
+			if (getFilename() == null)
+			{
+				Console.Error.WriteLine(&quot;error: &quot; + s);
+			}
+			else
+			{
+				Console.Error.WriteLine(getFilename() + &quot;: error: &quot; + s);
+			}
+		}
+		
+		/*Parser warning-reporting function can be overridden in subclass */
+		public virtual void  reportWarning(string s)
+		{
+			if (getFilename() == null)
+			{
+				Console.Error.WriteLine(&quot;warning: &quot; + s);
+			}
+			else
+			{
+				Console.Error.WriteLine(getFilename() + &quot;: warning: &quot; + s);
+			}
+		}
+		
+		public virtual void refresh()
+		{
+			if (caseSensitive)
+			{
+				cached_LA2 = inputState.input.LA(2);
+				cached_LA1 = inputState.input.LA(1);
+			}
+			else
+			{
+				cached_LA2 = toLower(inputState.input.LA(2));
+				cached_LA1 = toLower(inputState.input.LA(1));
+			}
+		}
+
+		public virtual void resetState(InputBuffer ib)
+		{
+			text.Length = 0;
+			traceDepth = 0;
+			inputState.resetInput(ib);
+			refresh();
+		}
+
+		public void resetState(Stream s)
+		{
+			resetState(new ByteBuffer(s));
+		}
+
+		public void resetState(TextReader tr)
+		{
+			resetState(new CharBuffer(tr));
+		}
+
+		public virtual void  resetText()
+		{
+			text.Length = 0;
+			inputState.tokenStartColumn = inputState.column;
+			inputState.tokenStartLine = inputState.line;
+		}
+		
+		public virtual void  rewind(int pos)
+		{
+			inputState.input.rewind(pos);
+			//setColumn(inputState.tokenStartColumn);
+			cached_LA2 = inputState.input.LA(2);
+			cached_LA1 = inputState.input.LA(1);
+		}
+		
+		public virtual void  setCaseSensitive(bool t)
+		{
+			caseSensitive = t;
+			if (caseSensitive)
+			{
+				cached_LA2 = inputState.input.LA(2);
+				cached_LA1 = inputState.input.LA(1);
+			}
+			else
+			{
+				cached_LA2 = toLower(inputState.input.LA(2));
+				cached_LA1 = toLower(inputState.input.LA(1));
+			}
+		}
+		
+		public virtual void  setCommitToPath(bool commit)
+		{
+			commitToPath = commit;
+		}
+		
+		public virtual void  setFilename(string f)
+		{
+			inputState.filename = f;
+		}
+		
+		public virtual void  setLine(int line)
+		{
+			inputState.line = line;
+		}
+		
+		public virtual void  setText(string s)
+		{
+			resetText();
+			text.Append(s);
+		}
+		
+		public virtual void  setTokenObjectClass(string cl)
+		{
+			this.tokenCreator = new ReflectionBasedTokenCreator(this, cl);
+		}
+		
+		public virtual void  setTokenCreator(TokenCreator tokenCreator)
+		{
+			this.tokenCreator = tokenCreator;
+		}
+		
+		// Test the token text against the literals table
+		// Override this method to perform a different literals test
+		public virtual int testLiteralsTable(int ttype)
+		{
+			string tokenText = text.ToString();
+
+			if ( (tokenText == null) || (tokenText == string.Empty) )
+				return ttype;
+			else
+			{
+				object typeAsObject = literals[tokenText];
+				return (typeAsObject == null) ? ttype : ((int) typeAsObject);
+			}
+		}
+		
+		/*Test the text passed in against the literals table
+		* Override this method to perform a different literals test
+		* This is used primarily when you want to test a portion of
+		* a token.
+		*/
+		public virtual int testLiteralsTable(string someText, int ttype)
+		{
+			if ( (someText == null) || (someText == string.Empty) )
+				return ttype;
+			else
+			{
+				object typeAsObject = literals[someText];
+				return (typeAsObject == null) ? ttype : ((int) typeAsObject);
+			}
+		}
+		
+		// Override this method to get more specific case handling
+		public virtual char toLower(int c)
+		{
+			return Char.ToLower(Convert.ToChar(c), System.Globalization.CultureInfo.InvariantCulture);
+		}
+		
+		public virtual void  traceIndent()
+		{
+			 for (int i = 0; i &lt; traceDepth; i++)
+				Console.Out.Write(&quot; &quot;);
+		}
+		
+		public virtual void  traceIn(string rname)
+		{
+			traceDepth += 1;
+			traceIndent();
+			Console.Out.WriteLine(&quot;&gt; lexer &quot; + rname + &quot;; c==&quot; + LA(1));
+		}
+		
+		public virtual void  traceOut(string rname)
+		{
+			traceIndent();
+			Console.Out.WriteLine(&quot;&lt; lexer &quot; + rname + &quot;; c==&quot; + LA(1));
+			traceDepth -= 1;
+		}
+		
+		/*This method is called by YourLexer.nextToken() when the lexer has
+		*  hit EOF condition.  EOF is NOT a character.
+		*  This method is not called if EOF is reached during
+		*  syntactic predicate evaluation or during evaluation
+		*  of normal lexical rules, which presumably would be
+		*  an IOException.  This traps the &quot;normal&quot; EOF condition.
+		*
+		*  uponEOF() is called after the complete evaluation of
+		*  the previous token and only if your parser asks
+		*  for another token beyond that last non-EOF token.
+		*
+		*  You might want to throw token or char stream exceptions
+		*  like: &quot;Heh, premature eof&quot; or a retry stream exception
+		*  (&quot;I found the end of this file, go back to referencing file&quot;).
+		*/
+		public virtual void  uponEOF()
+		{
+		}
+
+		private class ReflectionBasedTokenCreator : TokenCreator
+		{
+			protected ReflectionBasedTokenCreator() {}
+
+			public ReflectionBasedTokenCreator(CharScanner owner, string tokenTypeName)
+			{
+				this.owner = owner;
+				SetTokenType(tokenTypeName);
+			}
+
+			private CharScanner owner;
+
+			/// &lt;summary&gt;
+			/// The fully qualified name of the Token type to create.
+			/// &lt;/summary&gt;
+			private string tokenTypeName;
+
+			/// &lt;summary&gt;
+			/// Type object used as a template for creating tokens by reflection.
+			/// &lt;/summary&gt;
+			private Type tokenTypeObject;
+
+			/// &lt;summary&gt;
+			/// Returns the fully qualified name of the Token type that this
+			/// class creates.
+			/// &lt;/summary&gt;
+			private void SetTokenType(string tokenTypeName)
+			{
+				this.tokenTypeName = tokenTypeName;
+				foreach (Assembly assem in AppDomain.CurrentDomain.GetAssemblies())
+				{
+					try
+					{
+						tokenTypeObject = assem.GetType(tokenTypeName);
+						if (tokenTypeObject != null)
+						{
+							break;
+						}
+					}
+					catch
+					{
+						throw new TypeLoadException(&quot;Unable to load Type for Token class '&quot; + tokenTypeName + &quot;'&quot;);
+					}
+				}
+				if (tokenTypeObject==null)
+					throw new TypeLoadException(&quot;Unable to load Type for Token class '&quot; + tokenTypeName + &quot;'&quot;);
+			}
+
+			/// &lt;summary&gt;
+			/// Returns the fully qualified name of the Token type that this
+			/// class creates.
+			/// &lt;/summary&gt;
+			public override string TokenTypeName
+			{
+				get
+				{ 
+					return tokenTypeName; 
+				}
+			}
+
+			/// &lt;summary&gt;
+			/// Constructs a &lt;see cref=&quot;Token&quot;/&gt; instance.
+			/// &lt;/summary&gt;
+			public override IToken Create()
+			{
+				IToken newToken = null;
+
+				try
+				{
+					newToken = (Token) Activator.CreateInstance(tokenTypeObject);
+				}
+				catch
+				{
+					// supress exception
+				}
+				return newToken;
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/CharScanner.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/CharStreamException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/CharStreamException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/CharStreamException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,34 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*
+	* Anything that goes wrong while generating a stream of characters
+	*/
+
+	[Serializable]
+	public class CharStreamException : ANTLRException
+	{
+		/*
+		* CharStreamException constructor comment.
+		*/
+		public CharStreamException(string s) : base(s)
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/CharStreamException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/CharStreamIOException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/CharStreamIOException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/CharStreamIOException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,34 @@
+using System;
+using IOException = System.IO.IOException;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	/*
+	* Wrap an IOException in a CharStreamException
+	*/
+	[Serializable]
+	public class CharStreamIOException : CharStreamException
+	{
+		public IOException io;
+		
+		public CharStreamIOException(IOException io) : base(io.Message)
+		{
+			this.io = io;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/CharStreamIOException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/CommonAST.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/CommonAST.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/CommonAST.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,123 @@
+using System;
+using AST = antlr.collections.AST;
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*Common AST node implementation */
+	public class CommonAST : BaseAST
+	{
+		public static readonly CommonAST.CommonASTCreator Creator = new CommonASTCreator();
+
+		internal int ttype = Token.INVALID_TYPE;
+		internal string text;
+		
+		
+		[Obsolete(&quot;Deprecated since version 2.7.2. Use ASTFactory.dup() instead.&quot;, false)]
+		protected CommonAST(CommonAST another)
+		{
+			// don't include child/sibling pointers in Clone()/dup()
+			//down	= another.down;
+			//right	= another.right;
+			ttype	= another.ttype;
+			text	= (another.text==null) ? null : String.Copy(another.text);
+		}
+
+		/*Get the token text for this node */
+		override public string getText()
+		{
+			return text;
+		}
+		
+		/*Get the token type for this node */
+		override public int Type
+		{
+			get { return ttype;   }
+			set { ttype = value; }
+		}
+		
+		override public void  initialize(int t, string txt)
+		{
+			Type = t;
+			setText(txt);
+		}
+		
+		override public void  initialize(AST t)
+		{
+			setText(t.getText());
+			Type = t.Type;
+		}
+		
+		public CommonAST()
+		{
+		}
+		
+		public CommonAST(IToken tok)
+		{
+			initialize(tok);
+		}
+		
+		override public void  initialize(IToken tok)
+		{
+			setText(tok.getText());
+			Type = tok.Type;
+		}
+		/*Set the token text for this node */
+		override public void  setText(string text_)
+		{
+			text = text_;
+		}
+		/*Set the token type for this node */
+		override public void  setType(int ttype_)
+		{
+			this.Type = ttype_;
+		}
+
+		#region Implementation of ICloneable
+		[Obsolete(&quot;Deprecated since version 2.7.2. Use ASTFactory.dup() instead.&quot;, false)]
+		override public object Clone()
+		{
+			return new CommonAST(this);
+		}
+		#endregion
+
+		public class CommonASTCreator : ASTNodeCreator
+		{
+			public CommonASTCreator() {}
+
+			/// &lt;summary&gt;
+			/// Returns the fully qualified name of the AST type that this
+			/// class creates.
+			/// &lt;/summary&gt;
+			public override string ASTNodeTypeName
+			{
+				get 
+				{ 
+					return typeof(antlr.CommonAST).FullName;; 
+				}
+			}
+
+			/// &lt;summary&gt;
+			/// Constructs a &lt;see cref=&quot;AST&quot;/&gt; instance.
+			/// &lt;/summary&gt;
+			public override AST Create()
+			{
+				return new CommonAST();
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/CommonAST.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/CommonASTWithHiddenTokens.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/CommonASTWithHiddenTokens.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/CommonASTWithHiddenTokens.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,104 @@
+using System;
+using AST		= antlr.collections.AST;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*A CommonAST whose initialization copies hidden token
+	*  information from the Token used to create a node.
+	*/
+
+	public class CommonASTWithHiddenTokens : CommonAST
+	{
+		new public static readonly CommonASTWithHiddenTokens.CommonASTWithHiddenTokensCreator Creator = new CommonASTWithHiddenTokensCreator();
+
+		protected internal IHiddenStreamToken hiddenBefore, hiddenAfter; // references to hidden tokens
+		
+		public CommonASTWithHiddenTokens() : base()
+		{
+		}
+		
+		public CommonASTWithHiddenTokens(IToken tok) : base(tok)
+		{
+		}
+		
+		[Obsolete(&quot;Deprecated since version 2.7.2. Use ASTFactory.dup() instead.&quot;, false)]
+		protected CommonASTWithHiddenTokens(CommonASTWithHiddenTokens another) : base(another)
+		{
+			hiddenBefore	= another.hiddenBefore;
+			hiddenAfter	= another.hiddenAfter;
+		}
+
+		public virtual IHiddenStreamToken getHiddenAfter()
+		{
+			return hiddenAfter;
+		}
+		
+		public virtual IHiddenStreamToken getHiddenBefore()
+		{
+			return hiddenBefore;
+		}
+		
+		override public void initialize(AST t)
+		{
+			hiddenBefore = ((CommonASTWithHiddenTokens) t).getHiddenBefore();
+			hiddenAfter  = ((CommonASTWithHiddenTokens) t).getHiddenAfter();
+			base.initialize(t);
+		}
+
+		override public void initialize(IToken tok)
+		{
+			IHiddenStreamToken t = (IHiddenStreamToken) tok;
+			base.initialize(t);
+			hiddenBefore = t.getHiddenBefore();
+			hiddenAfter  = t.getHiddenAfter();
+		}
+
+		#region Implementation of ICloneable
+		[Obsolete(&quot;Deprecated since version 2.7.2. Use ASTFactory.dup() instead.&quot;, false)]
+		override public object Clone()
+		{
+			return new CommonASTWithHiddenTokens(this);
+		}
+		#endregion
+
+		public class CommonASTWithHiddenTokensCreator : ASTNodeCreator
+		{
+			public CommonASTWithHiddenTokensCreator() {}
+
+			/// &lt;summary&gt;
+			/// Returns the fully qualified name of the AST type that this
+			/// class creates.
+			/// &lt;/summary&gt;
+			public override string ASTNodeTypeName
+			{
+				get 
+				{ 
+					return typeof(antlr.CommonASTWithHiddenTokens).FullName;; 
+				}
+			}
+
+			/// &lt;summary&gt;
+			/// Constructs a &lt;see cref=&quot;AST&quot;/&gt; instance.
+			/// &lt;/summary&gt;
+			public override AST Create()
+			{
+				return new CommonASTWithHiddenTokens();
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/CommonASTWithHiddenTokens.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/CommonHiddenStreamToken.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/CommonHiddenStreamToken.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/CommonHiddenStreamToken.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,84 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	public class CommonHiddenStreamToken : CommonToken, IHiddenStreamToken
+	{
+		new public static readonly CommonHiddenStreamToken.CommonHiddenStreamTokenCreator Creator = new CommonHiddenStreamTokenCreator();
+
+		protected internal IHiddenStreamToken hiddenBefore;
+		protected internal IHiddenStreamToken hiddenAfter;
+		
+		public CommonHiddenStreamToken() : base()
+		{
+		}
+		
+		public CommonHiddenStreamToken(int t, string txt) : base(t, txt)
+		{
+		}
+		
+		public CommonHiddenStreamToken(string s) : base(s)
+		{
+		}
+		
+		public virtual IHiddenStreamToken getHiddenAfter()
+		{
+			return hiddenAfter;
+		}
+		
+		public virtual IHiddenStreamToken getHiddenBefore()
+		{
+			return hiddenBefore;
+		}
+		
+		public virtual void  setHiddenAfter(IHiddenStreamToken t)
+		{
+			hiddenAfter = t;
+		}
+		
+		public virtual void  setHiddenBefore(IHiddenStreamToken t)
+		{
+			hiddenBefore = t;
+		}
+
+		public class CommonHiddenStreamTokenCreator : TokenCreator
+		{
+			public CommonHiddenStreamTokenCreator() {}
+
+			/// &lt;summary&gt;
+			/// Returns the fully qualified name of the Token type that this
+			/// class creates.
+			/// &lt;/summary&gt;
+			public override string TokenTypeName
+			{
+				get 
+				{ 
+					return typeof(antlr.CommonHiddenStreamToken).FullName;; 
+				}
+			}
+
+			/// &lt;summary&gt;
+			/// Constructs a &lt;see cref=&quot;Token&quot;/&gt; instance.
+			/// &lt;/summary&gt;
+			public override IToken Create()
+			{
+				return new CommonHiddenStreamToken();
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/CommonHiddenStreamToken.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/CommonToken.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/CommonToken.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/CommonToken.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,105 @@
+using System;
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	public class CommonToken : Token
+	{
+		public static readonly CommonToken.CommonTokenCreator Creator = new CommonTokenCreator();
+
+		// most tokens will want line and text information
+		protected internal int line;
+		protected internal string text = null;
+		protected internal int col;
+		
+		public CommonToken()
+		{
+		}
+		
+		public CommonToken(int t, string txt)
+		{
+			type_ = t;
+			setText(txt);
+		}
+		
+		public CommonToken(string s)
+		{
+			text = s;
+		}
+		
+		override public int getLine()
+		{
+			return line;
+		}
+		
+		override public string getText()
+		{
+			return text;
+		}
+		
+		override public void  setLine(int l)
+		{
+			line = l;
+		}
+		
+		override public void  setText(string s)
+		{
+			text = s;
+		}
+		
+		override public string ToString()
+		{
+			return &quot;[\&quot;&quot; + getText() + &quot;\&quot;,&lt;&quot; + type_ + &quot;&gt;,line=&quot; + line + &quot;,col=&quot; + col + &quot;]&quot;;
+		}
+		
+		/*Return token's start column */
+		override public int getColumn()
+		{
+			return col;
+		}
+		
+		override public void  setColumn(int c)
+		{
+			col = c;
+		}
+
+		public class CommonTokenCreator : TokenCreator
+		{
+			public CommonTokenCreator() {}
+
+			/// &lt;summary&gt;
+			/// Returns the fully qualified name of the Token type that this
+			/// class creates.
+			/// &lt;/summary&gt;
+			public override string TokenTypeName
+			{
+				get 
+				{ 
+					return typeof(antlr.CommonToken).FullName;; 
+				}
+			}
+
+			/// &lt;summary&gt;
+			/// Constructs a &lt;see cref=&quot;Token&quot;/&gt; instance.
+			/// &lt;/summary&gt;
+			public override IToken Create()
+			{
+				return new CommonToken();
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/CommonToken.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/DefaultFileLineFormatter.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/DefaultFileLineFormatter.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/DefaultFileLineFormatter.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,48 @@
+using System;
+using StringBuilder			= System.Text.StringBuilder;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	public class DefaultFileLineFormatter : FileLineFormatter
+	{
+		public override string getFormatString(string fileName, int line, int column)
+		{
+			StringBuilder buf = new StringBuilder();
+			
+			if (fileName != null)
+				buf.Append(fileName + &quot;:&quot;);
+			
+			if (line != - 1)
+			{
+				if (fileName == null)
+					buf.Append(&quot;line &quot;);
+				
+				buf.Append(line);
+				
+				if (column != - 1)
+					buf.Append(&quot;:&quot; + column);
+				
+				buf.Append(&quot;:&quot;);
+			}
+			
+			buf.Append(&quot; &quot;);
+			
+			return buf.ToString();
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/DefaultFileLineFormatter.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/DumpASTVisitor.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/DumpASTVisitor.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/DumpASTVisitor.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,95 @@
+using System;
+
+using AST			= antlr.collections.AST;
+
+namespace antlr
+{
+	/* ANTLR Translator Generator
+	 * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	 * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	 *
+	 * $Id:$
+	 */
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	/// &lt;summary&gt;
+	/// Summary description for DumpASTVisitor.
+	/// &lt;/summary&gt;
+	/** Simple class to dump the contents of an AST to the output */
+	public class DumpASTVisitor : ASTVisitor 
+	{
+		protected int level = 0;
+
+
+		private void tabs() 
+		{
+			for (int i = 0; i &lt; level; i++) 
+			{
+				Console.Out.Write(&quot;   &quot;);
+			}
+		}
+
+		public void visit(AST node) 
+		{
+			// Flatten this level of the tree if it has no children
+			bool flatten = /*true*/ false;
+			AST node2;
+			for (node2 = node; node2 != null; node2 = node2.getNextSibling()) 
+			{
+				if (node2.getFirstChild() != null) 
+				{
+					flatten = false;
+					break;
+				}
+			}
+
+			for (node2 = node; node2 != null; node2 = node2.getNextSibling()) 
+			{
+				if (!flatten || node2 == node) 
+				{
+					tabs();
+				}
+				if (node2.getText() == null) 
+				{
+					Console.Out.Write(&quot;nil&quot;);
+				}
+				else 
+				{
+					Console.Out.Write(node2.getText());
+				}
+
+				Console.Out.Write(&quot; [&quot; + node2.Type + &quot;] &quot;);
+
+				if (flatten) 
+				{
+					Console.Out.Write(&quot; &quot;);
+				}
+				else 
+				{
+					Console.Out.WriteLine(&quot;&quot;);
+				}
+
+				if (node2.getFirstChild() != null) 
+				{
+					level++;
+					visit(node2.getFirstChild());
+					level--;
+				}
+			}
+
+			if (flatten) 
+			{
+				Console.Out.WriteLine(&quot;&quot;);
+			}
+		}
+	}  
+}
+
+


Property changes on: trunk/src/antlr-runtime/antlr/DumpASTVisitor.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/FileLineFormatter.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/FileLineFormatter.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/FileLineFormatter.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,41 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	public abstract class FileLineFormatter
+	{
+		
+		private static FileLineFormatter formatter = new DefaultFileLineFormatter();
+		
+		public static FileLineFormatter getFormatter()
+		{
+			return formatter;
+		}
+		
+		public static void  setFormatter(FileLineFormatter f)
+		{
+			formatter = f;
+		}
+		
+		/*@param fileName the file that should appear in the prefix. (or null)
+		* @param line the line (or -1)
+		* @param column the column (or -1)
+		*/
+		public abstract string getFormatString(string fileName, int line, int column);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/FileLineFormatter.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/IHiddenStreamToken.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/IHiddenStreamToken.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/IHiddenStreamToken.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,28 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	public interface IHiddenStreamToken : IToken
+	{
+		IHiddenStreamToken	getHiddenAfter();
+		void				setHiddenAfter(IHiddenStreamToken t);
+
+		IHiddenStreamToken	getHiddenBefore();
+		void				setHiddenBefore(IHiddenStreamToken t);
+	}
+}
\ No newline at end of file

Added: trunk/src/antlr-runtime/antlr/IToken.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/IToken.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/IToken.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,40 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/// &lt;summary&gt;
+	/// A token is minimally a token type.  Subclasses can add the text matched
+	/// for the token and line info. 
+	/// &lt;/summary&gt;
+	public interface IToken
+	{
+		int		getColumn();
+		void	setColumn(int c);
+
+		int		getLine();
+		void	setLine(int l);
+
+		string	getFilename();
+		void	setFilename(string name);
+
+		string	getText();
+		void	setText(string t);
+
+		int		Type { get; set; }
+	}
+}
\ No newline at end of file

Added: trunk/src/antlr-runtime/antlr/InputBuffer.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/InputBuffer.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/InputBuffer.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,165 @@
+namespace antlr
+{
+	using System;
+	using ArrayList		= System.Collections.ArrayList;
+	using StringBuilder	= System.Text.StringBuilder;
+
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	// SAS: Added this class to genericise the input buffers for scanners
+	//      This allows a scanner to use a binary (FileInputStream) or
+	//      text (FileReader) stream of data; the generated scanner
+	//      subclass will define the input stream
+	//      There are two subclasses to this: CharBuffer and ByteBuffer
+	
+	/// &lt;summary&gt;
+	/// Represents a stream of characters fed to the lexer from that can be rewound 
+	/// via mark()/rewind() methods.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	/// &lt;para&gt;
+	/// A dynamic array is used to buffer up all the input characters.  Normally,
+	/// &quot;k&quot; characters are stored in the buffer.  More characters may be stored 
+	/// during guess mode (testing syntactic predicate), or when LT(i&gt;k) is referenced.
+	/// Consumption of characters is deferred.  In other words, reading the next
+	/// character is not done by conume(), but deferred until needed by LA or LT.
+	/// &lt;/para&gt;
+	/// &lt;/remarks&gt;
+	public abstract class InputBuffer
+	{
+		// Number of active markers
+		protected internal int nMarkers = 0;
+		
+		// Additional offset used when markers are active
+		protected internal int markerOffset = 0;
+		
+		// Number of calls to consume() since last LA() or LT() call
+		protected internal int numToConsume = 0;
+		
+		// Circular queue
+		protected ArrayList	queue;
+		
+		/*Create an input buffer */
+		public InputBuffer()
+		{
+			queue = new ArrayList();
+		}
+		
+		/*This method updates the state of the input buffer so that
+		*  the text matched since the most recent mark() is no longer
+		*  held by the buffer.  So, you either do a mark/rewind for
+		*  failed predicate or mark/commit to keep on parsing without
+		*  rewinding the input.
+		*/
+		public virtual void  commit()
+		{
+			nMarkers--;
+		}
+		
+		/*Mark another character for deferred consumption */
+		public virtual char consume()
+		{
+			numToConsume++;
+			return LA(1);
+		}
+		
+		/*Ensure that the input buffer is sufficiently full */
+		public abstract void  fill(int amount);
+		
+		public virtual string getLAChars()
+		{
+			StringBuilder la = new StringBuilder();
+
+			// copy buffer contents to array before looping thru contents (it's usually faster)
+			char[] fastBuf = new char[queue.Count-markerOffset];
+			queue.CopyTo(fastBuf, markerOffset);
+
+			la.Append(fastBuf);
+			return la.ToString();
+		}
+		
+		public virtual string getMarkedChars()
+		{
+			StringBuilder marked = new StringBuilder();
+
+			// copy buffer contents to array before looping thru contents (it's usually faster)
+			char[] fastBuf = new char[queue.Count-markerOffset];
+			queue.CopyTo(fastBuf, markerOffset);
+
+			marked.Append(fastBuf);
+			return marked.ToString();
+		}
+		
+		public virtual bool isMarked()
+		{
+			return (nMarkers != 0);
+		}
+		
+		/*Get a lookahead character */
+		public virtual char LA(int i)
+		{
+			fill(i);
+			return (char) queue[markerOffset + i - 1];
+		}
+		
+		/*Return an integer marker that can be used to rewind the buffer to
+		* its current state.
+		*/
+		public virtual int mark()
+		{
+			syncConsume();
+			nMarkers++;
+			return markerOffset;
+		}
+		
+		/*Rewind the character buffer to a marker.
+		* @param mark Marker returned previously from mark()
+		*/
+		public virtual void  rewind(int mark)
+		{
+			syncConsume();
+			markerOffset = mark;
+			nMarkers--;
+		}
+		
+		/*Reset the input buffer
+		*/
+		public virtual void  reset()
+		{
+			nMarkers = 0;
+			markerOffset = 0;
+			numToConsume = 0;
+			queue.Clear();
+		}
+		
+		/*Sync up deferred consumption */
+		protected internal virtual void  syncConsume()
+		{
+			if (numToConsume &gt; 0)
+			{
+				if (nMarkers &gt; 0)
+				{
+					// guess mode -- leave leading characters and bump offset.
+					markerOffset += numToConsume;
+				}
+				else
+				{
+					// normal mode -- remove &quot;consumed&quot; characters from buffer
+					queue.RemoveRange(0, numToConsume);
+				}
+				numToConsume = 0;
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/InputBuffer.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/LLkParser.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/LLkParser.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/LLkParser.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,100 @@
+using System;
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*An LL(k) parser.
+	*
+	* @see antlr.Token
+	* @see antlr.TokenBuffer
+	* @see antlr.LL1Parser
+	*/
+	public class LLkParser : Parser
+	{
+		internal int k;
+		
+		public LLkParser(int k_)
+		{
+			k = k_;
+		}
+		public LLkParser(ParserSharedInputState state, int k_)
+		{
+			k = k_;
+			inputState = state;
+		}
+		public LLkParser(TokenBuffer tokenBuf, int k_)
+		{
+			k = k_;
+			setTokenBuffer(tokenBuf);
+		}
+		public LLkParser(TokenStream lexer, int k_)
+		{
+			k = k_;
+			TokenBuffer tokenBuf = new TokenBuffer(lexer);
+			setTokenBuffer(tokenBuf);
+		}
+		/*Consume another token from the input stream.  Can only write sequentially!
+		* If you need 3 tokens ahead, you must consume() 3 times.
+		* &lt;p&gt;
+		* Note that it is possible to overwrite tokens that have not been matched.
+		* For example, calling consume() 3 times when k=2, means that the first token
+		* consumed will be overwritten with the 3rd.
+		*/
+		override public void  consume()
+		{
+			inputState.input.consume();
+		}
+		override public int LA(int i)
+		{
+			return inputState.input.LA(i);
+		}
+		override public IToken LT(int i)
+		{
+			return inputState.input.LT(i);
+		}
+		private void  trace(string ee, string rname)
+		{
+			traceIndent();
+			Console.Out.Write(ee + rname + ((inputState.guessing &gt; 0)?&quot;; [guessing]&quot;:&quot;; &quot;));
+			 for (int i = 1; i &lt;= k; i++)
+			{
+				if (i != 1)
+				{
+					Console.Out.Write(&quot;, &quot;);
+				}
+				if ( LT(i)!=null ) {
+					Console.Out.Write(&quot;LA(&quot; + i + &quot;)==&quot; + LT(i).getText());
+				}
+				else 
+				{
+					Console.Out.Write(&quot;LA(&quot; + i + &quot;)==ull&quot;);
+				}
+			}
+			Console.Out.WriteLine(&quot;&quot;);
+		}
+		override public void  traceIn(string rname)
+		{
+			traceDepth += 1;
+			trace(&quot;&gt; &quot;, rname);
+		}
+		override public void  traceOut(string rname)
+		{
+			trace(&quot;&lt; &quot;, rname);
+			traceDepth -= 1;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/LLkParser.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/LexerSharedInputState.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/LexerSharedInputState.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/LexerSharedInputState.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,88 @@
+using System;
+using Stream			= System.IO.Stream;
+using TextReader		= System.IO.TextReader;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*This object contains the data associated with an
+	*  input stream of characters.  Multiple lexers
+	*  share a single LexerSharedInputState to lex
+	*  the same input stream.
+	*/
+	public class LexerSharedInputState
+	{
+		protected internal int column;
+		protected internal int line;
+		protected internal int tokenStartColumn;
+		protected internal int tokenStartLine;
+		protected internal InputBuffer input;
+		
+		/*What file (if known) caused the problem? */
+		protected internal string filename;
+		
+		public int guessing;
+		
+		public LexerSharedInputState(InputBuffer inbuf)
+		{
+			initialize();
+			input = inbuf;
+		}
+		
+		public LexerSharedInputState(Stream inStream) : this(new ByteBuffer(inStream))
+		{
+		}
+		
+		public LexerSharedInputState(TextReader inReader) : this(new CharBuffer(inReader))
+		{
+		}
+		
+		private void initialize()
+		{
+			column = 1;
+			line = 1;
+			tokenStartColumn = 1;
+			tokenStartLine = 1;
+			guessing = 0;
+			filename = null;
+		}
+		
+		public virtual void reset()
+		{
+			initialize();
+			input.reset();
+		}
+
+		public virtual void resetInput(InputBuffer ib)
+		{
+			reset();
+			input = ib;
+		}
+
+		public virtual void resetInput(Stream s)
+		{
+			reset();
+			input = new ByteBuffer(s);
+		}
+
+		public virtual void resetInput(TextReader tr)
+		{
+			reset();
+			input = new CharBuffer(tr);
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/LexerSharedInputState.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/MismatchedCharException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/MismatchedCharException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/MismatchedCharException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,179 @@
+using System;
+using StringBuilder			= System.Text.StringBuilder;
+
+using BitSet				= antlr.collections.impl.BitSet;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	[Serializable]
+	public class MismatchedCharException : RecognitionException
+	{
+		/*
+		* Returns a clean error message (no line number/column information)
+		*/
+		override public string Message
+		{
+			get 
+			{
+				StringBuilder sb = new StringBuilder();
+			
+				switch (mismatchType)
+				{
+					case CharTypeEnum.CharType: 
+						sb.Append(&quot;expecting &quot;);   appendCharName(sb, expecting);
+						sb.Append(&quot;, found &quot;);     appendCharName(sb, foundChar);
+						break;
+				
+					case CharTypeEnum.NotCharType: 
+						sb.Append(&quot;expecting anything but '&quot;);
+						appendCharName(sb, expecting);
+						sb.Append(&quot;'; got it anyway&quot;);
+						break;
+				
+					case CharTypeEnum.RangeType: 				
+					case CharTypeEnum.NotRangeType: 
+						sb.Append(&quot;expecting token &quot;);
+						if (mismatchType == CharTypeEnum.NotRangeType)
+							sb.Append(&quot;NOT &quot;);
+						sb.Append(&quot;in range: &quot;);
+						appendCharName(sb, expecting);
+						sb.Append(&quot;..&quot;);
+						appendCharName(sb, upper);
+						sb.Append(&quot;, found &quot;);
+						appendCharName(sb, foundChar);
+						break;
+				
+					case CharTypeEnum.SetType: 
+					case CharTypeEnum.NotSetType: 
+						sb.Append(&quot;expecting &quot; + (mismatchType == CharTypeEnum.NotSetType ? &quot;NOT &quot; : &quot;&quot;) + &quot;one of (&quot;);
+						int[] elems = bset.toArray();
+						for (int i = 0; i &lt; elems.Length; i++) 
+						{
+							appendCharName(sb, elems[i]);
+						}
+						sb.Append(&quot;), found &quot;);
+						appendCharName(sb, foundChar);
+						break;
+				
+					default: 
+						sb.Append(base.Message);
+						break;				
+				}			
+				return sb.ToString();
+			}
+		}
+
+		// Types of chars
+
+		public enum CharTypeEnum
+		{
+			CharType = 1,
+			NotCharType = 2,
+			RangeType = 3,
+			NotRangeType = 4,
+			SetType = 5,
+			NotSetType = 6
+		}
+		
+		// One of the above
+		public CharTypeEnum mismatchType;
+		
+		// what was found on the input stream
+		public int foundChar;
+		
+		// For CHAR/NOT_CHAR and RANGE/NOT_RANGE
+		public int expecting;
+		
+		// For RANGE/NOT_RANGE (expecting is lower bound of range)
+		public int upper;
+		
+		// For SET/NOT_SET
+		public BitSet bset;
+		
+		// who knows...they may want to ask scanner questions
+		public CharScanner scanner;
+		
+		/*
+		* MismatchedCharException constructor comment.
+		*/
+		public MismatchedCharException() : base(&quot;Mismatched char&quot;)
+		{
+		}
+		
+		// Expected range / not range
+		public MismatchedCharException(char c, char lower, char upper_, bool matchNot, CharScanner scanner_) : 
+					base(&quot;Mismatched char&quot;, scanner_.getFilename(), scanner_.getLine(), scanner_.getColumn())
+		{
+			mismatchType = matchNot ? CharTypeEnum.NotRangeType : CharTypeEnum.RangeType;
+			foundChar = c;
+			expecting = lower;
+			upper = upper_;
+			scanner = scanner_;
+		}
+		
+		// Expected token / not token
+		public MismatchedCharException(char c, char expecting_, bool matchNot, CharScanner scanner_) : 
+					base(&quot;Mismatched char&quot;, scanner_.getFilename(), scanner_.getLine(), scanner_.getColumn())
+		{
+			mismatchType = matchNot ? CharTypeEnum.NotCharType : CharTypeEnum.CharType;
+			foundChar = c;
+			expecting = expecting_;
+			scanner = scanner_;
+		}
+		
+		// Expected BitSet / not BitSet
+		public MismatchedCharException(char c, BitSet set_, bool matchNot, CharScanner scanner_) :
+					base(&quot;Mismatched char&quot;, scanner_.getFilename(), scanner_.getLine(), scanner_.getColumn())
+		{
+			mismatchType = matchNot ? CharTypeEnum.NotSetType : CharTypeEnum.SetType;
+			foundChar = c;
+			bset = set_;
+			scanner = scanner_;
+		}		
+
+		/// &lt;summary&gt;
+		/// Append a char to the msg buffer.  If special, then show escaped version
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;sb&quot;&gt;Message buffer&lt;/param&gt;
+		/// &lt;param name=&quot;c&quot;&gt;Char to append&lt;/param&gt;
+		private void appendCharName(StringBuilder sb, int c) 
+		{
+			switch (c) 
+			{
+				case 65535 :
+					// 65535 = (char) -1 = EOF
+					sb.Append(&quot;'&lt;EOF&gt;'&quot;);
+					break;
+				case '\n' :
+					sb.Append(@&quot;'\n'&quot;);
+					break;
+				case '\r' :
+					sb.Append(@&quot;'\r'&quot;);
+					break;
+				case '\t' :
+					sb.Append(@&quot;'\t'&quot;);
+					break;
+				default :
+					sb.Append('\'');
+					sb.Append((char) c);
+					sb.Append('\'');
+					break;
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/MismatchedCharException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/MismatchedTokenException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/MismatchedTokenException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/MismatchedTokenException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,214 @@
+using System;
+using StringBuilder			= System.Text.StringBuilder;
+
+using BitSet				= antlr.collections.impl.BitSet;
+using AST					= antlr.collections.AST;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	[Serializable]
+	public class MismatchedTokenException : RecognitionException
+	{
+		// Token names array for formatting
+		internal string[] tokenNames;
+		// The token that was encountered
+		public IToken token;
+		// The offending AST node if tree walking
+		public AST node;
+		
+		internal string tokenText = null; // taken from node or token object
+		
+		// Types of tokens
+		public enum TokenTypeEnum
+		{
+			TokenType = 1,
+			NotTokenType = 2,
+			RangeType = 3,
+			NotRangeType = 4,
+			SetType = 5,
+			NotSetType = 6
+		}
+		// One of the above
+		public TokenTypeEnum mismatchType;
+		
+		// For TOKEN/NOT_TOKEN and RANGE/NOT_RANGE
+		public int expecting;
+		
+		// For RANGE/NOT_RANGE (expecting is lower bound of range)
+		public int upper;
+		
+		// For SET/NOT_SET
+		public BitSet bset;
+		
+		/*Looking for AST wildcard, didn't find it */
+		public MismatchedTokenException() : base(&quot;Mismatched Token: expecting any AST node&quot;, &quot;&lt;AST&gt;&quot;, - 1, - 1)
+		{
+		}
+		
+		// Expected range / not range
+		public MismatchedTokenException(string[] tokenNames_, AST node_, int lower, int upper_, bool matchNot) : 
+					base(&quot;Mismatched Token&quot;, &quot;&lt;AST&gt;&quot;, - 1, - 1)
+		{
+			tokenNames = tokenNames_;
+			node = node_;
+			if (node_ == null)
+			{
+				tokenText = &quot;&lt;empty tree&gt;&quot;;
+			}
+			else
+			{
+				tokenText = node_.ToString();
+			}
+			mismatchType = matchNot ? TokenTypeEnum.NotRangeType : TokenTypeEnum.RangeType;
+			expecting = lower;
+			upper = upper_;
+		}
+		
+		// Expected token / not token
+		public MismatchedTokenException(string[] tokenNames_, AST node_, int expecting_, bool matchNot) :
+					base(&quot;Mismatched Token&quot;, &quot;&lt;AST&gt;&quot;, - 1, - 1)
+		{
+			tokenNames = tokenNames_;
+			node = node_;
+			if (node_ == null)
+			{
+				tokenText = &quot;&lt;empty tree&gt;&quot;;
+			}
+			else
+			{
+				tokenText = node_.ToString();
+			}
+			mismatchType = matchNot ? TokenTypeEnum.NotTokenType : TokenTypeEnum.TokenType;
+			expecting = expecting_;
+		}
+		
+		// Expected BitSet / not BitSet
+		public MismatchedTokenException(string[] tokenNames_, AST node_, BitSet set_, bool matchNot) :
+					base(&quot;Mismatched Token&quot;, &quot;&lt;AST&gt;&quot;, - 1, - 1)
+		{
+			tokenNames = tokenNames_;
+			node = node_;
+			if (node_ == null)
+			{
+				tokenText = &quot;&lt;empty tree&gt;&quot;;
+			}
+			else
+			{
+				tokenText = node_.ToString();
+			}
+			mismatchType = matchNot ? TokenTypeEnum.NotSetType : TokenTypeEnum.SetType;
+			bset = set_;
+		}
+		
+		// Expected range / not range
+		public MismatchedTokenException(string[] tokenNames_, IToken token_, int lower, int upper_, bool matchNot, string fileName_) : 
+					base(&quot;Mismatched Token&quot;, fileName_, token_.getLine(), token_.getColumn())
+		{
+			tokenNames = tokenNames_;
+			token = token_;
+			tokenText = token_.getText();
+			mismatchType = matchNot ? TokenTypeEnum.NotRangeType : TokenTypeEnum.RangeType;
+			expecting = lower;
+			upper = upper_;
+		}
+		
+		// Expected token / not token
+		public MismatchedTokenException(string[] tokenNames_, IToken token_, int expecting_, bool matchNot, string fileName_) :
+					base(&quot;Mismatched Token&quot;, fileName_, token_.getLine(), token_.getColumn())
+		{
+			tokenNames = tokenNames_;
+			token = token_;
+			tokenText = token_.getText();
+			mismatchType = matchNot ? TokenTypeEnum.NotTokenType : TokenTypeEnum.TokenType;
+			expecting = expecting_;
+		}
+		
+		// Expected BitSet / not BitSet
+		public MismatchedTokenException(string[] tokenNames_, IToken token_, BitSet set_, bool matchNot, string fileName_) :
+					base(&quot;Mismatched Token&quot;, fileName_, token_.getLine(), token_.getColumn())
+		{
+			tokenNames = tokenNames_;
+			token = token_;
+			tokenText = token_.getText();
+			mismatchType = matchNot ? TokenTypeEnum.NotSetType : TokenTypeEnum.SetType;
+			bset = set_;
+		}
+		
+		/*
+		* Returns a clean error message (no line number/column information)
+		*/
+		override public string Message
+		{
+			get 
+			{
+				StringBuilder sb = new StringBuilder();
+			
+				switch (mismatchType)
+				{
+					case TokenTypeEnum.TokenType: 
+						sb.Append(&quot;expecting &quot; + tokenName(expecting) + &quot;, found '&quot; + tokenText + &quot;'&quot;);
+						break;
+				
+					case TokenTypeEnum.NotTokenType: 
+						sb.Append(&quot;expecting anything but &quot; + tokenName(expecting) + &quot;; got it anyway&quot;);
+						break;
+				
+					case TokenTypeEnum.RangeType: 
+						sb.Append(&quot;expecting token in range: &quot; + tokenName(expecting) + &quot;..&quot; + tokenName(upper) + &quot;, found '&quot; + tokenText + &quot;'&quot;);
+						break;
+				
+					case TokenTypeEnum.NotRangeType: 
+						sb.Append(&quot;expecting token NOT in range: &quot; + tokenName(expecting) + &quot;..&quot; + tokenName(upper) + &quot;, found '&quot; + tokenText + &quot;'&quot;);
+						break;
+				
+					case TokenTypeEnum.SetType: case TokenTypeEnum.NotSetType: 
+						sb.Append(&quot;expecting &quot; + (mismatchType == TokenTypeEnum.NotSetType ? &quot;NOT &quot; : &quot;&quot;) + &quot;one of (&quot;);
+						int[] elems = bset.toArray();
+						for (int i = 0; i &lt; elems.Length; i++)
+						{
+							sb.Append(&quot; &quot;);
+							sb.Append(tokenName(elems[i]));
+						}
+						sb.Append(&quot;), found '&quot; + tokenText + &quot;'&quot;);
+						break;
+				
+					default: 
+						sb.Append(base.Message);
+						break;				
+				}			
+				return sb.ToString();
+			}
+		}
+		
+		private string tokenName(int tokenType)
+		{
+			if (tokenType == Token.INVALID_TYPE)
+			{
+				return &quot;&lt;Set of tokens&gt;&quot;;
+			}
+			else if (tokenType &lt; 0 || tokenType &gt;= tokenNames.Length)
+			{
+				return &quot;&lt;&quot; + tokenType.ToString() + &quot;&gt;&quot;;
+			}
+			else
+			{
+				return tokenNames[tokenType];
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/MismatchedTokenException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/NoViableAltException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/NoViableAltException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/NoViableAltException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,61 @@
+using System;
+
+using AST					= antlr.collections.AST;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	[Serializable]
+	public class NoViableAltException : RecognitionException
+	{
+		public IToken token;
+		public AST node; // handles parsing and treeparsing
+		
+		public NoViableAltException(AST t) : base(&quot;NoViableAlt&quot;, &quot;&lt;AST&gt;&quot;, - 1, - 1)
+		{
+			node = t;
+		}
+		
+		public NoViableAltException(IToken t, string fileName_) : 
+					base(&quot;NoViableAlt&quot;, fileName_, t.getLine(), t.getColumn())
+		{
+			token = t;
+		}
+		
+		/*
+		* Returns a clean error message (no line number/column information)
+		*/
+		override public string Message
+		{
+			get 
+			{
+				if (token != null)
+				{
+					//return &quot;unexpected token: &quot; + token.getText();
+					return &quot;unexpected token: &quot; + token.ToString();
+				}
+			
+				// must a tree parser error if token==null
+				if ( (node==null) || (node==TreeParser.ASTNULL) )
+				{
+					return &quot;unexpected end of subtree&quot;;
+				}
+				return &quot;unexpected AST node: &quot; + node.ToString();
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/NoViableAltException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/NoViableAltForCharException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/NoViableAltForCharException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/NoViableAltForCharException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,66 @@
+using System;
+using StringBuilder				= System.Text.StringBuilder;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	[Serializable]
+	public class NoViableAltForCharException : RecognitionException
+	{
+		public char foundChar;
+		
+		public NoViableAltForCharException(char c, CharScanner scanner) :
+					base(&quot;NoViableAlt&quot;, scanner.getFilename(), scanner.getLine(), scanner.getColumn())
+		{
+			foundChar = c;
+		}
+		
+		public NoViableAltForCharException(char c, string fileName, int line, int column) : 
+					base(&quot;NoViableAlt&quot;, fileName, line, column)
+		{
+			foundChar = c;
+		}
+		
+		/*
+		* Returns a clean error message (no line number/column information)
+		*/
+		override public string Message
+		{
+			get
+			{
+				StringBuilder mesg = new StringBuilder(&quot;unexpected char: &quot;);
+			
+				// I'm trying to mirror a change in the C++ stuff.
+				// But java seems to lack something isprint-ish..
+				// so we do it manually. This is probably too restrictive.
+			
+				if ((foundChar &gt;= ' ') &amp;&amp; (foundChar &lt;= '~'))
+				{
+					mesg.Append('\'');
+					mesg.Append(foundChar);
+					mesg.Append('\'');
+				}
+				else
+				{
+					mesg.Append(&quot;0x&quot;);
+					mesg.Append(((int)foundChar).ToString(&quot;X&quot;));
+				}
+				return mesg.ToString();
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/NoViableAltForCharException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/ParseTree.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ParseTree.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ParseTree.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,75 @@
+namespace antlr
+{
+	/* ANTLR Translator Generator
+	 * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	 * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	 */
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+
+	using System;
+	using StringBuilder 	= System.Text.StringBuilder;
+	using AST 				= antlr.collections.AST;
+
+	public abstract class ParseTree : BaseAST
+	{
+		/// &lt;summary&gt;
+		/// Walk parse tree and return requested number of derivation steps.
+		/// If steps less-than 0, return node text.  If steps equals 1, return derivation
+		/// string at step.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;step&quot;&gt;derivation steps&lt;/param&gt;
+		/// &lt;returns&gt;&lt;/returns&gt;
+		public string getLeftmostDerivationStep(int step) 
+		{
+			if ( step &lt;= 0 ) 
+			{
+				return ToString();
+			}
+			StringBuilder buf = new StringBuilder (2000);
+			getLeftmostDerivation(buf, step);
+			return buf.ToString();
+		}
+
+		public string getLeftmostDerivation(int maxSteps)
+		{
+			StringBuilder buf = new StringBuilder(2000);
+			buf.Append(&quot;    &quot; + this.ToString());
+			buf.Append(&quot;\n&quot;);
+			for (int d=1; d &lt; maxSteps; d++) 
+			{
+				buf.Append(&quot; =&gt;&quot;);
+				buf.Append(getLeftmostDerivationStep(d));
+				buf.Append(&quot;\n&quot;);
+			}
+			return buf.ToString();
+		}
+
+		/// &lt;summary&gt;
+		/// Get derivation and return how many you did (less than requested for
+		/// subtree roots.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;buf&quot;&gt;string buffer&lt;/param&gt;
+		/// &lt;param name=&quot;step&quot;&gt;derivation steps&lt;/param&gt;
+		/// &lt;returns&gt;&lt;/returns&gt;
+		protected internal abstract int getLeftmostDerivation(StringBuilder buf, int step);
+
+		// just satisfy BaseAST interface; unused as we manually create nodes
+
+		public override void initialize(int i, string s) 
+		{
+		}
+		
+		public override void initialize(AST ast) 
+		{
+		}
+		
+		public override void initialize(IToken token) 
+		{
+		}
+	}
+}

Added: trunk/src/antlr-runtime/antlr/ParseTreeRule.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ParseTreeRule.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ParseTreeRule.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,92 @@
+namespace antlr
+{
+
+	/* ANTLR Translator Generator
+	 * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	 * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	 */
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+
+	using System;
+	using StringBuilder 	= System.Text.StringBuilder;
+	using AST 				= antlr.collections.AST;
+
+	public class ParseTreeRule : ParseTree 
+	{
+		public const int INVALID_ALT = -1;
+
+		protected string ruleName;
+		protected int altNumber;  // unused until I modify antlr to record this
+
+		public ParseTreeRule(string ruleName) : this(ruleName, INVALID_ALT)
+		{
+		}
+
+		public ParseTreeRule(string ruleName, int altNumber) 
+		{
+			this.ruleName  = ruleName;
+			this.altNumber = altNumber;
+		}
+
+		public string getRuleName() 
+		{
+			return ruleName;
+		}
+
+		/// &lt;summary&gt;
+		/// Do a step-first walk, building up a buffer of tokens until
+		/// you've reached a particular step and print out any rule subroots
+		/// insteads of descending.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;buf&quot;&gt;derivation buffer&lt;/param&gt;
+		/// &lt;param name=&quot;step&quot;&gt;derivation steps&lt;/param&gt;
+		/// &lt;returns&gt;&lt;/returns&gt;
+		protected internal override int getLeftmostDerivation(StringBuilder buf, int step) 
+		{
+			int numReplacements = 0;
+			if ( step &lt;= 0 ) 
+			{
+				buf.Append(' ');
+				buf.Append(ToString());
+				return numReplacements;
+			}
+			AST child = getFirstChild();
+			numReplacements = 1;
+			// walk child printing them out, descending into at most one
+			while ( child != null ) 
+			{
+				if ( (numReplacements &gt;= step) || (child is ParseTreeToken) )
+				{
+					buf.Append(' ');
+					buf.Append(child.ToString());
+				}
+				else 
+				{
+					// descend for at least one more derivation; update count
+					int remainingReplacements = step - numReplacements;
+					int n = ((ParseTree) child).getLeftmostDerivation(buf, remainingReplacements);
+					numReplacements += n;
+				}
+				child = child.getNextSibling();
+			}
+			return numReplacements;
+		}
+
+		public override string ToString()
+		{
+			if ( altNumber == INVALID_ALT ) 
+			{
+				return '&lt;'+ruleName+'&gt;';
+			}
+			else 
+			{
+				return '&lt;'+ruleName+&quot;[&quot;+altNumber+&quot;]&gt;&quot;;
+			}
+		}
+	}
+}

Added: trunk/src/antlr-runtime/antlr/ParseTreeToken.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ParseTreeToken.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ParseTreeToken.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,44 @@
+namespace antlr
+{
+
+	/* ANTLR Translator Generator
+	 * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	 * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	 */
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+
+	using System;
+	using StringBuilder 	= System.Text.StringBuilder;
+	using AST 				= antlr.collections.AST;
+
+	public class ParseTreeToken : ParseTree
+	{
+		protected IToken token;
+
+		public ParseTreeToken(IToken token) 
+		{
+			this.token = token;
+		}
+
+		protected override internal int getLeftmostDerivation(StringBuilder buf, int step) 
+		{
+			buf.Append(' ');
+			buf.Append(ToString());
+			return step; // did on replacements
+		}
+
+		public override string ToString()
+		{
+			if ( token != null ) 
+			{
+				return token.getText();
+			}
+			return &quot;&lt;missing token&gt;&quot;;
+		}
+	}
+}

Added: trunk/src/antlr-runtime/antlr/Parser.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/Parser.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/Parser.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,507 @@
+using System;
+using EventHandlerList			= System.ComponentModel.EventHandlerList;
+
+using BitSet					= antlr.collections.impl.BitSet;
+using AST						= antlr.collections.AST;
+using ASTArray					= antlr.collections.impl.ASTArray;
+using antlr.debug;
+
+using MessageListener				= antlr.debug.MessageListener;
+using ParserListener				= antlr.debug.ParserListener;
+using ParserMatchListener			= antlr.debug.ParserMatchListener;
+using ParserTokenListener			= antlr.debug.ParserTokenListener;
+using SemanticPredicateListener		= antlr.debug.SemanticPredicateListener;
+using SyntacticPredicateListener	= antlr.debug.SyntacticPredicateListener;
+using TraceListener					= antlr.debug.TraceListener;
+
+/*
+	private Vector messageListeners;
+	private Vector newLineListeners;
+	private Vector matchListeners;
+	private Vector tokenListeners;
+	private Vector semPredListeners;
+	private Vector synPredListeners;
+	private Vector traceListeners;
+*/
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	public abstract class Parser : IParserDebugSubject
+	{
+		// Used to store event delegates
+		private EventHandlerList events_ = new EventHandlerList();
+
+		protected internal EventHandlerList Events 
+		{
+			get	{ return events_;	}
+		}
+
+		// The unique keys for each event that Parser [objects] can generate
+		internal static readonly object EnterRuleEventKey		= new object();
+		internal static readonly object ExitRuleEventKey			= new object();
+		internal static readonly object DoneEventKey				= new object();
+		internal static readonly object ReportErrorEventKey		= new object();
+		internal static readonly object ReportWarningEventKey	= new object();
+		internal static readonly object NewLineEventKey			= new object();
+		internal static readonly object MatchEventKey			= new object();
+		internal static readonly object MatchNotEventKey			= new object();
+		internal static readonly object MisMatchEventKey			= new object();
+		internal static readonly object MisMatchNotEventKey		= new object();
+		internal static readonly object ConsumeEventKey			= new object();
+		internal static readonly object LAEventKey				= new object();
+		internal static readonly object SemPredEvaluatedEventKey	= new object();
+		internal static readonly object SynPredStartedEventKey	= new object();
+		internal static readonly object SynPredFailedEventKey	= new object();
+		internal static readonly object SynPredSucceededEventKey	= new object();
+
+		protected internal ParserSharedInputState inputState;
+		
+		/*Nesting level of registered handlers */
+		// protected int exceptionLevel = 0;
+		
+		/*Table of token type to token names */
+		protected internal string[] tokenNames;
+		
+		/*AST return value for a rule is squirreled away here */
+		protected internal AST returnAST;
+		
+		/*AST support code; parser and treeparser delegate to this object */
+		protected internal ASTFactory astFactory = new ASTFactory();
+		
+		private bool ignoreInvalidDebugCalls = false;
+		
+		/*Used to keep track of indentdepth for traceIn/Out */
+		protected internal int traceDepth = 0;
+		
+		public Parser()
+		{
+			inputState = new ParserSharedInputState();
+		}
+		
+		public Parser(ParserSharedInputState state)
+		{
+			inputState = state;
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+
+		public event TraceEventHandler EnterRule
+		{
+			add		{	Events.AddHandler(EnterRuleEventKey, value);	}
+			remove	{	Events.RemoveHandler(EnterRuleEventKey, value);	}
+		}
+
+		public event TraceEventHandler ExitRule
+		{
+			add		{	Events.AddHandler(ExitRuleEventKey, value);		}
+			remove	{	Events.RemoveHandler(ExitRuleEventKey, value);	}
+		}
+
+		public event TraceEventHandler Done
+		{
+			add		{	Events.AddHandler(DoneEventKey, value);		}
+			remove	{	Events.RemoveHandler(DoneEventKey, value);	}
+		}
+
+		public event MessageEventHandler ErrorReported
+		{
+			add		{	Events.AddHandler(ReportErrorEventKey, value);		}
+			remove	{	Events.RemoveHandler(ReportErrorEventKey, value);	}
+		}
+
+		public event MessageEventHandler WarningReported
+		{
+			add		{	Events.AddHandler(ReportWarningEventKey, value);	}
+			remove	{	Events.RemoveHandler(ReportWarningEventKey, value);	}
+		}
+
+		public event MatchEventHandler MatchedToken
+		{
+			add		{	Events.AddHandler(MatchEventKey, value);	}
+			remove	{	Events.RemoveHandler(MatchEventKey, value);	}
+		}
+
+		public event MatchEventHandler MatchedNotToken
+		{
+			add		{	Events.AddHandler(MatchNotEventKey, value);		}
+			remove	{	Events.RemoveHandler(MatchNotEventKey, value);	}
+		}
+
+		public event MatchEventHandler MisMatchedToken
+		{
+			add		{	Events.AddHandler(MisMatchEventKey, value);		}
+			remove	{	Events.RemoveHandler(MisMatchEventKey, value);	}
+		}
+
+		public event MatchEventHandler MisMatchedNotToken
+		{
+			add		{	Events.AddHandler(MisMatchNotEventKey, value);		}
+			remove	{	Events.RemoveHandler(MisMatchNotEventKey, value);	}
+		}
+
+		public event TokenEventHandler ConsumedToken
+		{
+			add		{	Events.AddHandler(ConsumeEventKey, value);		}
+			remove	{	Events.RemoveHandler(ConsumeEventKey, value);	}
+		}
+
+		public event TokenEventHandler TokenLA
+		{
+			add		{	Events.AddHandler(LAEventKey, value);		}
+			remove	{	Events.RemoveHandler(LAEventKey, value);	}
+		}
+
+		public event SemanticPredicateEventHandler SemPredEvaluated
+		{
+			add		{	Events.AddHandler(SemPredEvaluatedEventKey, value);		}
+			remove	{	Events.RemoveHandler(SemPredEvaluatedEventKey, value);	}
+		}
+
+		public event SyntacticPredicateEventHandler SynPredStarted
+		{
+			add		{	Events.AddHandler(SynPredStartedEventKey, value);		}
+			remove	{	Events.RemoveHandler(SynPredStartedEventKey, value);	}
+		}
+
+		public event SyntacticPredicateEventHandler SynPredFailed
+		{
+			add		{	Events.AddHandler(SynPredFailedEventKey, value);	}
+			remove	{	Events.RemoveHandler(SynPredFailedEventKey, value);	}
+		}
+
+		public event SyntacticPredicateEventHandler SynPredSucceeded
+		{
+			add		{	Events.AddHandler(SynPredSucceededEventKey, value);		}
+			remove	{	Events.RemoveHandler(SynPredSucceededEventKey, value);	}
+		}
+
+		
+		public virtual void  addMessageListener(MessageListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.ArgumentException(&quot;addMessageListener() is only valid if parser built for debugging&quot;);
+		}
+		
+		public virtual void  addParserListener(ParserListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.ArgumentException(&quot;addParserListener() is only valid if parser built for debugging&quot;);
+		}
+		
+		public virtual void  addParserMatchListener(ParserMatchListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.ArgumentException(&quot;addParserMatchListener() is only valid if parser built for debugging&quot;);
+		}
+		
+		public virtual void  addParserTokenListener(ParserTokenListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.ArgumentException(&quot;addParserTokenListener() is only valid if parser built for debugging&quot;);
+		}
+		
+		public virtual void  addSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.ArgumentException(&quot;addSemanticPredicateListener() is only valid if parser built for debugging&quot;);
+		}
+		
+		public virtual void  addSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.ArgumentException(&quot;addSyntacticPredicateListener() is only valid if parser built for debugging&quot;);
+		}
+		
+		public virtual void  addTraceListener(TraceListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.ArgumentException(&quot;addTraceListener() is only valid if parser built for debugging&quot;);
+		}
+		
+		/*Get another token object from the token stream */
+		public abstract void  consume();
+		/*Consume tokens until one matches the given token */
+		public virtual void  consumeUntil(int tokenType)
+		{
+			while (LA(1) != Token.EOF_TYPE &amp;&amp; LA(1) != tokenType)
+			{
+				consume();
+			}
+		}
+		/*Consume tokens until one matches the given token set */
+		public virtual void  consumeUntil(BitSet bset)
+		{
+			while (LA(1) != Token.EOF_TYPE &amp;&amp; !bset.member(LA(1)))
+			{
+				consume();
+			}
+		}
+		protected internal virtual void  defaultDebuggingSetup(TokenStream lexer, TokenBuffer tokBuf)
+		{
+			// by default, do nothing -- we're not debugging
+		}
+		/*Get the AST return value squirreled away in the parser */
+		public virtual AST getAST()
+		{
+			return returnAST;
+		}
+		public virtual ASTFactory getASTFactory()
+		{
+			return astFactory;
+		}
+		public virtual string getFilename()
+		{
+			return inputState.filename;
+		}
+		
+		public virtual ParserSharedInputState getInputState()
+		{
+			return inputState;
+		}
+		
+		public virtual void  setInputState(ParserSharedInputState state)
+		{
+			inputState = state;
+		}
+		
+		public virtual void resetState()
+		{
+			traceDepth = 0;
+			inputState.reset();
+		}
+
+		public virtual string getTokenName(int num)
+		{
+			return tokenNames[num];
+		}
+		public virtual string[] getTokenNames()
+		{
+			return tokenNames;
+		}
+		public virtual bool isDebugMode()
+		{
+			return false;
+		}
+		/*Return the token type of the ith token of lookahead where i=1
+		* is the current token being examined by the parser (i.e., it
+		* has not been matched yet).
+		*/
+		public abstract int LA(int i);
+		/*Return the ith token of lookahead */
+		public abstract IToken LT(int i);
+		// Forwarded to TokenBuffer
+		public virtual int mark()
+		{
+			return inputState.input.mark();
+		}
+		/*Make sure current lookahead symbol matches token type &lt;tt&gt;t&lt;/tt&gt;.
+		* Throw an exception upon mismatch, which is catch by either the
+		* error handler or by the syntactic predicate.
+		*/
+		public virtual void  match(int t)
+		{
+			if (LA(1) != t)
+				throw new MismatchedTokenException(tokenNames, LT(1), t, false, getFilename());
+			else
+				consume();
+		}
+		/*Make sure current lookahead symbol matches the given set
+		* Throw an exception upon mismatch, which is catch by either the
+		* error handler or by the syntactic predicate.
+		*/
+		public virtual void  match(BitSet b)
+		{
+			if (!b.member(LA(1)))
+				throw new MismatchedTokenException(tokenNames, LT(1), b, false, getFilename());
+			else
+				consume();
+		}
+		public virtual void  matchNot(int t)
+		{
+			if (LA(1) == t)
+				throw new MismatchedTokenException(tokenNames, LT(1), t, true, getFilename());
+			else
+				consume();
+		}
+
+		/// &lt;summary&gt;
+		/// @deprecated as of 2.7.2. This method calls System.exit() and writes
+		/// directly to stderr, which is usually not appropriate when
+		/// a parser is embedded into a larger application. Since the method is
+		/// &lt;code&gt;static&lt;/code&gt;, it cannot be overridden to avoid these problems.
+		/// ANTLR no longer uses this method internally or in generated code.
+		/// &lt;/summary&gt;
+		/// 
+		[Obsolete(&quot;De-activated since version 2.7.2.6 as it cannot be overidden.&quot;, true)]
+		public static void  panic()
+		{
+			System.Console.Error.WriteLine(&quot;Parser: panic&quot;);
+			System.Environment.Exit(1);
+		}
+
+		public virtual void  removeMessageListener(MessageListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.SystemException(&quot;removeMessageListener() is only valid if parser built for debugging&quot;);
+		}
+		public virtual void  removeParserListener(ParserListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.SystemException(&quot;removeParserListener() is only valid if parser built for debugging&quot;);
+		}
+		public virtual void  removeParserMatchListener(ParserMatchListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.SystemException(&quot;removeParserMatchListener() is only valid if parser built for debugging&quot;);
+		}
+		public virtual void  removeParserTokenListener(ParserTokenListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.SystemException(&quot;removeParserTokenListener() is only valid if parser built for debugging&quot;);
+		}
+		public virtual void  removeSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.ArgumentException(&quot;removeSemanticPredicateListener() is only valid if parser built for debugging&quot;);
+		}
+		public virtual void  removeSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.ArgumentException(&quot;removeSyntacticPredicateListener() is only valid if parser built for debugging&quot;);
+		}
+		public virtual void  removeTraceListener(TraceListener l)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.SystemException(&quot;removeTraceListener() is only valid if parser built for debugging&quot;);
+		}
+		
+		/*Parser error-reporting function can be overridden in subclass */
+		public virtual void reportError(RecognitionException ex)
+		{
+			Console.Error.WriteLine(ex);
+		}
+		
+		/*Parser error-reporting function can be overridden in subclass */
+		public virtual void reportError(string s)
+		{
+			if (getFilename() == null)
+			{
+				Console.Error.WriteLine(&quot;error: &quot; + s);
+			}
+			else
+			{
+				Console.Error.WriteLine(getFilename() + &quot;: error: &quot; + s);
+			}
+		}
+		
+		/*Parser warning-reporting function can be overridden in subclass */
+		public virtual void  reportWarning(string s)
+		{
+			if (getFilename() == null)
+			{
+				Console.Error.WriteLine(&quot;warning: &quot; + s);
+			}
+			else
+			{
+				Console.Error.WriteLine(getFilename() + &quot;: warning: &quot; + s);
+			}
+		}
+		
+		public virtual void recover(RecognitionException ex, BitSet tokenSet)
+		{
+			consume();
+			consumeUntil(tokenSet);
+		}
+		
+		public virtual void  rewind(int pos)
+		{
+			inputState.input.rewind(pos);
+		}
+
+		/// &lt;summary&gt;
+		/// Specify an object with support code (shared by Parser and TreeParser.
+		/// Normally, the programmer does not play with this, using 
+		/// &lt;see cref=&quot;setASTNodeClass&quot;/&gt; instead.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;f&quot;&gt;&lt;/param&gt;
+		public virtual void  setASTFactory(ASTFactory f)
+		{
+			astFactory = f;
+		}
+
+		/// &lt;summary&gt;
+		/// Specify the type of node to create during tree building. 
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;cl&quot;&gt;Fully qualified AST Node type name.&lt;/param&gt;
+		public virtual void  setASTNodeClass(string cl)
+		{
+			astFactory.setASTNodeType(cl);
+		}
+
+		/// &lt;summary&gt;
+		/// Specify the type of node to create during tree building. 
+		/// use &lt;see cref=&quot;setASTNodeClass&quot;/&gt; now to be consistent with 
+		/// Token Object Type accessor.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;nodeType&quot;&gt;Fully qualified AST Node type name.&lt;/param&gt;
+		[Obsolete(&quot;Replaced by setASTNodeClass(string) since version 2.7.1&quot;, true)]
+		public virtual void  setASTNodeType(string nodeType)
+		{
+			setASTNodeClass(nodeType);
+		}
+
+		public virtual void  setDebugMode(bool debugMode)
+		{
+			if (!ignoreInvalidDebugCalls)
+				throw new System.SystemException(&quot;setDebugMode() only valid if parser built for debugging&quot;);
+		}
+		public virtual void  setFilename(string f)
+		{
+			inputState.filename = f;
+		}
+		public virtual void  setIgnoreInvalidDebugCalls(bool Value)
+		{
+			ignoreInvalidDebugCalls = Value;
+		}
+		/*Set or change the input token buffer */
+		public virtual void  setTokenBuffer(TokenBuffer t)
+		{
+			inputState.input = t;
+		}
+		
+		public virtual void  traceIndent()
+		{
+			 for (int i = 0; i &lt; traceDepth; i++)
+				Console.Out.Write(&quot; &quot;);
+		}
+		public virtual void  traceIn(string rname)
+		{
+			traceDepth += 1;
+			traceIndent();
+			Console.Out.WriteLine(&quot;&gt; &quot; + rname + &quot;; LA(1)==&quot; + LT(1).getText() + ((inputState.guessing &gt; 0)?&quot; [guessing]&quot;:&quot;&quot;));
+		}
+		public virtual void  traceOut(string rname)
+		{
+			traceIndent();
+			Console.Out.WriteLine(&quot;&lt; &quot; + rname + &quot;; LA(1)==&quot; + LT(1).getText() + ((inputState.guessing &gt; 0)?&quot; [guessing]&quot;:&quot;&quot;));
+			traceDepth -= 1;
+		}
+	}
+}


Property changes on: trunk/src/antlr-runtime/antlr/Parser.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/ParserSharedInputState.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/ParserSharedInputState.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/ParserSharedInputState.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,44 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	/*This object contains the data associated with an
+	*  input stream of tokens.  Multiple parsers
+	*  share a single ParserSharedInputState to parse
+	*  the same stream of tokens.
+	*/
+
+	public class ParserSharedInputState
+	{
+		/*Where to get token objects */
+		protected internal TokenBuffer input;
+		
+		/*Are we guessing (guessing&gt;0)? */
+		public int guessing = 0;
+		
+		/*What file (if known) caused the problem? */
+		protected internal string filename;
+		
+		public virtual void  reset()
+		{
+			guessing = 0;
+			filename = null;
+			input.reset();
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/ParserSharedInputState.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/RecognitionException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/RecognitionException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/RecognitionException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,82 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	[Serializable]
+	public class RecognitionException : ANTLRException
+	{
+		public string fileName; // not used by treeparsers
+		public int line; // not used by treeparsers
+		public int column; // not used by treeparsers
+		
+		public RecognitionException() : base(&quot;parsing error&quot;)
+		{
+			fileName = null;
+			line = - 1;
+			column = - 1;
+		}
+		
+		/*
+		* RecognitionException constructor comment.
+		* @param s java.lang.String
+		*/
+		public RecognitionException(string s) : base(s)
+		{
+			fileName = null;
+			line = - 1;
+			column = - 1;
+		}
+		
+		/*
+		* RecognitionException constructor comment.
+		* @param s java.lang.String
+		*/
+		public RecognitionException(string s, string fileName_, int line_, int column_) : base(s)
+		{
+			fileName = fileName_;
+			line = line_;
+			column = column_;
+		}
+		
+		public virtual string getFilename()
+		{
+			return fileName;
+		}
+		
+		public virtual int getLine()
+		{
+			return line;
+		}
+		
+		public virtual int getColumn()
+		{
+			return column;
+		}
+		
+		[Obsolete(&quot;Replaced by Message property since version 2.7.0&quot;, true)]
+		public virtual string getErrorMessage()
+		{
+			return Message;
+		}
+		
+		override public string ToString()
+		{
+			return FileLineFormatter.getFormatter().getFormatString(fileName, line, column) + Message;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/RecognitionException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/SemanticException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/SemanticException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/SemanticException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,39 @@
+using System;
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	[Serializable]
+	public class SemanticException : RecognitionException
+	{
+		public SemanticException(string s) : base(s)
+		{
+		}
+		
+		[Obsolete(&quot;Replaced by SemanticException(string, string, int, int) since version 2.7.2.6&quot;, false)]
+		public SemanticException(String s, String fileName, int line) :
+					this(s, fileName, line, -1)
+		{
+			
+		}
+
+		public SemanticException(string s, string fileName, int line, int column) :
+					base(s, fileName, line, column)
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/SemanticException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/StringUtils.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/StringUtils.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/StringUtils.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,119 @@
+using System;
+
+namespace antlr
+{
+	/* ANTLR Translator Generator
+	 * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	 * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	 *
+	 * $Id:$
+	 */
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	public class StringUtils
+	{
+		/*General-purpose utility function for removing
+		* characters from back of string
+		* @param s The string to process
+		* @param c The character to remove
+		* @return The resulting string
+		*/
+		static public string stripBack(string s, char c)
+		{
+			while (s.Length &gt; 0 &amp;&amp; s[s.Length - 1] == c)
+			{
+				s = s.Substring(0, (s.Length - 1) - (0));
+			}
+			return s;
+		}
+		
+		/*General-purpose utility function for removing
+		* characters from back of string
+		* @param s The string to process
+		* @param remove A string containing the set of characters to remove
+		* @return The resulting string
+		*/
+		static public string stripBack(string s, string remove)
+		{
+			bool changed;
+			do 
+			{
+				changed = false;
+				 for (int i = 0; i &lt; remove.Length; i++)
+				{
+					char c = remove[i];
+					while (s.Length &gt; 0 &amp;&amp; s[s.Length - 1] == c)
+					{
+						changed = true;
+						s = s.Substring(0, (s.Length - 1) - (0));
+					}
+				}
+			}
+			while (changed);
+			return s;
+		}
+		
+		/*General-purpose utility function for removing
+		* characters from front of string
+		* @param s The string to process
+		* @param c The character to remove
+		* @return The resulting string
+		*/
+		static public string stripFront(string s, char c)
+		{
+			while (s.Length &gt; 0 &amp;&amp; s[0] == c)
+			{
+				s = s.Substring(1);
+			}
+			return s;
+		}
+		
+		/*General-purpose utility function for removing
+		* characters from front of string
+		* @param s The string to process
+		* @param remove A string containing the set of characters to remove
+		* @return The resulting string
+		*/
+		static public string stripFront(string s, string remove)
+		{
+			bool changed;
+			do 
+			{
+				changed = false;
+				 for (int i = 0; i &lt; remove.Length; i++)
+				{
+					char c = remove[i];
+					while (s.Length &gt; 0 &amp;&amp; s[0] == c)
+					{
+						changed = true;
+						s = s.Substring(1);
+					}
+				}
+			}
+			while (changed);
+			return s;
+		}
+		
+		/*General-purpose utility function for removing
+		* characters from the front and back of string
+		* @param s The string to process
+		* @param head exact string to strip from head
+		* @param tail exact string to strip from tail
+		* @return The resulting string
+		*/
+		public static string stripFrontBack(string src, string head, string tail)
+		{
+			int h = src.IndexOf(head);
+			int t = src.LastIndexOf(tail);
+			if (h == - 1 || t == - 1)
+				return src;
+			return src.Substring(h + 1, (t) - (h + 1));
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/StringUtils.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/Token.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/Token.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/Token.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,99 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*A token is minimally a token type.  Subclasses can add the text matched
+	*  for the token and line info. 
+	*/
+
+	public class Token : IToken //, ICloneable
+	{
+		// constants
+		public const int MIN_USER_TYPE = 4;
+		public const int NULL_TREE_LOOKAHEAD = 3;
+		public const int INVALID_TYPE = 0;
+		public const int EOF_TYPE = 1;
+		public static readonly int SKIP = - 1;
+		
+		// each Token has at least a token type
+		protected int type_;
+		
+		// the illegal token object
+		public static Token badToken = new Token(INVALID_TYPE, &quot;&lt;no text&gt;&quot;);
+		
+		public Token()
+		{
+			type_ = INVALID_TYPE;
+		}
+		public Token(int t)
+		{
+			type_ = t;
+		}
+		public Token(int t, string txt)
+		{
+			type_ = t;
+			setText(txt);
+		}
+		public virtual int getColumn()
+		{
+			return 0;
+		}
+		public virtual int getLine()
+		{
+			return 0;
+		}
+		public virtual string getFilename() 
+		{
+			return null;
+		}
+
+		public virtual void setFilename(string name) 
+		{
+		}
+
+		public virtual string getText()
+		{
+			return &quot;&lt;no text&gt;&quot;;
+		}
+
+		public int Type
+		{
+			get { return type_;  }
+			set { type_ = value; }
+		}
+
+		public virtual void setType(int newType)	{ this.Type = newType; }
+
+		public virtual void  setColumn(int c)
+		{
+			;
+		}
+		public virtual void  setLine(int l)
+		{
+			;
+		}
+		public virtual void  setText(string t)
+		{
+			;
+		}
+		override public string ToString()
+		{
+			return &quot;[\&quot;&quot; + getText() + &quot;\&quot;,&lt;&quot; + type_ + &quot;&gt;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/Token.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenBuffer.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenBuffer.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenBuffer.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,146 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	/*A Stream of Token objects fed to the parser from a Tokenizer that can
+	* be rewound via mark()/rewind() methods.
+	* &lt;p&gt;
+	* A dynamic array is used to buffer up all the input tokens.  Normally,
+	* &quot;k&quot; tokens are stored in the buffer.  More tokens may be stored during
+	* guess mode (testing syntactic predicate), or when LT(i&gt;k) is referenced.
+	* Consumption of tokens is deferred.  In other words, reading the next
+	* token is not done by conume(), but deferred until needed by LA or LT.
+	* &lt;p&gt;
+	*
+	* @see antlr.Token
+	* @see antlr.Tokenizer
+	* @see antlr.TokenQueue
+	*/
+	
+	public class TokenBuffer
+	{
+		
+		// Token source
+		protected internal TokenStream input;
+		
+		// Number of active markers
+		protected internal int nMarkers = 0;
+		
+		// Additional offset used when markers are active
+		protected internal int markerOffset = 0;
+		
+		// Number of calls to consume() since last LA() or LT() call
+		protected internal int numToConsume = 0;
+		
+		// Circular queue
+		internal TokenQueue queue;
+		
+		/*Create a token buffer */
+		public TokenBuffer(TokenStream input_)
+		{
+			input = input_;
+			queue = new TokenQueue(1);
+		}
+		
+		/*Reset the input buffer to empty state */
+		public virtual void  reset()
+		{
+			nMarkers = 0;
+			markerOffset = 0;
+			numToConsume = 0;
+			queue.reset();
+		}
+		
+		/*Mark another token for deferred consumption */
+		public virtual void  consume()
+		{
+			numToConsume++;
+		}
+		
+		/*Ensure that the token buffer is sufficiently full */
+		protected virtual void  fill(int amount)
+		{
+			syncConsume();
+			// Fill the buffer sufficiently to hold needed tokens
+			while (queue.nbrEntries &lt; (amount + markerOffset))
+			{
+				// Append the next token
+				queue.append(input.nextToken());
+			}
+		}
+		
+		/*return the Tokenizer (needed by ParseView) */
+		public virtual TokenStream getInput()
+		{
+			return input;
+		}
+		
+		/*Get a lookahead token value */
+		public virtual int LA(int i)
+		{
+			fill(i);
+			return queue.elementAt(markerOffset + i - 1).Type;
+		}
+		
+		/*Get a lookahead token */
+		public virtual IToken LT(int i)
+		{
+			fill(i);
+			return queue.elementAt(markerOffset + i - 1);
+		}
+		
+		/*Return an integer marker that can be used to rewind the buffer to
+		* its current state.
+		*/
+		public virtual int mark()
+		{
+			syncConsume();
+			nMarkers++;
+			return markerOffset;
+		}
+		
+		/*Rewind the token buffer to a marker.
+		* @param mark Marker returned previously from mark()
+		*/
+		public virtual void  rewind(int mark)
+		{
+			syncConsume();
+			markerOffset = mark;
+			nMarkers--;
+		}
+		
+		/*Sync up deferred consumption */
+		protected virtual void  syncConsume()
+		{
+			while (numToConsume &gt; 0)
+			{
+				if (nMarkers &gt; 0)
+				{
+					// guess mode -- leave leading tokens and bump offset.
+					markerOffset++;
+				}
+				else
+				{
+					// normal mode -- remove first token
+					queue.removeFirst();
+				}
+				numToConsume--;
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenBuffer.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenCreator.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenCreator.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenCreator.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,48 @@
+namespace antlr
+{
+	using System;
+
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+
+	/// &lt;summary&gt;
+	/// A creator of Token object instances.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	/// &lt;para&gt;
+	/// This class and it's sub-classes exists primarily as an optimization
+	/// of the reflection-based mechanism(s) previously used exclusively to 
+	/// create instances of Token objects.
+	/// &lt;/para&gt;
+	/// &lt;para&gt;
+	/// Since Lexers in ANTLR use a single Token type, each TokenCreator can 
+	/// create one class of Token objects (that's why it's not called TokenFactory).
+	/// &lt;/para&gt;
+	/// &lt;/remarks&gt;
+	public abstract class TokenCreator
+	{
+		/// &lt;summary&gt;
+		/// Returns the fully qualified name of the Token type that this
+		/// class creates.
+		/// &lt;/summary&gt;
+		public abstract string TokenTypeName
+		{
+			get;
+		}
+
+		/// &lt;summary&gt;
+		/// Constructs a &lt;see cref=&quot;Token&quot;/&gt; instance.
+		/// &lt;/summary&gt;
+		public abstract IToken Create();
+	}
+}
\ No newline at end of file

Added: trunk/src/antlr-runtime/antlr/TokenQueue.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenQueue.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenQueue.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,121 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	/*A private circular buffer object used by the token buffer */
+
+	class TokenQueue
+	{
+		/*Physical circular buffer of tokens */
+		private IToken[] buffer;
+		/*buffer.length-1 for quick modulos */
+		private int sizeLessOne;
+		/*physical index of front token */
+		private int offset;
+		/*number of tokens in the queue */
+		protected internal int nbrEntries;
+		
+		public TokenQueue(int minSize)
+		{
+			// Find first power of 2 &gt;= to requested size
+			int size;
+			if (minSize &lt; 0)
+			{
+				init(16); // pick some value for them
+				return ;
+			}
+			// check for overflow
+			if (minSize &gt;= (int.MaxValue / 2))
+			{
+				init(int.MaxValue); // wow that's big.
+				return ;
+			}
+			 for (size = 2; size &lt; minSize; size *= 2)
+			{
+				;
+			}
+			init(size);
+		}
+		
+		/*Add token to end of the queue
+		* @param tok The token to add
+		*/
+		public void  append(IToken tok)
+		{
+			if (nbrEntries == buffer.Length)
+			{
+				expand();
+			}
+			buffer[(offset + nbrEntries) &amp; sizeLessOne] = tok;
+			nbrEntries++;
+		}
+		
+		/*Fetch a token from the queue by index
+		* @param idx The index of the token to fetch, where zero is the token at the front of the queue
+		*/
+		public IToken elementAt(int idx)
+		{
+			return buffer[(offset + idx) &amp; sizeLessOne];
+		}
+		
+		/*Expand the token buffer by doubling its capacity */
+		private void  expand()
+		{
+			IToken[] newBuffer = new IToken[buffer.Length * 2];
+			// Copy the contents to the new buffer
+			// Note that this will store the first logical item in the
+			// first physical array element.
+			 for (int i = 0; i &lt; buffer.Length; i++)
+			{
+				newBuffer[i] = elementAt(i);
+			}
+			// Re-initialize with new contents, keep old nbrEntries
+			buffer = newBuffer;
+			sizeLessOne = buffer.Length - 1;
+			offset = 0;
+		}
+		
+		/*Initialize the queue.
+		* @param size The initial size of the queue
+		*/
+		private void  init(int size)
+		{
+			// Allocate buffer
+			buffer = new IToken[size];
+			// Other initialization
+			sizeLessOne = size - 1;
+			offset = 0;
+			nbrEntries = 0;
+		}
+		
+		/*Clear the queue. Leaving the previous buffer alone.
+		*/
+		public void  reset()
+		{
+			offset = 0;
+			nbrEntries = 0;
+		}
+		
+		/*Remove token from front of queue */
+		public void  removeFirst()
+		{
+			offset = (offset + 1) &amp; sizeLessOne;
+			nbrEntries--;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenQueue.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenStream.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenStream.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenStream.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,26 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	public interface TokenStream
+	{
+		IToken nextToken();
+	}
+	
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenStream.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenStreamBasicFilter.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenStreamBasicFilter.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenStreamBasicFilter.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,56 @@
+using System;
+using BitSet = antlr.collections.impl.BitSet;
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*This object is a TokenStream that passes through all
+	*  tokens except for those that you tell it to discard.
+	*  There is no buffering of the tokens.
+	*/
+	public class TokenStreamBasicFilter : TokenStream
+	{
+		/*The set of token types to discard */
+		protected internal BitSet discardMask;
+		
+		/*The input stream */
+		protected internal TokenStream input;
+		
+		public TokenStreamBasicFilter(TokenStream input)
+		{
+			this.input = input;
+			discardMask = new BitSet();
+		}
+		public virtual void  discard(int ttype)
+		{
+			discardMask.add(ttype);
+		}
+		public virtual void  discard(BitSet mask)
+		{
+			discardMask = mask;
+		}
+		public virtual IToken nextToken()
+		{
+			IToken tok = input.nextToken();
+			while (tok != null &amp;&amp; discardMask.member(tok.Type))
+			{
+				tok = input.nextToken();
+			}
+			return tok;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenStreamBasicFilter.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenStreamException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenStreamException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenStreamException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,34 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*
+	* Anything that goes wrong while generating a stream of tokens.
+	*/
+
+	[Serializable]
+	public class TokenStreamException : ANTLRException
+	{
+		public TokenStreamException()
+		{
+		}
+		public TokenStreamException(string s) : base(s)
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenStreamException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenStreamHiddenTokenFilter.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenStreamHiddenTokenFilter.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenStreamHiddenTokenFilter.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,179 @@
+using System;
+using BitSet = antlr.collections.impl.BitSet;
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*This object filters a token stream coming from a lexer
+	* or another TokenStream so that only certain token channels
+	* get transmitted to the parser.
+	*
+	* Any of the channels can be filtered off as &quot;hidden&quot; channels whose
+	* tokens can be accessed from the parser.
+	*/
+	public class TokenStreamHiddenTokenFilter : TokenStreamBasicFilter, TokenStream
+	{
+		// protected BitSet discardMask;
+		protected internal BitSet hideMask;
+		
+		private IHiddenStreamToken nextMonitoredToken;
+		
+		/*track tail of hidden list emanating from previous
+		*  monitored token
+		*/
+		protected internal IHiddenStreamToken lastHiddenToken;
+		
+		protected internal IHiddenStreamToken firstHidden = null;
+		
+		public TokenStreamHiddenTokenFilter(TokenStream input) : base(input)
+		{
+			hideMask = new BitSet();
+		}
+		protected internal virtual void  consume()
+		{
+			nextMonitoredToken = (IHiddenStreamToken) input.nextToken();
+		}
+		private void  consumeFirst()
+		{
+			consume(); // get first token of input stream
+			
+			// Handle situation where hidden or discarded tokens
+			// appear first in input stream
+			IHiddenStreamToken p = null;
+			// while hidden or discarded scarf tokens
+			while (hideMask.member(LA(1).Type) || discardMask.member(LA(1).Type))
+			{
+				if (hideMask.member(LA(1).Type))
+				{
+					if (p == null)
+					{
+						p = LA(1);
+					}
+					else
+					{
+						p.setHiddenAfter(LA(1));
+						LA(1).setHiddenBefore(p); // double-link
+						p = LA(1);
+					}
+					lastHiddenToken = p;
+					if (firstHidden == null)
+					{
+						firstHidden = p; // record hidden token if first
+					}
+				}
+				consume();
+			}
+		}
+		public virtual BitSet getDiscardMask()
+		{
+			return discardMask;
+		}
+		/*Return a ptr to the hidden token appearing immediately after
+		*  token t in the input stream.
+		*/
+		public virtual IHiddenStreamToken getHiddenAfter(IHiddenStreamToken t)
+		{
+			return t.getHiddenAfter();
+		}
+		/*Return a ptr to the hidden token appearing immediately before
+		*  token t in the input stream.
+		*/
+		public virtual IHiddenStreamToken getHiddenBefore(IHiddenStreamToken t)
+		{
+			return t.getHiddenBefore();
+		}
+		public virtual BitSet getHideMask()
+		{
+			return hideMask;
+		}
+		/*Return the first hidden token if one appears
+		*  before any monitored token.
+		*/
+		public virtual IHiddenStreamToken getInitialHiddenToken()
+		{
+			return firstHidden;
+		}
+		public virtual void  hide(int m)
+		{
+			hideMask.add(m);
+		}
+		public virtual void  hide(BitSet mask)
+		{
+			hideMask = mask;
+		}
+		protected internal virtual IHiddenStreamToken LA(int i)
+		{
+			return nextMonitoredToken;
+		}
+		/*Return the next monitored token.
+		*  Test the token following the monitored token.
+		*  If following is another monitored token, save it
+		*  for the next invocation of nextToken (like a single
+		*  lookahead token) and return it then.
+		*  If following is unmonitored, nondiscarded (hidden)
+		*  channel token, add it to the monitored token.
+		*
+		*  Note: EOF must be a monitored Token.
+		*/
+		override public IToken nextToken()
+		{
+			// handle an initial condition; don't want to get lookahead
+			// token of this splitter until first call to nextToken
+			if (LA(1) == null)
+			{
+				consumeFirst();
+			}
+			
+			// we always consume hidden tokens after monitored, thus,
+			// upon entry LA(1) is a monitored token.
+			IHiddenStreamToken monitored = LA(1);
+			// point to hidden tokens found during last invocation
+			monitored.setHiddenBefore(lastHiddenToken);
+			lastHiddenToken = null;
+			
+			// Look for hidden tokens, hook them into list emanating
+			// from the monitored tokens.
+			consume();
+			IHiddenStreamToken p = monitored;
+			// while hidden or discarded scarf tokens
+			while (hideMask.member(LA(1).Type) || discardMask.member(LA(1).Type))
+			{
+				if (hideMask.member(LA(1).Type))
+				{
+					// attach the hidden token to the monitored in a chain
+					// link forwards
+					p.setHiddenAfter(LA(1));
+					// link backwards
+					if (p != monitored)
+					{
+						//hidden cannot point to monitored tokens
+						LA(1).setHiddenBefore(p);
+					}
+					p = (lastHiddenToken = LA(1));
+				}
+				consume();
+			}
+			return monitored;
+		}
+		public virtual void resetState()
+		{
+			firstHidden			= null;
+			lastHiddenToken		= null;
+			nextMonitoredToken	= null;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenStreamHiddenTokenFilter.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenStreamIOException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenStreamIOException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenStreamIOException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,37 @@
+using System;
+using IOException = System.IO.IOException;
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*
+	* Wraps an IOException in a TokenStreamException
+	*/
+	[Serializable]
+	public class TokenStreamIOException : TokenStreamException
+	{
+		public IOException io;
+		/*
+		* TokenStreamIOException constructor comment.
+		* @param s java.lang.String
+		*/
+		public TokenStreamIOException(IOException io) : base(io.Message)
+		{
+			this.io = io;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenStreamIOException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenStreamRecognitionException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenStreamRecognitionException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenStreamRecognitionException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,41 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+	
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*
+	* Wraps a RecognitionException in a TokenStreamException so you
+	* can pass it along.
+	*/
+
+	[Serializable]
+	public class TokenStreamRecognitionException : TokenStreamException
+	{
+		public RecognitionException recog;
+		
+		public TokenStreamRecognitionException(RecognitionException re) :
+				base(re.Message)
+		{
+			this.recog = re;
+		}
+		
+		override public string ToString()
+		{
+			return recog.ToString();
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenStreamRecognitionException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenStreamRetryException.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenStreamRetryException.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenStreamRetryException.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,31 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*
+	* Aborted recognition of current token. Try to get one again.
+	* Used by TokenStreamSelector.retry() to force nextToken()
+	* of stream to re-enter and retry.
+	*/
+
+	[Serializable]
+	public class TokenStreamRetryException : TokenStreamException
+	{
+		public TokenStreamRetryException() {}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenStreamRetryException.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenStreamRewriteEngine.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenStreamRewriteEngine.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenStreamRewriteEngine.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,552 @@
+namespace antlr
+{
+	/* ANTLR Translator Generator
+	 * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	 * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	 */
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+
+	using System;
+	using IList 		= System.Collections.IList;
+	using IDictionary 	= System.Collections.IDictionary;
+	using ArrayList 	= System.Collections.ArrayList;
+	using Hashtable		= System.Collections.Hashtable;
+	using IComparer		= System.Collections.IComparer;
+	using StringBuilder = System.Text.StringBuilder;
+	using BitSet 		= antlr.collections.impl.BitSet;
+
+	/// &lt;summary&gt;
+	/// This token stream tracks the *entire* token stream coming from
+	/// a lexer, but does not pass on the whitespace (or whatever else
+	/// you want to discard) to the parser.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	/// &lt;para&gt;
+	/// This class can then be asked for the ith token in the input stream.
+	/// Useful for dumping out the input stream exactly after doing some
+	/// augmentation or other manipulations.  Tokens are index from 0..n-1
+	/// &lt;/para&gt;
+	/// &lt;para&gt;
+	/// You can insert stuff, replace, and delete chunks.  Note that the
+	/// operations are done lazily--only if you convert the buffer to a
+	/// string.  This is very efficient because you are not moving data around
+	/// all the time.  As the buffer of tokens is converted to strings, the
+	/// toString() method(s) check to see if there is an operation at the
+	/// current index.  If so, the operation is done and then normal string
+	/// rendering continues on the buffer.  This is like having multiple Turing
+	/// machine instruction streams (programs) operating on a single input tape. :)
+	/// &lt;/para&gt;
+	/// &lt;para&gt;
+	/// Since the operations are done lazily at toString-time, operations do not
+	/// screw up the token index values.  That is, an insert operation at token
+	/// index i does not change the index values for tokens i+1..n-1.
+	/// &lt;/para&gt;
+	/// &lt;para&gt;
+	/// Because operations never actually alter the buffer, you may always get
+	/// the original token stream back without undoing anything.  Since
+	/// the instructions are queued up, you can easily simulate transactions and
+	/// roll back any changes if there is an error just by removing instructions.
+	/// For example,
+	/// &lt;/para&gt;
+	/// &lt;example&gt;For example:
+	/// &lt;code&gt;
+	/// TokenStreamRewriteEngine rewriteEngine = new TokenStreamRewriteEngine(lexer);
+	/// JavaRecognizer           parser        = new JavaRecognizer(rewriteEngine);
+	/// ...
+	/// rewriteEngine.insertAfter(&quot;pass1&quot;, t, &quot;foobar&quot;);}
+	/// rewriteEngine.insertAfter(&quot;pass2&quot;, u, &quot;start&quot;);}
+	/// System.Console.Out.WriteLine(rewriteEngine.ToString(&quot;pass1&quot;));
+	/// System.Console.Out.WriteLine(rewriteEngine.ToString(&quot;pass2&quot;));
+	/// &lt;/code&gt;
+	/// &lt;/example&gt;
+	/// &lt;para&gt;
+	/// You can also have multiple &quot;instruction streams&quot; and get multiple
+	/// rewrites from a single pass over the input.  Just name the instruction
+	/// streams and use that name again when printing the buffer.  This could be
+	/// useful for generating a C file and also its header file--all from the
+	/// same buffer.
+	/// &lt;/para&gt;
+	/// &lt;para&gt;
+	/// If you don't use named rewrite streams, a &quot;default&quot; stream is used.
+	/// &lt;/para&gt;
+	/// &lt;para&gt;
+	/// Terence Parr, <A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">parrt at cs.usfca.edu</A>
+	/// University of San Francisco
+	/// February 2004
+	/// &lt;/para&gt;
+	/// &lt;/remarks&gt;
+	public class TokenStreamRewriteEngine : TokenStream
+	{
+		public const int MIN_TOKEN_INDEX = 0;
+
+		protected class RewriteOperation 
+		{
+			protected internal int 		index;
+			protected internal string 	text;
+			
+			protected RewriteOperation(int index, string text) 
+			{
+				this.index = index;
+				this.text  = text;
+			}
+			
+			/// &lt;summary&gt;
+			/// Execute the rewrite operation by possibly adding to the buffer.
+			/// &lt;/summary&gt;
+			/// &lt;param name=&quot;buf&quot;&gt;rewrite buffer&lt;/param&gt;
+			/// &lt;returns&gt;The index of the next token to operate on.&lt;/returns&gt;
+			public virtual int execute(StringBuilder buf) 
+			{
+				return index;
+			}
+		}
+
+		protected class InsertBeforeOp : RewriteOperation 
+		{
+			public InsertBeforeOp(int index, string text) : base(index, text)
+			{
+			}
+			
+			public override int execute(StringBuilder buf) 
+			{
+				buf.Append(text);
+				return index;
+			}
+		}
+
+		protected class ReplaceOp : RewriteOperation 
+		{
+			protected int lastIndex;
+			
+			public ReplaceOp(int from, int to, string text) : base(from, text)
+			{
+				lastIndex = to;
+			}
+			
+			public override int execute(StringBuilder buf) 
+			{
+				if ( text != null ) 
+				{
+					buf.Append(text);
+				}
+				return lastIndex+1;
+			}
+		}
+
+		protected class DeleteOp : ReplaceOp 
+		{
+			public DeleteOp(int from, int to) : base(from, to, null)
+			{
+			}
+		}
+
+		public const string 	DEFAULT_PROGRAM_NAME = &quot;default&quot;;
+		public const int 		PROGRAM_INIT_SIZE 	= 100;
+
+		/// &lt;summary&gt;
+		/// Track the incoming list of tokens
+		/// &lt;/summary&gt;
+		protected IList tokens;
+
+		/// &lt;summary&gt;
+		/// You may have multiple, named streams of rewrite operations.
+		/// I'm calling these things &quot;programs.&quot;
+		/// Maps string (name) -&gt; rewrite (List)
+		/// &lt;/summary&gt;
+		protected IDictionary programs = null;
+
+		/// &lt;summary&gt;
+		/// Map string (program name) -&gt; Integer index
+		/// &lt;/summary&gt;
+		protected IDictionary lastRewriteTokenIndexes = null;
+
+		/// &lt;summary&gt;
+		/// track index of tokens
+		/// &lt;/summary&gt;
+		protected int index = MIN_TOKEN_INDEX;
+
+		/// &lt;summary&gt;
+		/// Who do we suck tokens from?
+		/// &lt;/summary&gt;
+		protected TokenStream stream;
+
+		/// &lt;summary&gt;
+		/// Which (whitespace) token(s) to throw out
+		/// &lt;/summary&gt;
+		protected BitSet discardMask = new BitSet();
+
+		public TokenStreamRewriteEngine(TokenStream upstream) : this(upstream, 1000)
+		{
+		}
+
+		public TokenStreamRewriteEngine(TokenStream upstream, int initialSize) 
+		{
+			stream   = upstream;
+			tokens   = new ArrayList(initialSize);
+			programs = new Hashtable();
+			programs[DEFAULT_PROGRAM_NAME]	= new ArrayList(PROGRAM_INIT_SIZE);
+			lastRewriteTokenIndexes			= new Hashtable();
+		}
+
+		public IToken nextToken() 				// throws TokenStreamException 
+		{
+			TokenWithIndex t;
+
+			// suck tokens until end of stream or we find a non-discarded token
+			do 
+			{
+				t = (TokenWithIndex) stream.nextToken();
+				if ( t != null ) 
+				{
+					t.setIndex(index);  // what is t's index in list?
+					if ( t.Type != Token.EOF_TYPE ) 
+					{
+						tokens.Add(t);  // track all tokens except EOF
+					}
+					index++;			// move to next position
+				}
+			} while ( (t != null) &amp;&amp; (discardMask.member(t.Type)) );
+
+			return t;
+		}
+
+		public void rollback(int instructionIndex) 
+		{
+			rollback(DEFAULT_PROGRAM_NAME, instructionIndex);
+		}
+
+		/// &lt;summary&gt;
+		/// Rollback the instruction stream for a program so that
+		/// the indicated instruction (via instructionIndex) is no
+		/// longer in the stream.
+		/// &lt;/summary&gt;
+		/// &lt;remarks&gt;
+		/// UNTESTED!
+		/// &lt;/remarks&gt;
+		/// &lt;param name=&quot;programName&quot;&gt;&lt;/param&gt;
+		/// &lt;param name=&quot;instructionIndex&quot;&gt;&lt;/param&gt;
+		public void rollback(string programName, int instructionIndex) 
+		{
+			ArrayList il = (ArrayList) programs[programName];
+			if ( il != null ) 
+			{
+				programs[programName] = il.GetRange(MIN_TOKEN_INDEX, (instructionIndex - MIN_TOKEN_INDEX));
+			}
+		}
+
+		public void deleteProgram() 
+		{
+			deleteProgram(DEFAULT_PROGRAM_NAME);
+		}
+
+		/// &lt;summary&gt;
+		/// Reset the program so that no instructions exist
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;programName&quot;&gt;&lt;/param&gt;
+		public void deleteProgram(string programName) 
+		{
+			rollback(programName, MIN_TOKEN_INDEX);
+		}
+
+		/// &lt;summary&gt;
+		/// If op.index &gt; lastRewriteTokenIndexes, just add to the end.
+		/// Otherwise, do linear
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;op&quot;&gt;&lt;/param&gt;
+		protected void addToSortedRewriteList(RewriteOperation op) 
+		{
+			addToSortedRewriteList(DEFAULT_PROGRAM_NAME, op);
+		}
+
+		protected void addToSortedRewriteList(string programName, RewriteOperation op) 
+		{
+			ArrayList rewrites = (ArrayList) getProgram(programName);
+			// if at or beyond last op's index, just append
+			if ( op.index &gt;= getLastRewriteTokenIndex(programName) ) 
+			{
+				rewrites.Add(op); // append to list of operations
+				// record the index of this operation for next time through
+				setLastRewriteTokenIndex(programName, op.index);
+				return;
+			}
+			// not after the last one, so must insert to ordered list
+			int pos = rewrites.BinarySearch(op, RewriteOperationComparer.Default);
+			if (pos &lt; 0) 
+			{
+				rewrites.Insert(-pos-1, op);
+			}
+		}
+
+		public void insertAfter(IToken t, string text) 
+		{
+			insertAfter(DEFAULT_PROGRAM_NAME, t, text);
+		}
+
+		public void insertAfter(int index, string text) 
+		{
+			insertAfter(DEFAULT_PROGRAM_NAME, index, text);
+		}
+
+		public void insertAfter(string programName, IToken t, string text) 
+		{
+			insertAfter(programName,((TokenWithIndex) t).getIndex(), text); 
+		}
+
+		public void insertAfter(string programName, int index, string text) 
+		{
+			// to insert after, just insert before next index (even if past end)
+			insertBefore(programName, index+1, text); 
+		}
+
+		public void insertBefore(IToken t, string text) 
+		{
+			insertBefore(DEFAULT_PROGRAM_NAME, t, text);
+		}
+
+		public void insertBefore(int index, string text) 
+		{
+			insertBefore(DEFAULT_PROGRAM_NAME, index, text);
+		}
+
+		public void insertBefore(string programName, IToken t, string text) 
+		{
+			insertBefore(programName, ((TokenWithIndex) t).getIndex(), text);
+		}
+
+		public void insertBefore(string programName, int index, string text) 
+		{
+			addToSortedRewriteList(programName, new InsertBeforeOp(index, text));
+		}
+
+		public void replace(int index, string text) 
+		{
+			replace(DEFAULT_PROGRAM_NAME, index, index, text);
+		}
+
+		public void replace(int from, int to, string text) 
+		{
+			replace(DEFAULT_PROGRAM_NAME, from, to, text);
+		}
+
+		public void replace(IToken indexT, string text) 
+		{
+			replace(DEFAULT_PROGRAM_NAME, indexT, indexT, text);
+		}
+
+		public void replace(IToken from, IToken to, string text) 
+		{
+			replace(DEFAULT_PROGRAM_NAME, from, to, text);
+		}
+
+		public void replace(string programName, int from, int to, string text) 
+		{
+			addToSortedRewriteList(new ReplaceOp(from, to, text));
+		}
+
+		public void replace(string programName, IToken from, IToken to, string text) 
+		{
+			replace(programName,
+				((TokenWithIndex) from).getIndex(),
+				((TokenWithIndex) to).getIndex(),
+				text);
+		}
+
+		public void delete(int index) 
+		{
+			delete(DEFAULT_PROGRAM_NAME, index, index);
+		}
+
+		public void delete(int from, int to) 
+		{
+			delete(DEFAULT_PROGRAM_NAME, from, to);
+		}
+
+		public void delete(IToken indexT) 
+		{
+			delete(DEFAULT_PROGRAM_NAME, indexT, indexT);
+		}
+
+		public void delete(IToken from, IToken to) 
+		{
+			delete(DEFAULT_PROGRAM_NAME, from, to);
+		}
+
+		public void delete(string programName, int from, int to) 
+		{
+			replace(programName, from, to, null);
+		}
+
+		public void delete(string programName, IToken from, IToken to) 
+		{
+			replace(programName, from, to, null);
+		}
+
+		public void discard(int ttype) 
+		{
+			discardMask.add(ttype);
+		}
+
+		public TokenWithIndex getToken(int i) 
+		{
+			return (TokenWithIndex) tokens[i];
+		}
+
+		public int getTokenStreamSize() 
+		{
+			return tokens.Count;
+		}
+
+		public string ToOriginalString() 
+		{
+			return ToOriginalString(MIN_TOKEN_INDEX, getTokenStreamSize()-1);
+		}
+
+		public string ToOriginalString(int start, int end) 
+		{
+			StringBuilder buf = new StringBuilder();
+			for (int i = start; (i &gt;= MIN_TOKEN_INDEX) &amp;&amp; (i &lt;= end) &amp;&amp; (i &lt; tokens.Count); i++) 
+			{
+				buf.Append(getToken(i).getText());
+			}
+			return buf.ToString();
+		}
+
+		public override string ToString() 
+		{
+			return ToString(MIN_TOKEN_INDEX, getTokenStreamSize());
+		}
+
+		public string ToString(string programName) 
+		{
+			return ToString(programName, MIN_TOKEN_INDEX, getTokenStreamSize());
+		}
+
+		public string ToString(int start, int end) 
+		{
+			return ToString(DEFAULT_PROGRAM_NAME, start, end);
+		}
+
+		public string ToString(string programName, int start, int end) 
+		{
+			IList rewrites = (IList) programs[programName];
+			if (rewrites == null) 
+			{
+				return null; // invalid program
+			}
+			StringBuilder buf = new StringBuilder();
+
+			// Index of first rewrite we have not done
+			int rewriteOpIndex = 0;
+
+			int tokenCursor = start;
+			while ( (tokenCursor &gt;= MIN_TOKEN_INDEX) &amp;&amp;
+				(tokenCursor &lt;= end) &amp;&amp;
+				(tokenCursor &lt; tokens.Count) )
+			{
+				if (rewriteOpIndex &lt; rewrites.Count) 
+				{
+					RewriteOperation op = (RewriteOperation) rewrites[rewriteOpIndex];
+					while ( (tokenCursor == op.index) &amp;&amp; (rewriteOpIndex &lt; rewrites.Count) ) 
+					{
+						/*
+						Console.Out.WriteLine(&quot;execute op &quot;+rewriteOpIndex+
+											&quot; (type &quot;+op.GetType().FullName+&quot;)&quot;
+											+&quot; at index &quot;+op.index);
+						*/
+						tokenCursor = op.execute(buf);
+						rewriteOpIndex++;
+						if (rewriteOpIndex &lt; rewrites.Count) 
+						{
+							op = (RewriteOperation) rewrites[rewriteOpIndex];
+						}
+					}
+				}
+				if ( tokenCursor &lt; end ) 
+				{
+					buf.Append(getToken(tokenCursor).getText());
+					tokenCursor++;
+				}
+			}
+			// now see if there are operations (append) beyond last token index
+			for (int opi = rewriteOpIndex; opi &lt; rewrites.Count; opi++) 
+			{
+				RewriteOperation op = (RewriteOperation) rewrites[opi];
+				op.execute(buf); // must be insertions if after last token
+			}
+
+			return buf.ToString();
+		}
+
+		public string ToDebugString() 
+		{
+			return ToDebugString(MIN_TOKEN_INDEX, getTokenStreamSize());
+		}
+
+		public string ToDebugString(int start, int end) 
+		{
+			StringBuilder buf = new StringBuilder();
+			for (int i = start; (i &gt;= MIN_TOKEN_INDEX) &amp;&amp; (i &lt;= end) &amp;&amp; (i &lt; tokens.Count); i++) 
+			{
+				buf.Append(getToken(i));
+			}
+			return buf.ToString();
+		}
+
+		public int getLastRewriteTokenIndex() 
+		{
+			return getLastRewriteTokenIndex(DEFAULT_PROGRAM_NAME);
+		}
+
+		protected int getLastRewriteTokenIndex(string programName) 
+		{
+			object i = lastRewriteTokenIndexes[programName];
+			if (i == null)
+			{
+				return -1;
+			}
+			return (int) i;
+		}
+
+		protected void setLastRewriteTokenIndex(string programName, int i) 
+		{
+			lastRewriteTokenIndexes[programName] = (object) i;
+		}
+
+		protected IList getProgram(string name) 
+		{
+			IList il = (IList) programs[name];
+			if ( il == null ) 
+			{
+				il = initializeProgram(name);
+			}
+			return il;
+		}
+
+		private IList initializeProgram(string name) 
+		{
+			IList il = new ArrayList(PROGRAM_INIT_SIZE);
+			programs[name] = il;
+			return il;
+		}
+
+		public class RewriteOperationComparer : IComparer
+		{
+			public static readonly RewriteOperationComparer Default = new RewriteOperationComparer();
+		
+			public virtual int Compare(object o1, object o2)
+			{
+				RewriteOperation rop1 = (RewriteOperation) o1;
+				RewriteOperation rop2 = (RewriteOperation) o2;
+
+				if (rop1.index &lt; rop2.index) return -1;
+				if (rop1.index &gt; rop2.index) return 1;
+				return 0;
+			}
+		}
+	}
+}

Added: trunk/src/antlr-runtime/antlr/TokenStreamSelector.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenStreamSelector.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenStreamSelector.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,118 @@
+using System;
+using Hashtable		= System.Collections.Hashtable;
+using Stack    		= System.Collections.Stack;
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*A token stream MUX (multiplexor) knows about n token streams
+	*  and can multiplex them onto the same channel for use by token
+	*  stream consumer like a parser.  This is a way to have multiple
+	*  lexers break up the same input stream for a single parser.
+	*	Or, you can have multiple instances of the same lexer handle
+	*  multiple input streams; this works great for includes.
+	*/
+	public class TokenStreamSelector : TokenStream
+	{
+		/*The set of inputs to the MUX */
+		protected internal Hashtable inputStreamNames;
+		
+		/*The currently-selected token stream input */
+		protected internal TokenStream input;
+		
+		/*Used to track stack of input streams */
+		protected internal Stack streamStack = new Stack();
+		
+		public TokenStreamSelector() : base()
+		{
+			inputStreamNames = new Hashtable();
+		}
+		public virtual void  addInputStream(TokenStream stream, string key)
+		{
+			inputStreamNames[key] = stream;
+		}
+		/*Return the stream from tokens are being pulled at
+		*  the moment.
+		*/
+		public virtual TokenStream getCurrentStream()
+		{
+			return input;
+		}
+		public virtual TokenStream getStream(string sname)
+		{
+			TokenStream stream = (TokenStream) inputStreamNames[sname];
+			if (stream == null)
+			{
+				throw new System.ArgumentException(&quot;TokenStream &quot; + sname + &quot; not found&quot;);
+			}
+			return stream;
+		}
+		public virtual IToken nextToken()
+		{
+			// return input.nextToken();
+			// keep looking for a token until you don't
+			// get a retry exception.
+			 for (; ; )
+			{
+				try
+				{
+					return input.nextToken();
+				}
+				catch (TokenStreamRetryException)
+				{
+					// just retry &quot;forever&quot;
+				}
+			}
+		}
+		public virtual TokenStream pop()
+		{
+			TokenStream stream = (TokenStream) streamStack.Pop();
+			select(stream);
+			return stream;
+		}
+		public virtual void  push(TokenStream stream)
+		{
+			streamStack.Push(input); // save current stream
+			select(stream);
+		}
+		public virtual void  push(string sname)
+		{
+			streamStack.Push(input);
+			select(sname);
+		}
+		/*Abort recognition of current Token and try again.
+		*  A stream can push a new stream (for include files
+		*  for example, and then retry(), which will cause
+		*  the current stream to abort back to this.nextToken().
+		*  this.nextToken() then asks for a token from the
+		*  current stream, which is the new &quot;substream.&quot;
+		*/
+		public virtual void  retry()
+		{
+			throw new TokenStreamRetryException();
+		}
+		/*Set the stream without pushing old stream */
+		public virtual void  select(TokenStream stream)
+		{
+			input = stream;
+		}
+		public virtual void  select(string sname)
+		{
+			input = getStream(sname);
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TokenStreamSelector.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TokenWithIndex.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TokenWithIndex.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TokenWithIndex.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,51 @@
+namespace antlr
+{
+	/* ANTLR Translator Generator
+	 * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	 * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	 */
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+
+	using System;
+
+	 /// &lt;summary&gt;
+	 /// This token tracks it's own index 0..n-1 relative to the beginning 
+	 /// of the stream. It is designed to work with 
+	 /// &lt;see cref=&quot;TokenStreamRewriteEngine&quot;/&gt; in TokenStreamRewriteEngine.cs
+	 /// &lt;/summary&gt; 
+	public class TokenWithIndex : CommonToken 
+	{
+		/// &lt;summary&gt;
+		/// Index into token array indicating position in input stream
+		/// &lt;/summary&gt;
+	    int index;
+
+	    public TokenWithIndex() : base()
+	    {
+	    }
+
+	    public TokenWithIndex(int i, string t) : base(i, t)
+	    {
+	    }
+
+		public void setIndex(int i)
+		{
+			index = i;
+		}
+
+		public int getIndex() 
+		{
+			return index;
+		}
+
+		public override string ToString()
+		{
+			return &quot;[&quot;+index+&quot;:\&quot;&quot; + getText() + &quot;\&quot;,&lt;&quot; + Type + &quot;&gt;,line=&quot; + line + &quot;,col=&quot; + col + &quot;]\n&quot;;
+		}
+	}
+}
\ No newline at end of file

Added: trunk/src/antlr-runtime/antlr/TreeParser.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TreeParser.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TreeParser.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,178 @@
+using System;
+using AST = antlr.collections.AST;
+using BitSet = antlr.collections.impl.BitSet;
+	
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	public class TreeParser
+	{
+		/*The AST Null object; the parsing cursor is set to this when
+		*  it is found to be null.  This way, we can test the
+		*  token type of a node without having to have tests for null
+		*  everywhere.
+		*/
+		public static ASTNULLType ASTNULL = new ASTNULLType();
+		
+		/*Where did this rule leave off parsing; avoids a return parameter */
+		protected internal AST retTree_;
+		
+		/*guessing nesting level; guessing==0 implies not guessing */
+		// protected int guessing = 0;
+		
+		/*Nesting level of registered handlers */
+		// protected int exceptionLevel = 0;
+		
+		protected internal TreeParserSharedInputState inputState;
+		
+		/*Table of token type to token names */
+		protected internal string[] tokenNames;
+		
+		/*AST return value for a rule is squirreled away here */
+		protected internal AST returnAST;
+		
+		/*AST support code; parser and treeparser delegate to this object */
+		protected internal ASTFactory astFactory = new ASTFactory();
+		
+		/*Used to keep track of indentdepth for traceIn/Out */
+		protected internal int traceDepth = 0;
+		
+		public TreeParser()
+		{
+			inputState = new TreeParserSharedInputState();
+		}
+		/*Get the AST return value squirreled away in the parser */
+		public virtual AST getAST()
+		{
+			return returnAST;
+		}
+		public virtual ASTFactory getASTFactory()
+		{
+			return astFactory;
+		}
+		public virtual void resetState()
+		{
+			traceDepth  = 0;
+			returnAST	= null;
+			retTree_	= null;
+			inputState.reset();
+		}
+		public virtual string getTokenName(int num)
+		{
+			return tokenNames[num];
+		}
+		public virtual string[] getTokenNames()
+		{
+			return tokenNames;
+		}
+		protected internal virtual void  match(AST t, int ttype)
+		{
+			//System.out.println(&quot;match(&quot;+ttype+&quot;); cursor is &quot;+t);
+			if (t == null || t == ASTNULL || t.Type != ttype)
+			{
+				throw new MismatchedTokenException(getTokenNames(), t, ttype, false);
+			}
+		}
+		/*Make sure current lookahead symbol matches the given set
+		* Throw an exception upon mismatch, which is catch by either the
+		* error handler or by the syntactic predicate.
+		*/
+		public virtual void  match(AST t, BitSet b)
+		{
+			if (t == null || t == ASTNULL || !b.member(t.Type))
+			{
+				throw new MismatchedTokenException(getTokenNames(), t, b, false);
+			}
+		}
+		protected internal virtual void  matchNot(AST t, int ttype)
+		{
+			//System.out.println(&quot;match(&quot;+ttype+&quot;); cursor is &quot;+t);
+			if (t == null || t == ASTNULL || t.Type == ttype)
+			{
+				throw new MismatchedTokenException(getTokenNames(), t, ttype, true);
+			}
+		}
+
+		/// &lt;summary&gt;
+		/// @deprecated as of 2.7.2. This method calls System.exit() and writes
+		/// directly to stderr, which is usually not appropriate when
+		/// a parser is embedded into a larger application. Since the method is
+		/// &lt;code&gt;static&lt;/code&gt;, it cannot be overridden to avoid these problems.
+		/// ANTLR no longer uses this method internally or in generated code.
+		/// &lt;/summary&gt;
+		/// 
+		[Obsolete(&quot;De-activated since version 2.7.2.6 as it cannot be overidden.&quot;, true)]
+		public static void panic()
+		{
+			Console.Error.WriteLine(&quot;TreeWalker: panic&quot;);
+			System.Environment.Exit(1);
+		}
+		/*Parser error-reporting function can be overridden in subclass */
+		public virtual void  reportError(RecognitionException ex)
+		{
+			Console.Error.WriteLine(ex.ToString());
+		}
+		/*Parser error-reporting function can be overridden in subclass */
+		public virtual void  reportError(string s)
+		{
+			Console.Error.WriteLine(&quot;error: &quot; + s);
+		}
+		/*Parser warning-reporting function can be overridden in subclass */
+		public virtual void  reportWarning(string s)
+		{
+			Console.Error.WriteLine(&quot;warning: &quot; + s);
+		}
+		/*Specify an object with support code (shared by
+		*  Parser and TreeParser.  Normally, the programmer
+		*  does not play with this, using setASTNodeType instead.
+		*/
+		public virtual void  setASTFactory(ASTFactory f)
+		{
+			astFactory = f;
+		}
+		
+		/*Specify the type of node to create during tree building */
+		public virtual void  setASTNodeType(string nodeType)
+		{
+			setASTNodeClass(nodeType);
+		}
+		
+		/*Specify the type of node to create during tree building */
+		public virtual void  setASTNodeClass(string nodeType)
+		{
+			astFactory.setASTNodeType(nodeType);
+		}
+		
+		public virtual void  traceIndent()
+		{
+			 for (int i = 0; i &lt; traceDepth; i++)
+				Console.Out.Write(&quot; &quot;);
+		}
+		public virtual void  traceIn(string rname, AST t)
+		{
+			traceDepth += 1;
+			traceIndent();
+			Console.Out.WriteLine(&quot;&gt; &quot; + rname + &quot;(&quot; + ((t != null) ? t.ToString() : &quot;null&quot;) + &quot;)&quot; + ((inputState.guessing &gt; 0) ? &quot; [guessing]&quot; : &quot;&quot;));
+		}
+		public virtual void  traceOut(string rname, AST t)
+		{
+			traceIndent();
+			Console.Out.WriteLine(&quot;&lt; &quot; + rname + &quot;(&quot; + ((t != null) ? t.ToString() : &quot;null&quot;) + &quot;)&quot; + ((inputState.guessing &gt; 0) ? &quot; [guessing]&quot; : &quot;&quot;));
+			traceDepth--;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TreeParser.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr/TreeParserSharedInputState.cs
===================================================================
--- trunk/src/antlr-runtime/antlr/TreeParserSharedInputState.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr/TreeParserSharedInputState.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,37 @@
+using System;
+
+namespace antlr
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*This object contains the data associated with an
+	*  input AST.  Multiple parsers
+	*  share a single TreeParserSharedInputState to parse
+	*  the same tree or to have the parser walk multiple
+	*  trees.
+	*/
+
+	public class TreeParserSharedInputState
+	{
+		/*Are we guessing (guessing&gt;0)? */
+		public int guessing = 0;
+
+		public virtual void reset()
+		{
+			guessing = 0;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr/TreeParserSharedInputState.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.collections/AST.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.collections/AST.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.collections/AST.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,89 @@
+using System;
+using IEnumerator = System.Collections.IEnumerator;
+
+using IToken = antlr.IToken;
+	
+namespace antlr.collections
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/// &lt;summary&gt;
+	/// Minimal AST node interface used by ANTLR AST generation and tree-walker.
+	/// &lt;/summary&gt;
+	public interface AST : ICloneable
+	{
+		/// &lt;summary&gt;
+		/// Add a (rightmost) child to this node
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;c&quot;&gt;&lt;/param&gt;
+		void  addChild(AST c);
+		bool Equals(AST t);
+		bool EqualsList(AST t);
+		bool EqualsListPartial(AST t);
+		bool EqualsTree(AST t);
+		bool EqualsTreePartial(AST t);
+		IEnumerator findAll(AST tree);
+		IEnumerator findAllPartial(AST subtree);
+		/// &lt;summary&gt;
+		/// Get the first child of this node; null if no children
+		/// &lt;/summary&gt;
+		AST getFirstChild();
+		/// &lt;summary&gt;
+		/// Get	the next sibling in line after this one
+		/// &lt;/summary&gt;
+		AST getNextSibling();
+		/// &lt;summary&gt;
+		/// Get the token text for this node
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;/returns&gt;
+		string getText();
+		/// &lt;summary&gt;
+		/// Get the token type for this node
+		/// &lt;/summary&gt;
+		int Type	{ get; set;}
+		/// &lt;summary&gt;
+		/// Get number of children of this node; if leaf, returns 0
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;Number of children&lt;/returns&gt;
+		int getNumberOfChildren();
+		void  initialize(int t, string txt);
+		void  initialize(AST t);
+		void  initialize(IToken t);
+		/// &lt;summary&gt;
+		/// Set the first child of a node.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;c&quot;&gt;&lt;/param&gt;
+		void  setFirstChild(AST c);
+		/// &lt;summary&gt;
+		/// Set the next sibling after this one.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;n&quot;&gt;&lt;/param&gt;
+		void  setNextSibling(AST n);
+		/// &lt;summary&gt;
+		/// Set the token text for this node
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;
+		void  setText(string text);
+		/// &lt;summary&gt;
+		/// Set the token type for this node
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;ttype&quot;&gt;&lt;/param&gt;
+		void  setType(int ttype);
+		string ToString();
+		string ToStringList();
+		string ToStringTree();
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.collections/AST.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.collections.impl/ASTArray.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.collections.impl/ASTArray.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.collections.impl/ASTArray.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,42 @@
+using System;
+using AST = antlr.collections.AST;
+	
+namespace antlr.collections.impl
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+
+	/*ASTArray is a class that allows ANTLR to
+	* generate code that can create and initialize an array
+	* in one expression, like:
+	*    (new ASTArray(3)).add(x).add(y).add(z)
+	*/
+	public class ASTArray
+	{
+		public int size = 0;
+		public AST[] array;
+		
+		
+		public ASTArray(int capacity)
+		{
+			array = new AST[capacity];
+		}
+		public virtual ASTArray add(AST node)
+		{
+			array[size++] = node;
+			return this;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.collections.impl/ASTArray.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.collections.impl/BitSet.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.collections.impl/BitSet.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.collections.impl/BitSet.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,539 @@
+using System;
+using ArrayList					= System.Collections.ArrayList;
+
+//using CharFormatter				= antlr.CharFormatter;
+
+namespace antlr.collections.impl
+{
+	/*ANTLR Translator Generator
+	* Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	* Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	*
+	* $Id:$
+	*/
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+	// With many thanks to Eric V. Smith from the ANTLR list.
+	//
+	
+	/*A BitSet to replace java.util.BitSet.
+	* Primary differences are that most set operators return new sets
+	* as opposed to oring and anding &quot;in place&quot;.  Further, a number of
+	* operations were added.  I cannot contain a BitSet because there
+	* is no way to access the internal bits (which I need for speed)
+	* and, because it is final, I cannot subclass to add functionality.
+	* Consider defining set degree.  Without access to the bits, I must
+	* call a method n times to test the ith bit...ack!
+	*
+	* Also seems like or() from util is wrong when size of incoming set is bigger
+	* than this.bits.length.
+	*
+	* @author Terence Parr
+	* @author &lt;br&gt;&lt;a href=&quot;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">pete at yamuna.demon.co.uk</A>&quot;&gt;Pete Wells&lt;/a&gt;
+	*/
+
+	public class BitSet : ICloneable
+	{
+		protected internal const int BITS = 64; // number of bits / long
+		protected internal const int NIBBLE = 4;
+		protected internal const int LOG_BITS = 6; // 2^6 == 64
+		
+		/*We will often need to do a mod operator (i mod nbits).  Its
+		* turns out that, for powers of two, this mod operation is
+		* same as (i &amp; (nbits-1)).  Since mod is slow, we use a
+		* precomputed mod mask to do the mod instead.
+		*/
+		protected internal static readonly int MOD_MASK = BITS - 1;
+		
+		/*The actual data bits */
+		protected internal long[] dataBits;
+		
+		/*Construct a bitset of size one word (64 bits) */
+		public BitSet() : this(BITS)
+		{
+		}
+		
+		/*Construction from a static array of longs */
+		public BitSet(long[] bits_)
+		{
+			dataBits = bits_;
+		}
+		
+		/*Construct a bitset given the size
+		* @param nbits The size of the bitset in bits
+		*/
+		public BitSet(int nbits)
+		{
+			dataBits = new long[((nbits - 1) &gt;&gt; LOG_BITS) + 1];
+		}
+		
+		/*or this element into this set (grow as necessary to accommodate) */
+		public virtual void  add(int el)
+		{
+			int n = wordNumber(el);
+			if (n &gt;= dataBits.Length)
+			{
+				growToInclude(el);
+			}
+			dataBits[n] |= bitMask(el);
+		}
+		
+		public virtual BitSet and(BitSet a)
+		{
+			BitSet s = (BitSet) this.Clone();
+			s.andInPlace(a);
+			return s;
+		}
+		
+		public virtual void  andInPlace(BitSet a)
+		{
+			int min = (int) (Math.Min(dataBits.Length, a.dataBits.Length));
+			 for (int i = min - 1; i &gt;= 0; i--)
+			{
+				dataBits[i] &amp;= a.dataBits[i];
+			}
+			// clear all bits in this not present in a (if this bigger than a).
+			 for (int i = min; i &lt; dataBits.Length; i++)
+			{
+				dataBits[i] = 0;
+			}
+		}
+		
+		private static long bitMask(int bitNumber)
+		{
+			int bitPosition = bitNumber &amp; MOD_MASK; // bitNumber mod BITS
+			return 1L &lt;&lt; bitPosition;
+		}
+		
+		public virtual void  clear()
+		{
+			 for (int i = dataBits.Length - 1; i &gt;= 0; i--)
+			{
+				dataBits[i] = 0;
+			}
+		}
+		
+		public virtual void  clear(int el)
+		{
+			int n = wordNumber(el);
+			if (n &gt;= dataBits.Length)
+			{
+				// grow as necessary to accommodate
+				growToInclude(el);
+			}
+			dataBits[n] &amp;= ~ bitMask(el);
+		}
+		
+		public virtual object Clone()
+		{
+			BitSet s;
+			try
+			{
+				s = new BitSet();
+				s.dataBits = new long[dataBits.Length];
+				Array.Copy(dataBits, 0, s.dataBits, 0, dataBits.Length);
+			}
+			catch //(System.Exception e)
+			{
+				throw new System.ApplicationException();
+			}
+			return s;
+		}
+		
+		public virtual int degree()
+		{
+			int deg = 0;
+			 for (int i = dataBits.Length - 1; i &gt;= 0; i--)
+			{
+				long word = dataBits[i];
+				if (word != 0L)
+				{
+					 for (int bit = BITS - 1; bit &gt;= 0; bit--)
+					{
+						if ((word &amp; (1L &lt;&lt; bit)) != 0)
+						{
+							deg++;
+						}
+					}
+				}
+			}
+			return deg;
+		}
+		
+		override public int GetHashCode()
+		{
+			return dataBits.GetHashCode();
+		}
+
+		/*code &quot;inherited&quot; from java.util.BitSet */
+		override public bool Equals(object obj)
+		{
+			if ((obj != null) &amp;&amp; (obj is BitSet))
+			{
+				BitSet bset = (BitSet) obj;
+				
+				int n = (int) (System.Math.Min(dataBits.Length, bset.dataBits.Length));
+				 for (int i = n; i-- &gt; 0; )
+				{
+					if (dataBits[i] != bset.dataBits[i])
+					{
+						return false;
+					}
+				}
+				if (dataBits.Length &gt; n)
+				{
+					 for (int i = (int) (dataBits.Length); i-- &gt; n; )
+					{
+						if (dataBits[i] != 0)
+						{
+							return false;
+						}
+					}
+				}
+				else if (bset.dataBits.Length &gt; n)
+				{
+					 for (int i = (int) (bset.dataBits.Length); i-- &gt; n; )
+					{
+						if (bset.dataBits[i] != 0)
+						{
+							return false;
+						}
+					}
+				}
+				return true;
+			}
+			return false;
+		}
+		
+		/*
+		* Grows the set to a larger number of bits.
+		* @param bit element that must fit in set
+		*/
+		public virtual void  growToInclude(int bit)
+		{
+			int newSize = (int) (System.Math.Max(dataBits.Length &lt;&lt; 1, numWordsToHold(bit)));
+			long[] newbits = new long[newSize];
+			Array.Copy(dataBits, 0, newbits, 0, dataBits.Length);
+			dataBits = newbits;
+		}
+		
+		public virtual bool member(int el)
+		{
+			int n = wordNumber(el);
+			if (n &gt;= dataBits.Length)
+				return false;
+			return (dataBits[n] &amp; bitMask(el)) != 0;
+		}
+		
+		public virtual bool nil()
+		{
+			 for (int i = dataBits.Length - 1; i &gt;= 0; i--)
+			{
+				if (dataBits[i] != 0)
+					return false;
+			}
+			return true;
+		}
+		
+		public virtual BitSet not()
+		{
+			BitSet s = (BitSet) this.Clone();
+			s.notInPlace();
+			return s;
+		}
+		
+		public virtual void  notInPlace()
+		{
+			 for (int i = dataBits.Length - 1; i &gt;= 0; i--)
+			{
+				dataBits[i] = ~ dataBits[i];
+			}
+		}
+		
+		/*complement bits in the range 0..maxBit. */
+		public virtual void  notInPlace(int maxBit)
+		{
+			notInPlace(0, maxBit);
+		}
+		
+		/*complement bits in the range minBit..maxBit.*/
+		public virtual void  notInPlace(int minBit, int maxBit)
+		{
+			// make sure that we have room for maxBit
+			growToInclude(maxBit);
+			 for (int i = minBit; i &lt;= maxBit; i++)
+			{
+				int n = wordNumber(i);
+				dataBits[n] ^= bitMask(i);
+			}
+		}
+		
+		private int numWordsToHold(int el)
+		{
+			return (el &gt;&gt; LOG_BITS) + 1;
+		}
+		
+		public static BitSet of(int el)
+		{
+			BitSet s = new BitSet(el + 1);
+			s.add(el);
+			return s;
+		}
+		
+		/*return this | a in a new set */
+		public virtual BitSet or(BitSet a)
+		{
+			BitSet s = (BitSet) this.Clone();
+			s.orInPlace(a);
+			return s;
+		}
+		
+		public virtual void  orInPlace(BitSet a)
+		{
+			// If this is smaller than a, grow this first
+			if (a.dataBits.Length &gt; dataBits.Length)
+			{
+				setSize((int) (a.dataBits.Length));
+			}
+			int min = (int) (System.Math.Min(dataBits.Length, a.dataBits.Length));
+			 for (int i = min - 1; i &gt;= 0; i--)
+			{
+				dataBits[i] |= a.dataBits[i];
+			}
+		}
+		
+		// remove this element from this set
+		public virtual void  remove(int el)
+		{
+			int n = wordNumber(el);
+			if (n &gt;= dataBits.Length)
+			{
+				growToInclude(el);
+			}
+			dataBits[n] &amp;= ~ bitMask(el);
+		}
+		
+		/*
+		* Sets the size of a set.
+		* @param nwords how many words the new set should be
+		*/
+		private void  setSize(int nwords)
+		{
+			long[] newbits = new long[nwords];
+			int n = (int) (System.Math.Min(nwords, dataBits.Length));
+			Array.Copy(dataBits, 0, newbits, 0, n);
+			dataBits = newbits;
+		}
+		
+		public virtual int size()
+		{
+			return dataBits.Length &lt;&lt; LOG_BITS; // num words * bits per word
+		}
+		
+		/*return how much space is being used by the dataBits array not
+		*  how many actually have member bits on.
+		*/
+		public virtual int lengthInLongWords()
+		{
+			return dataBits.Length;
+		}
+		
+		/*Is this contained within a? */
+		public virtual bool subset(BitSet a)
+		{
+			if (a == null) //(a == null || !(a is BitSet))
+				return false;
+			return this.and(a).Equals(this);
+		}
+		
+		/*Subtract the elements of 'a' from 'this' in-place.
+		* Basically, just turn off all bits of 'this' that are in 'a'.
+		*/
+		public virtual void  subtractInPlace(BitSet a)
+		{
+			if (a == null)
+				return ;
+			// for all words of 'a', turn off corresponding bits of 'this'
+			 for (int i = 0; i &lt; dataBits.Length &amp;&amp; i &lt; a.dataBits.Length; i++)
+			{
+				dataBits[i] &amp;= ~ a.dataBits[i];
+			}
+		}
+		
+		public virtual int[] toArray()
+		{
+			int[] elems = new int[degree()];
+			int en = 0;
+			 for (int i = 0; i &lt; (dataBits.Length &lt;&lt; LOG_BITS); i++)
+			{
+				if (member(i))
+				{
+					elems[en++] = i;
+				}
+			}
+			return elems;
+		}
+		
+		public virtual long[] toPackedArray()
+		{
+			return dataBits;
+		}
+		
+		override public string ToString()
+		{
+			return ToString(&quot;,&quot;);
+		}
+		
+		/*Transform a bit set into a string by formatting each element as an integer
+		* @separator The string to put in between elements
+		* @return A commma-separated list of values
+		*/
+		public virtual string ToString(string separator)
+		{
+			string str = &quot;&quot;;
+			 for (int i = 0; i &lt; (dataBits.Length &lt;&lt; LOG_BITS); i++)
+			{
+				if (member(i))
+				{
+					if (str.Length &gt; 0)
+					{
+						str += separator;
+					}
+					str = str + i;
+				}
+			}
+			return str;
+		}
+		
+		/*Create a string representation where instead of integer elements, the
+		* ith element of vocabulary is displayed instead.  Vocabulary is a Vector
+		* of Strings.
+		* @separator The string to put in between elements
+		* @return A commma-separated list of character constants.
+		*/
+		public virtual string ToString(string separator, ArrayList vocabulary)
+		{
+			if (vocabulary == null)
+			{
+				return ToString(separator);
+			}
+			string str = &quot;&quot;;
+			 for (int i = 0; i &lt; (dataBits.Length &lt;&lt; LOG_BITS); i++)
+			{
+				if (member(i))
+				{
+					if (str.Length &gt; 0)
+					{
+						str += separator;
+					}
+					if (i &gt;= vocabulary.Count)
+					{
+						str += &quot;&lt;bad element &quot; + i + &quot;&gt;&quot;;
+					}
+					else if (vocabulary[i] == null)
+					{
+						str += &quot;&lt;&quot; + i + &quot;&gt;&quot;;
+					}
+					else
+					{
+						str += (string) vocabulary[i];
+					}
+				}
+			}
+			return str;
+		}
+		
+		/*
+		* Dump a comma-separated list of the words making up the bit set.
+		* Split each 64 bit number into two more manageable 32 bit numbers.
+		* This generates a comma-separated list of C++-like unsigned long constants.
+		*/
+		public virtual string toStringOfHalfWords()
+		{
+			string s = new string(&quot;&quot;.ToCharArray());
+			 for (int i = 0; i &lt; dataBits.Length; i++)
+			{
+				if (i != 0)
+					s += &quot;, &quot;;
+				long tmp = dataBits[i];
+				tmp &amp;= 0xFFFFFFFFL;
+				s += (tmp + &quot;UL&quot;);
+				s += &quot;, &quot;;
+				tmp = SupportClass.URShift(dataBits[i], 32);
+				tmp &amp;= 0xFFFFFFFFL;
+				s += (tmp + &quot;UL&quot;);
+			}
+			return s;
+		}
+		
+		/*
+		* Dump a comma-separated list of the words making up the bit set.
+		* This generates a comma-separated list of Java-like long int constants.
+		*/
+		public virtual string toStringOfWords()
+		{
+			string s = new string(&quot;&quot;.ToCharArray());
+			 for (int i = 0; i &lt; dataBits.Length; i++)
+			{
+				if (i != 0)
+					s += &quot;, &quot;;
+				s += (dataBits[i] + &quot;L&quot;);
+			}
+			return s;
+		}
+		
+		/*Print out the bit set but collapse char ranges. */
+/*		public virtual string toStringWithRanges(string separator, CharFormatter formatter)
+		{
+			string str = &quot;&quot;;
+			int[] elems = this.toArray();
+			if (elems.Length == 0)
+			{
+				return &quot;&quot;;
+			}
+			// look for ranges
+			int i = 0;
+			while (i &lt; elems.Length)
+			{
+				int lastInRange;
+				lastInRange = 0;
+				 for (int j = i + 1; j &lt; elems.Length; j++)
+				{
+					if (elems[j] != elems[j - 1] + 1)
+					{
+						break;
+					}
+					lastInRange = j;
+				}
+				// found a range
+				if (str.Length &gt; 0)
+				{
+					str += separator;
+				}
+				if (lastInRange - i &gt;= 2)
+				{
+					str += formatter.literalChar(elems[i]);
+					str += &quot;..&quot;;
+					str += formatter.literalChar(elems[lastInRange]);
+					i = lastInRange; // skip past end of range for next range
+				}
+				else
+				{
+					// no range, just print current char and move on
+					str += formatter.literalChar(elems[i]);
+				}
+				i++;
+			}
+			return str;
+		}
+*/		
+		private static int wordNumber(int bit)
+		{
+			return bit &gt;&gt; LOG_BITS; // bit / BITS
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.collections.impl/BitSet.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ANTLREventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ANTLREventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ANTLREventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,37 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public abstract class ANTLREventArgs : EventArgs
+	{
+		public ANTLREventArgs()
+		{
+		}
+		public ANTLREventArgs(int type)
+		{
+			this.Type = type;
+		}
+	
+		public virtual int Type
+		{
+			get
+			{
+				return this.type_;
+			}
+			set
+			{
+				this.type_ = value;
+			}
+		}
+
+		internal void setValues(int type)
+		{
+			this.Type = type;
+		}
+
+		/// &lt;summary&gt;
+		/// Event type.
+		/// &lt;/summary&gt;
+		private int type_;
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ANTLREventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/DebuggingCharScanner.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/DebuggingCharScanner.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/DebuggingCharScanner.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,322 @@
+namespace antlr.debug
+{
+	using System;
+	using System.Threading;
+	using antlr;
+
+	using BitSet	= antlr.collections.impl.BitSet;
+	
+	public abstract class DebuggingCharScanner : CharScanner, DebuggingParser
+	{
+		private void  InitBlock()
+		{
+			eventSupport = new ScannerEventSupport(this);
+		}
+		public virtual void setDebugMode(bool mode)
+		{
+			_notDebugMode = !mode;
+		}
+
+		private ScannerEventSupport eventSupport;
+		private bool _notDebugMode = false;
+		protected internal string[] ruleNames;
+		protected internal string[] semPredNames;
+		
+		
+		public DebuggingCharScanner(InputBuffer cb) : base(cb)
+		{
+			InitBlock();
+		}
+		public DebuggingCharScanner(LexerSharedInputState state) : base(state)
+		{
+			InitBlock();
+		}
+		public virtual void  addMessageListener(MessageListener l)
+		{
+			eventSupport.addMessageListener(l);
+		}
+		public virtual void  addNewLineListener(NewLineListener l)
+		{
+			eventSupport.addNewLineListener(l);
+		}
+		public virtual void  addParserListener(ParserListener l)
+		{
+			eventSupport.addParserListener(l);
+		}
+		public virtual void  addParserMatchListener(ParserMatchListener l)
+		{
+			eventSupport.addParserMatchListener(l);
+		}
+		public virtual void  addParserTokenListener(ParserTokenListener l)
+		{
+			eventSupport.addParserTokenListener(l);
+		}
+		public virtual void  addSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			eventSupport.addSemanticPredicateListener(l);
+		}
+		public virtual void  addSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			eventSupport.addSyntacticPredicateListener(l);
+		}
+		public virtual void  addTraceListener(TraceListener l)
+		{
+			eventSupport.addTraceListener(l);
+		}
+		public override void  consume()
+		{
+			int la_1 = - 99;
+			try
+			{
+				la_1 = LA(1);
+			}
+			catch (CharStreamException)
+			{
+			}
+			base.consume();
+			eventSupport.fireConsume(la_1);
+		}
+		protected internal virtual void  fireEnterRule(int num, int data)
+		{
+			if (isDebugMode())
+				eventSupport.fireEnterRule(num, inputState.guessing, data);
+		}
+		protected internal virtual void  fireExitRule(int num, int ttype)
+		{
+			if (isDebugMode())
+				eventSupport.fireExitRule(num, inputState.guessing, ttype);
+		}
+		protected internal virtual bool fireSemanticPredicateEvaluated(int type, int num, bool condition)
+		{
+			if (isDebugMode())
+				return eventSupport.fireSemanticPredicateEvaluated(type, num, condition, inputState.guessing);
+			else
+				return condition;
+		}
+		protected internal virtual void  fireSyntacticPredicateFailed()
+		{
+			if (isDebugMode())
+				eventSupport.fireSyntacticPredicateFailed(inputState.guessing);
+		}
+		protected internal virtual void  fireSyntacticPredicateStarted()
+		{
+			if (isDebugMode())
+				eventSupport.fireSyntacticPredicateStarted(inputState.guessing);
+		}
+		protected internal virtual void  fireSyntacticPredicateSucceeded()
+		{
+			if (isDebugMode())
+				eventSupport.fireSyntacticPredicateSucceeded(inputState.guessing);
+		}
+		public virtual string getRuleName(int num)
+		{
+			return ruleNames[num];
+		}
+		public virtual string getSemPredName(int num)
+		{
+			return semPredNames[num];
+		}
+		public virtual void  goToSleep()
+		{
+			lock(this)
+			{
+				try
+				{
+					Monitor.Wait(this);
+				}
+				catch (System.Threading.ThreadInterruptedException)
+				{
+				}
+			}
+		}
+		public virtual bool isDebugMode()
+		{
+			return !_notDebugMode;
+		}
+		public override char LA(int i)
+		{
+			char la = base.LA(i);
+			eventSupport.fireLA(i, la);
+			return la;
+		}
+		protected internal override IToken makeToken(int t)
+		{
+			// do something with char buffer???
+			//		try {
+			//			IToken tok = (Token)tokenObjectClass.newInstance();
+			//			tok.setType(t);
+			//			// tok.setText(getText()); done in generated lexer now
+			//			tok.setLine(line);
+			//			return tok;
+			//		}
+			//		catch (InstantiationException ie) {
+			//			panic(&quot;can't instantiate a Token&quot;);
+			//		}
+			//		catch (IllegalAccessException iae) {
+			//			panic(&quot;Token class is not accessible&quot;);
+			//		}
+			return base.makeToken(t);
+		}
+		public override void  match(int c)
+		{
+			char la_1 = LA(1);
+			try
+			{
+				base.match(c);
+				eventSupport.fireMatch(Convert.ToChar(c), inputState.guessing);
+			}
+			catch (MismatchedCharException e)
+			{
+				if (inputState.guessing == 0)
+					eventSupport.fireMismatch(la_1, Convert.ToChar(c), inputState.guessing);
+				throw e;
+			}
+		}
+		public override void  match(BitSet b)
+		{
+			string text = this.text.ToString();
+			char la_1 = LA(1);
+			try
+			{
+				base.match(b);
+				eventSupport.fireMatch(la_1, b, text, inputState.guessing);
+			}
+			catch (MismatchedCharException e)
+			{
+				if (inputState.guessing == 0)
+					eventSupport.fireMismatch(la_1, b, text, inputState.guessing);
+				throw e;
+			}
+		}
+		public override void  match(string s)
+		{
+			System.Text.StringBuilder la_s = new System.Text.StringBuilder(&quot;&quot;);
+			int len = s.Length;
+			// peek at the next len worth of characters
+			try
+			{
+				 for (int i = 1; i &lt;= len; i++)
+				{
+					la_s.Append(base.LA(i));
+				}
+			}
+			catch (System.Exception)
+			{
+			}
+			
+			try
+			{
+				base.match(s);
+				eventSupport.fireMatch(s, inputState.guessing);
+			}
+			catch (MismatchedCharException e)
+			{
+				if (inputState.guessing == 0)
+					eventSupport.fireMismatch(la_s.ToString(), s, inputState.guessing);
+				throw e;
+			}
+			
+		}
+		public override void  matchNot(int c)
+		{
+			char la_1 = LA(1);
+			try
+			{
+				base.matchNot(c);
+				eventSupport.fireMatchNot(la_1, Convert.ToChar(c), inputState.guessing);
+			}
+			catch (MismatchedCharException e)
+			{
+				if (inputState.guessing == 0)
+					eventSupport.fireMismatchNot(la_1, Convert.ToChar(c), inputState.guessing);
+				throw e;
+			}
+			
+		}
+		public override void  matchRange(int c1, int c2)
+		{
+			char la_1 = LA(1);
+			try
+			{
+				base.matchRange(c1, c2);
+				eventSupport.fireMatch(la_1, &quot;&quot; + c1 + c2, inputState.guessing);
+			}
+			catch (MismatchedCharException e)
+			{
+				if (inputState.guessing == 0)
+					eventSupport.fireMismatch(la_1, &quot;&quot; + c1 + c2, inputState.guessing);
+				throw e;
+			}
+			
+		}
+		public override void  newline()
+		{
+			base.newline();
+			eventSupport.fireNewLine(getLine());
+		}
+		public virtual void  removeMessageListener(MessageListener l)
+		{
+			eventSupport.removeMessageListener(l);
+		}
+		public virtual void  removeNewLineListener(NewLineListener l)
+		{
+			eventSupport.removeNewLineListener(l);
+		}
+		public virtual void  removeParserListener(ParserListener l)
+		{
+			eventSupport.removeParserListener(l);
+		}
+		public virtual void  removeParserMatchListener(ParserMatchListener l)
+		{
+			eventSupport.removeParserMatchListener(l);
+		}
+		public virtual void  removeParserTokenListener(ParserTokenListener l)
+		{
+			eventSupport.removeParserTokenListener(l);
+		}
+		public virtual void  removeSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			eventSupport.removeSemanticPredicateListener(l);
+		}
+		public virtual void  removeSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			eventSupport.removeSyntacticPredicateListener(l);
+		}
+		public virtual void  removeTraceListener(TraceListener l)
+		{
+			eventSupport.removeTraceListener(l);
+		}
+		/// &lt;summary&gt;Report exception errors caught in nextToken() 
+		/// &lt;/summary&gt;
+		public virtual void  reportError(MismatchedCharException e)
+		{
+			eventSupport.fireReportError(e);
+			base.reportError(e);
+		}
+		/// &lt;summary&gt;Parser error-reporting function can be overridden in subclass 
+		/// &lt;/summary&gt;
+		public override void  reportError(string s)
+		{
+			eventSupport.fireReportError(s);
+			base.reportError(s);
+		}
+		/// &lt;summary&gt;Parser warning-reporting function can be overridden in subclass 
+		/// &lt;/summary&gt;
+		public override void  reportWarning(string s)
+		{
+			eventSupport.fireReportWarning(s);
+			base.reportWarning(s);
+		}
+		public virtual void  setupDebugging()
+		{
+		}
+
+		public virtual void  wakeUp()
+		{
+			lock(this)
+			{
+				Monitor.Pulse(this);
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/DebuggingCharScanner.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/DebuggingInputBuffer.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/DebuggingInputBuffer.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/DebuggingInputBuffer.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,82 @@
+namespace antlr.debug
+{
+	using System;
+	using ArrayList	= System.Collections.ArrayList;
+	
+	public class DebuggingInputBuffer : InputBuffer
+	{
+		public virtual ArrayList InputBufferListeners
+		{
+			get { return inputBufferEventSupport.InputBufferListeners; }
+		}
+		public virtual bool DebugMode
+		{
+			set	{ debugMode = value;	}
+		}
+
+		private InputBuffer buffer;
+		private InputBufferEventSupport inputBufferEventSupport;
+		private bool debugMode = true;
+		
+		
+		public DebuggingInputBuffer(InputBuffer buffer)
+		{
+			this.buffer = buffer;
+			inputBufferEventSupport = new InputBufferEventSupport(this);
+		}
+		public virtual void  addInputBufferListener(InputBufferListener l)
+		{
+			inputBufferEventSupport.addInputBufferListener(l);
+		}
+		public override char  consume()
+		{
+			char la = ' ';
+			try
+			{
+				la = buffer.LA(1);
+			}
+			catch (CharStreamException)
+			{
+			} // vaporize it...
+			buffer.consume();
+			if (debugMode)
+				inputBufferEventSupport.fireConsume(la);
+			return la;
+		}
+		public override void  fill(int a)
+		{
+			buffer.fill(a);
+		}
+		public virtual bool isDebugMode()
+		{
+			return debugMode;
+		}
+		public override bool isMarked()
+		{
+			return buffer.isMarked();
+		}
+		public override char LA(int i)
+		{
+			char la = buffer.LA(i);
+			if (debugMode)
+				inputBufferEventSupport.fireLA(la, i);
+			return la;
+		}
+		public override int mark()
+		{
+			int m = buffer.mark();
+			inputBufferEventSupport.fireMark(m);
+			return m;
+		}
+		public virtual void  removeInputBufferListener(InputBufferListener l)
+		{
+			if (inputBufferEventSupport != null)
+				inputBufferEventSupport.removeInputBufferListener(l);
+		}
+		public override void  rewind(int mark)
+		{
+			buffer.rewind(mark);
+			inputBufferEventSupport.fireRewind(mark);
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/DebuggingInputBuffer.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/DebuggingParser.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/DebuggingParser.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/DebuggingParser.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,12 @@
+namespace antlr.debug
+{
+	using System;
+	
+	/// &lt;summary&gt; This type was created in VisualAge.
+	/// &lt;/summary&gt;
+	public interface DebuggingParser
+	{
+		string getRuleName(int n);
+		string getSemPredName(int n);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/DebuggingParser.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/GuessingEventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/GuessingEventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/GuessingEventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,31 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public abstract class GuessingEventArgs : ANTLREventArgs
+	{
+		public GuessingEventArgs()
+		{
+		}
+		public GuessingEventArgs(int type) : base(type)
+		{
+		}
+
+		public virtual int Guessing
+		{
+			get	{ return guessing_;			}
+			set	{ this.guessing_ = value;	}
+		}
+
+		private int guessing_;
+		
+		
+		/// &lt;summary&gt;This should NOT be called from anyone other than ParserEventSupport! 
+		/// &lt;/summary&gt;
+		public virtual void  setValues(int type, int guessing)
+		{
+			setValues(type);
+			this.Guessing = guessing;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/GuessingEventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ICharScannerDebugSubject.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ICharScannerDebugSubject.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ICharScannerDebugSubject.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,15 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface ICharScannerDebugSubject : IDebugSubject
+	{
+		event NewLineEventHandler				HitNewLine;
+		event MatchEventHandler					MatchedChar;
+		event MatchEventHandler					MatchedNotChar;
+		event MatchEventHandler					MisMatchedChar;
+		event MatchEventHandler					MisMatchedNotChar;
+		event TokenEventHandler					ConsumedChar;
+		event TokenEventHandler					CharLA;
+	}
+}


Property changes on: trunk/src/antlr-runtime/antlr.debug/ICharScannerDebugSubject.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/IDebugSubject.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/IDebugSubject.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/IDebugSubject.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,23 @@
+namespace antlr.debug
+{
+	using System;
+	//using EventHandlerList	= System.ComponentModel.EventHandlerList;
+	
+	public interface IDebugSubject
+	{
+	/*	EventHandlerList Events 
+		{
+			get;
+		}
+*/
+		event TraceEventHandler					EnterRule;
+		event TraceEventHandler					ExitRule;
+		event TraceEventHandler					Done;
+		event MessageEventHandler				ErrorReported;
+		event MessageEventHandler				WarningReported;
+		event SemanticPredicateEventHandler		SemPredEvaluated;
+		event SyntacticPredicateEventHandler	SynPredStarted;
+		event SyntacticPredicateEventHandler	SynPredFailed;
+		event SyntacticPredicateEventHandler	SynPredSucceeded;
+	}
+}


Property changes on: trunk/src/antlr-runtime/antlr.debug/IDebugSubject.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/IParserDebugSubject.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/IParserDebugSubject.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/IParserDebugSubject.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,14 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface IParserDebugSubject : IDebugSubject
+	{
+		event MatchEventHandler					MatchedToken;
+		event MatchEventHandler					MatchedNotToken;
+		event MatchEventHandler					MisMatchedToken;
+		event MatchEventHandler					MisMatchedNotToken;
+		event TokenEventHandler					ConsumedToken;
+		event TokenEventHandler					TokenLA;
+	}
+}


Property changes on: trunk/src/antlr-runtime/antlr.debug/IParserDebugSubject.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/InputBufferEventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/InputBufferEventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/InputBufferEventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,50 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class InputBufferEventArgs : ANTLREventArgs
+	{
+		public InputBufferEventArgs()
+		{
+		}
+
+		public InputBufferEventArgs(int type, char c, int lookaheadAmount)
+		{
+			setValues(type, c, lookaheadAmount);
+		}
+	
+		public virtual char Char
+		{
+			get	{ return this.c_;	}
+			set	{ this.c_ = value;	}
+		}
+		public virtual int LookaheadAmount
+		{
+			get	{ return this.lookaheadAmount_;		}
+			set	{ this.lookaheadAmount_ = value;	}
+		}
+
+		internal char c_;
+		internal int lookaheadAmount_; // amount of lookahead
+
+		public const int CONSUME = 0;
+		public const int LA = 1;
+		public const int MARK = 2;
+		public const int REWIND = 3;
+		
+		
+		/// &lt;summary&gt;This should NOT be called from anyone other than ParserEventSupport! 
+		/// &lt;/summary&gt;
+		internal void  setValues(int type, char c, int la)
+		{
+			setValues(type);
+			this.Char	= c;
+			this.LookaheadAmount = la;
+		}
+
+		public override string ToString()
+		{
+			return &quot;CharBufferEvent [&quot; + (Type == CONSUME?&quot;CONSUME, &quot;:&quot;LA, &quot;) + Char + &quot;,&quot; + LookaheadAmount + &quot;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/InputBufferEventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/InputBufferEventSupport.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/InputBufferEventSupport.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/InputBufferEventSupport.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,124 @@
+namespace antlr.debug
+{
+	using System;
+	using ArrayList	= System.Collections.ArrayList;
+
+	public class InputBufferEventSupport
+	{
+		public virtual ArrayList InputBufferListeners
+		{
+			get
+			{
+				return inputBufferListeners;
+			}
+			
+		}
+		private object source;
+		private ArrayList inputBufferListeners;
+		private InputBufferEventArgs inputBufferEvent;
+		protected internal const int CONSUME = 0;
+		protected internal const int LA = 1;
+		protected internal const int MARK = 2;
+		protected internal const int REWIND = 3;
+		
+		
+		public InputBufferEventSupport(object source)
+		{
+			inputBufferEvent = new InputBufferEventArgs();
+			this.source = source;
+		}
+		public virtual void  addInputBufferListener(InputBufferListener l)
+		{
+			if (inputBufferListeners == null)
+				inputBufferListeners = new ArrayList();
+			inputBufferListeners.Add(l);
+		}
+		public virtual void  fireConsume(char c)
+		{
+			inputBufferEvent.setValues(InputBufferEventArgs.CONSUME, c, 0);
+			fireEvents(CONSUME, inputBufferListeners);
+		}
+		public virtual void  fireEvent(int type, Listener l)
+		{
+			switch (type)
+			{
+				case CONSUME: 
+					((InputBufferListener) l).inputBufferConsume(source, inputBufferEvent); break;
+				
+				case LA: 
+					((InputBufferListener) l).inputBufferLA(source, inputBufferEvent); break;
+				
+				case MARK: 
+					((InputBufferListener) l).inputBufferMark(source, inputBufferEvent); break;
+				
+				case REWIND: 
+					((InputBufferListener) l).inputBufferRewind(source, inputBufferEvent); break;
+				
+				default: 
+					throw new System.ArgumentException(&quot;bad type &quot; + type + &quot; for fireEvent()&quot;);
+				
+			}
+		}
+		public virtual void  fireEvents(int type, ArrayList listeners)
+		{
+			ArrayList targets = null;
+			Listener l = null;
+			
+			lock(this)
+			{
+				if (listeners == null)
+					return ;
+				targets = (ArrayList) listeners.Clone();
+			}
+			
+			if (targets != null)
+				 for (int i = 0; i &lt; targets.Count; i++)
+				{
+					l = (Listener) targets[i];
+					fireEvent(type, l);
+				}
+		}
+		public virtual void  fireLA(char c, int la)
+		{
+			inputBufferEvent.setValues(InputBufferEventArgs.LA, c, la);
+			fireEvents(LA, inputBufferListeners);
+		}
+		public virtual void  fireMark(int pos)
+		{
+			inputBufferEvent.setValues(InputBufferEventArgs.MARK, ' ', pos);
+			fireEvents(MARK, inputBufferListeners);
+		}
+		public virtual void  fireRewind(int pos)
+		{
+			inputBufferEvent.setValues(InputBufferEventArgs.REWIND, ' ', pos);
+			fireEvents(REWIND, inputBufferListeners);
+		}
+		protected internal virtual void  refresh(ArrayList listeners)
+		{
+			ArrayList v;
+			lock(listeners)
+			{
+				v = (ArrayList) listeners.Clone();
+			}
+			if (v != null)
+				 for (int i = 0; i &lt; v.Count; i++)
+					((Listener) v[i]).refresh();
+		}
+		public virtual void  refreshListeners()
+		{
+			refresh(inputBufferListeners);
+		}
+		public virtual void  removeInputBufferListener(InputBufferListener l)
+		{
+			if (inputBufferListeners != null)
+			{
+				ArrayList temp_arraylist;
+				object temp_object;
+				temp_arraylist = inputBufferListeners;
+				temp_object = l;
+				temp_arraylist.Contains(temp_object);
+				temp_arraylist.Remove(temp_object);
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/InputBufferEventSupport.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/InputBufferListener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/InputBufferListener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/InputBufferListener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,12 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface InputBufferListener : Listener
+	{
+		void  inputBufferConsume	(object source, InputBufferEventArgs e);
+		void  inputBufferLA			(object source, InputBufferEventArgs e);
+		void  inputBufferMark		(object source, InputBufferEventArgs e);
+		void  inputBufferRewind		(object source, InputBufferEventArgs e);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/InputBufferListener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/InputBufferListenerBase.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/InputBufferListenerBase.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/InputBufferListenerBase.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,65 @@
+namespace antlr.debug
+{
+	using System;
+	
+	/// &lt;summary&gt;
+	/// Provides an abstract base for implementing &lt;see cref=&quot;InputBufferListener&quot;/&gt; subclasses.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	///		&lt;param&gt;
+	///		This abstract class is provided to make it easier to create &lt;see cref=&quot;InputBufferListener&quot;/&gt;s. 
+	///		You should extend this base class rather than creating your own.
+	///		&lt;/param&gt;
+	/// &lt;/remarks&gt;
+	public abstract class InputBufferListenerBase : InputBufferListener
+	{
+		/// &lt;summary&gt;
+		/// Handle the &quot;Done&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  doneParsing(object source, TraceEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;CharConsumed&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  inputBufferConsume(object source, InputBufferEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;CharLA&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  inputBufferLA(object source, InputBufferEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;Mark&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  inputBufferMark(object source, InputBufferEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;Rewind&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  inputBufferRewind(object source, InputBufferEventArgs e)
+		{
+		}
+
+		public virtual void  refresh()
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/InputBufferListenerBase.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/InputBufferReporter.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/InputBufferReporter.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/InputBufferReporter.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,36 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class InputBufferReporter : InputBufferListenerBase, InputBufferListener
+	{
+		public virtual void inputBufferChanged(object source, InputBufferEventArgs e)
+		{
+			System.Console.Out.WriteLine(e);
+		}
+
+		/// &lt;summary&gt; charBufferConsume method comment.
+		/// &lt;/summary&gt;
+		public override void  inputBufferConsume(object source, InputBufferEventArgs e)
+		{
+			System.Console.Out.WriteLine(e);
+		}
+
+		/// &lt;summary&gt; charBufferLA method comment.
+		/// &lt;/summary&gt;
+		public override void  inputBufferLA(object source, InputBufferEventArgs e)
+		{
+			System.Console.Out.WriteLine(e);
+		}
+
+		public override void  inputBufferMark(object source, InputBufferEventArgs e)
+		{
+			System.Console.Out.WriteLine(e);
+		}
+
+		public override void  inputBufferRewind(object source, InputBufferEventArgs e)
+		{
+			System.Console.Out.WriteLine(e);
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/InputBufferReporter.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/LLkDebuggingParser.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/LLkDebuggingParser.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/LLkDebuggingParser.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,299 @@
+namespace antlr.debug
+{
+	using System;
+	using System.Threading;
+	using antlr.collections.impl;
+	
+	public class LLkDebuggingParser : LLkParser, DebuggingParser
+	{
+		private void  InitBlock()
+		{
+			parserEventSupport = new ParserEventSupport(this);
+		}
+		public override void setDebugMode(bool mode)
+		{
+			_notDebugMode = !mode;
+		}
+		protected internal ParserEventSupport parserEventSupport;
+		
+		private bool _notDebugMode = false;
+		protected internal string[] ruleNames;
+		protected internal string[] semPredNames;
+		
+		
+		public LLkDebuggingParser(int k_):base(k_)
+		{
+			InitBlock();
+		}
+		public LLkDebuggingParser(ParserSharedInputState state, int k_):base(state, k_)
+		{
+			InitBlock();
+		}
+		public LLkDebuggingParser(TokenBuffer tokenBuf, int k_):base(tokenBuf, k_)
+		{
+			InitBlock();
+		}
+		public LLkDebuggingParser(TokenStream lexer, int k_):base(lexer, k_)
+		{
+			InitBlock();
+		}
+		public override void  addMessageListener(MessageListener l)
+		{
+			parserEventSupport.addMessageListener(l);
+		}
+		public override void  addParserListener(ParserListener l)
+		{
+			parserEventSupport.addParserListener(l);
+		}
+		public override void  addParserMatchListener(ParserMatchListener l)
+		{
+			parserEventSupport.addParserMatchListener(l);
+		}
+		public override void  addParserTokenListener(ParserTokenListener l)
+		{
+			parserEventSupport.addParserTokenListener(l);
+		}
+		public override void  addSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			parserEventSupport.addSemanticPredicateListener(l);
+		}
+		public override void  addSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			parserEventSupport.addSyntacticPredicateListener(l);
+		}
+		public override void  addTraceListener(TraceListener l)
+		{
+			parserEventSupport.addTraceListener(l);
+		}
+		/// &lt;summary&gt;Get another token object from the token stream 
+		/// &lt;/summary&gt;
+		public override void  consume()
+		{
+			int la_1 = - 99;
+			la_1 = LA(1);
+			base.consume();
+			parserEventSupport.fireConsume(la_1);
+		}
+		protected internal virtual void  fireEnterRule(int num, int data)
+		{
+			if (isDebugMode())
+				parserEventSupport.fireEnterRule(num, inputState.guessing, data);
+		}
+		protected internal virtual void  fireExitRule(int num, int data)
+		{
+			if (isDebugMode())
+				parserEventSupport.fireExitRule(num, inputState.guessing, data);
+		}
+		protected internal virtual bool fireSemanticPredicateEvaluated(int type, int num, bool condition)
+		{
+			if (isDebugMode())
+				return parserEventSupport.fireSemanticPredicateEvaluated(type, num, condition, inputState.guessing);
+			else
+				return condition;
+		}
+		protected internal virtual void  fireSyntacticPredicateFailed()
+		{
+			if (isDebugMode())
+				parserEventSupport.fireSyntacticPredicateFailed(inputState.guessing);
+		}
+		protected internal virtual void  fireSyntacticPredicateStarted()
+		{
+			if (isDebugMode())
+				parserEventSupport.fireSyntacticPredicateStarted(inputState.guessing);
+		}
+		protected internal virtual void  fireSyntacticPredicateSucceeded()
+		{
+			if (isDebugMode())
+				parserEventSupport.fireSyntacticPredicateSucceeded(inputState.guessing);
+		}
+		public virtual string getRuleName(int num)
+		{
+			return ruleNames[num];
+		}
+		public virtual string getSemPredName(int num)
+		{
+			return semPredNames[num];
+		}
+
+		public virtual void  goToSleep()
+		{
+			lock(this)
+			{
+				try
+				{
+					Monitor.Wait(this);
+				}
+				catch (System.Threading.ThreadInterruptedException)
+				{
+				}
+			}
+		}
+		public override bool isDebugMode()
+		{
+			return !_notDebugMode;
+		}
+		public virtual bool isGuessing()
+		{
+			return inputState.guessing &gt; 0;
+		}
+		/// &lt;summary&gt;Return the token type of the ith token of lookahead where i=1
+		/// is the current token being examined by the parser (i.e., it
+		/// has not been matched yet).
+		/// &lt;/summary&gt;
+		public override int LA(int i)
+		{
+			int la = base.LA(i);
+			parserEventSupport.fireLA(i, la);
+			return la;
+		}
+		/// &lt;summary&gt;Make sure current lookahead symbol matches token type &lt;tt&gt;t&lt;/tt&gt;.
+		/// Throw an exception upon mismatch, which is catch by either the
+		/// error handler or by the syntactic predicate.
+		/// &lt;/summary&gt;
+		public override void  match(int t)
+		{
+			string text = LT(1).getText();
+			int la_1 = LA(1);
+			try
+			{
+				base.match(t);
+				parserEventSupport.fireMatch(t, text, inputState.guessing);
+			}
+			catch (MismatchedTokenException e)
+			{
+				if (inputState.guessing == 0)
+					parserEventSupport.fireMismatch(la_1, t, text, inputState.guessing);
+				throw e;
+			}
+		}
+		/// &lt;summary&gt;Make sure current lookahead symbol matches the given set
+		/// Throw an exception upon mismatch, which is catch by either the
+		/// error handler or by the syntactic predicate.
+		/// &lt;/summary&gt;
+		public override void  match(BitSet b)
+		{
+			string text = LT(1).getText();
+			int la_1 = LA(1);
+			try
+			{
+				base.match(b);
+				parserEventSupport.fireMatch(la_1, b, text, inputState.guessing);
+			}
+			catch (MismatchedTokenException e)
+			{
+				if (inputState.guessing == 0)
+					parserEventSupport.fireMismatch(la_1, b, text, inputState.guessing);
+				throw e;
+			}
+		}
+		public override void  matchNot(int t)
+		{
+			string text = LT(1).getText();
+			int la_1 = LA(1);
+			try
+			{
+				base.matchNot(t);
+				parserEventSupport.fireMatchNot(la_1, t, text, inputState.guessing);
+			}
+			catch (MismatchedTokenException e)
+			{
+				if (inputState.guessing == 0)
+					parserEventSupport.fireMismatchNot(la_1, t, text, inputState.guessing);
+				throw e;
+			}
+		}
+		public override void  removeMessageListener(MessageListener l)
+		{
+			parserEventSupport.removeMessageListener(l);
+		}
+		public override void  removeParserListener(ParserListener l)
+		{
+			parserEventSupport.removeParserListener(l);
+		}
+		public override void  removeParserMatchListener(ParserMatchListener l)
+		{
+			parserEventSupport.removeParserMatchListener(l);
+		}
+		public override void  removeParserTokenListener(ParserTokenListener l)
+		{
+			parserEventSupport.removeParserTokenListener(l);
+		}
+		public override void  removeSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			parserEventSupport.removeSemanticPredicateListener(l);
+		}
+		public override void  removeSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			parserEventSupport.removeSyntacticPredicateListener(l);
+		}
+		public override void  removeTraceListener(TraceListener l)
+		{
+			parserEventSupport.removeTraceListener(l);
+		}
+		/// &lt;summary&gt;Parser error-reporting function can be overridden in subclass 
+		/// &lt;/summary&gt;
+		public override void  reportError(RecognitionException ex)
+		{
+			parserEventSupport.fireReportError(ex);
+			base.reportError(ex);
+		}
+		/// &lt;summary&gt;Parser error-reporting function can be overridden in subclass 
+		/// &lt;/summary&gt;
+		public override void  reportError(string s)
+		{
+			parserEventSupport.fireReportError(s);
+			base.reportError(s);
+		}
+		/// &lt;summary&gt;Parser warning-reporting function can be overridden in subclass 
+		/// &lt;/summary&gt;
+		public override void  reportWarning(string s)
+		{
+			parserEventSupport.fireReportWarning(s);
+			base.reportWarning(s);
+		}
+		public virtual void  setupDebugging(TokenBuffer tokenBuf)
+		{
+			setupDebugging(null, tokenBuf);
+		}
+		public virtual void  setupDebugging(TokenStream lexer)
+		{
+			setupDebugging(lexer, null);
+		}
+		/// &lt;summary&gt;User can override to do their own debugging 
+		/// &lt;/summary&gt;
+		protected internal virtual void  setupDebugging(TokenStream lexer, TokenBuffer tokenBuf)
+		{
+			setDebugMode(true);
+			// default parser debug setup is ParseView
+			try
+			{
+//				try
+//				{
+//					System.Type.GetType(&quot;javax.swing.JButton&quot;);
+//				}
+//				catch (System.Exception)
+//				{
+//					System.Console.Error.WriteLine(&quot;Swing is required to use ParseView, but is not present in your CLASSPATH&quot;);
+//					System.Environment.Exit(1);
+//				}
+				System.Type c = System.Type.GetType(&quot;antlr.parseview.ParseView&quot;);
+				System.Reflection.ConstructorInfo constructor = c.GetConstructor(new System.Type[]{typeof(LLkDebuggingParser), typeof(TokenStream), typeof(TokenBuffer)});
+				constructor.Invoke(new object[]{this, lexer, tokenBuf});
+			}
+			catch (System.Exception e)
+			{
+				System.Console.Error.WriteLine(&quot;Error initializing ParseView: &quot; + e);
+				System.Console.Error.WriteLine(&quot;Please report this to Scott Stanchfield, <A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">thetick at magelang.com</A>&quot;);
+				System.Environment.Exit(1);
+			}
+		}
+
+		public virtual void  wakeUp()
+		{
+			lock(this)
+			{
+				Monitor.Pulse(this);
+			}
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/LLkDebuggingParser.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/Listener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/Listener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/Listener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,11 @@
+namespace antlr.debug
+{
+	using System;
+	
+
+	public interface Listener
+	{
+		void  doneParsing	(object source, TraceEventArgs e);
+		void  refresh		();
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/Listener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/MessageEventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/MessageEventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/MessageEventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,41 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class MessageEventArgs : ANTLREventArgs
+	{
+		public MessageEventArgs()
+		{
+		}
+		public MessageEventArgs(int type, string text)
+		{
+			setValues(type, text);
+		}
+
+		public virtual string Text
+		{
+			get	{ return text_;			}
+			set	{ this.text_ = value;	}
+			
+		}
+
+		private string text_;
+
+		public static int WARNING = 0;
+		public static int ERROR = 1;
+		
+		
+		/// &lt;summary&gt;This should NOT be called from anyone other than ParserEventSupport! 
+		/// &lt;/summary&gt;
+		internal void  setValues(int type, string text)
+		{
+			setValues(type);
+			this.Text   = text;
+		}
+
+		public override string ToString()
+		{
+			return &quot;ParserMessageEvent [&quot; + (Type == WARNING?&quot;warning,&quot;:&quot;error,&quot;) + Text + &quot;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/MessageEventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/MessageListener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/MessageListener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/MessageListener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,10 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface MessageListener : Listener
+	{
+		void  reportError	(object source, MessageEventArgs e);
+		void  reportWarning	(object source, MessageEventArgs e);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/MessageListener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/MessageListenerBase.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/MessageListenerBase.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/MessageListenerBase.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,47 @@
+namespace antlr.debug
+{
+	using System;
+	
+	/// &lt;summary&gt;
+	/// Provides an abstract base for implementing &lt;see cref=&quot;MessageListener&quot;/&gt; subclasses.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	///		&lt;param&gt;
+	///		This abstract class is provided to make it easier to create &lt;see cref=&quot;MessageListener&quot;/&gt;s. 
+	///		You should extend this base class rather than creating your own.
+	///		&lt;/param&gt;
+	/// &lt;/remarks&gt;
+	public class MessageListenerBase : MessageListener
+	{
+		/// &lt;summary&gt;
+		/// Handle the &quot;Done&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  doneParsing(object source, TraceEventArgs e)
+		{
+		}
+
+		public virtual void  refresh()
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;ReportError&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  reportError(object source, MessageEventArgs e)
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;ReportWarning&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  reportWarning(object source, MessageEventArgs e)
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/MessageListenerBase.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/NewLineEventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/NewLineEventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/NewLineEventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,31 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class NewLineEventArgs : ANTLREventArgs
+	{
+		public NewLineEventArgs()
+		{
+		}
+		public NewLineEventArgs(int line)
+		{
+			Line = line;
+		}
+
+		public virtual int Line
+		{
+			get	{ return this.line_; }
+			set	{ this.line_ = value; }
+		}
+
+		private int line_;
+		
+		
+		/// &lt;summary&gt;This should NOT be called from anyone other than ParserEventSupport! 
+		/// &lt;/summary&gt;
+		public override string ToString()
+		{
+			return &quot;NewLineEvent [&quot; + line_ + &quot;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/NewLineEventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/NewLineListener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/NewLineListener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/NewLineListener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,9 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface NewLineListener : Listener
+	{
+		void hitNewLine(object source, NewLineEventArgs e);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/NewLineListener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParseTreeDebugParser.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParseTreeDebugParser.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParseTreeDebugParser.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,162 @@
+namespace antlr.debug
+{
+
+	/* ANTLR Translator Generator
+	 * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+	 * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+	 */
+
+	//
+	// ANTLR C# Code Generator by Micheal Jordan
+	//                            Kunle Odutola       : kunle UNDERSCORE odutola AT hotmail DOT com
+	//                            Anthony Oguntimehin
+	//
+
+	using System;
+	using Stack = System.Collections.Stack;
+	using antlr;
+	using BitSet = antlr.collections.impl.BitSet;
+
+	/// &lt;summary&gt;
+	/// Specifies the behaviour required (i.e. parser modifications) 
+	/// specifically to support parse tree debugging and derivation.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	/// &lt;para&gt;
+	/// Override the standard matching and rule entry/exit routines
+	/// to build parse trees.  This class is useful for 2.7.3 where
+	/// you can specify a superclass like
+	/// &lt;/para&gt;
+	/// &lt;para&gt;
+	/// class TinyCParser extends Parser(ParseTreeDebugParser);
+	/// &lt;/para&gt;
+	/// &lt;/remarks&gt;
+	public class ParseTreeDebugParser : LLkParser 
+	{
+		/// &lt;summary&gt;
+		/// Each new rule invocation must have it's own subtree. Tokens are
+		/// added to the current root so we must have a stack of subtree roots.
+		/// &lt;/summary&gt;
+		protected Stack currentParseTreeRoot = new Stack();
+
+		/// &lt;summary&gt;
+		/// Track most recently created parse subtree so that when parsing
+		/// is finished, we can get to the root.
+		/// &lt;/summary&gt;
+		protected ParseTreeRule mostRecentParseTreeRoot = null;
+
+		/// &lt;summary&gt;
+		/// For every rule replacement with a production, we bump up count.
+		/// &lt;/summary&gt;
+		protected int numberOfDerivationSteps = 1; // n replacements plus step 0
+
+		public ParseTreeDebugParser(int k_) : base(k_)
+		{
+		}
+
+		public ParseTreeDebugParser(ParserSharedInputState state, int k_) : base(state, k_)
+		{
+		}
+
+		public ParseTreeDebugParser(TokenBuffer tokenBuf, int k_) : base(tokenBuf, k_)
+		{
+		}
+
+		public ParseTreeDebugParser(TokenStream lexer, int k_) : base(lexer,k_)
+		{
+		}
+
+		public ParseTree getParseTree() 
+		{
+			return mostRecentParseTreeRoot;
+		}
+
+		public int getNumberOfDerivationSteps() 
+		{
+			return numberOfDerivationSteps;
+		}
+
+		public override void match(int i) 			// throws MismatchedTokenException, TokenStreamException 
+		{
+			addCurrentTokenToParseTree();
+			base.match(i);
+		}
+
+		public override void match(BitSet bitSet) 	// throws MismatchedTokenException, TokenStreamException 
+		{
+			addCurrentTokenToParseTree();
+			base.match(bitSet);
+		}
+
+		public override void matchNot(int i) 		// throws MismatchedTokenException, TokenStreamException
+		{
+			addCurrentTokenToParseTree();
+			base.matchNot(i);
+		}
+
+		/// &lt;summary&gt;
+		/// Adds LT(1) to the current parse subtree.
+		/// &lt;/summary&gt;
+		/// &lt;remarks&gt;
+		/// &lt;para&gt;
+		/// Note that the match() routines add the node before checking for 
+		/// correct match.  This means that, upon mismatched token, there 
+		/// will a token node in the tree corresponding to where that token 
+		/// was expected.  For no viable alternative errors, no node will 
+		/// be in the tree as nothing was matched() (the lookahead failed 
+		/// to predict an alternative).
+		/// &lt;/para&gt;
+		/// &lt;/remarks&gt;
+		protected void addCurrentTokenToParseTree() 		// throws TokenStreamException 
+		{
+			if (inputState.guessing &gt; 0) 
+			{
+				return;
+			}
+			ParseTreeRule root = (ParseTreeRule) currentParseTreeRoot.Peek();
+			ParseTreeToken tokenNode = null;
+			if ( LA(1) == Token.EOF_TYPE ) 
+			{
+				tokenNode = new ParseTreeToken(new antlr.CommonToken(&quot;EOF&quot;));
+			}
+			else 
+			{
+				tokenNode = new ParseTreeToken(LT(1));
+			}
+			root.addChild(tokenNode);
+		}
+
+		/// &lt;summary&gt;
+		/// Create a rule node, add to current tree, and make it current root
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt;
+		public override void traceIn(string s) 				// throws TokenStreamException 
+		{
+			if (inputState.guessing &gt; 0) 
+			{
+				return;
+			}
+			ParseTreeRule subRoot = new ParseTreeRule(s);
+			if ( currentParseTreeRoot.Count &gt; 0 ) 
+			{
+				ParseTreeRule oldRoot = (ParseTreeRule) currentParseTreeRoot.Peek();
+				oldRoot.addChild(subRoot);
+			}
+			currentParseTreeRoot.Push(subRoot);
+			numberOfDerivationSteps++;
+		}
+
+		/// &lt;summary&gt;
+		/// Pop current root; back to adding to old root
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt;
+		public override void traceOut(string s) 				// throws TokenStreamException
+		{
+			if (inputState.guessing &gt; 0) 
+			{
+				return;
+			}
+			mostRecentParseTreeRoot = (ParseTreeRule) currentParseTreeRoot.Pop();
+		}
+	}
+}

Added: trunk/src/antlr-runtime/antlr.debug/ParserController.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserController.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserController.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,14 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface ParserController : ParserListener
+		{
+			ParserEventSupport ParserEventSupport
+			{
+				set;
+			}
+
+			void  checkBreak();
+		}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserController.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserEventSupport.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserEventSupport.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserEventSupport.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,490 @@
+namespace antlr.debug
+{
+	using System;
+	using System.Reflection;
+	using Hashtable			= System.Collections.Hashtable;
+	using DictionaryEntry	= System.Collections.DictionaryEntry;
+	using ArrayList			= System.Collections.ArrayList;
+
+	using antlr.collections.impl;
+	
+	
+	public delegate void MessageEventHandler(object sender, MessageEventArgs e); 
+	public delegate void NewLineEventHandler(object sender, NewLineEventArgs e); 
+	public delegate void MatchEventHandler(object sender, MatchEventArgs e); 
+	public delegate void TokenEventHandler(object sender, TokenEventArgs e); 
+	public delegate void SemanticPredicateEventHandler(object sender, SemanticPredicateEventArgs e); 
+	public delegate void SyntacticPredicateEventHandler(object sender, SyntacticPredicateEventArgs e); 
+	public delegate void TraceEventHandler(object sender, TraceEventArgs e); 
+
+	/// &lt;summary&gt;A class to assist in firing parser events
+	/// NOTE: I intentionally _did_not_ synchronize the event firing and
+	/// add/remove listener methods.  This is because the add/remove should
+	/// _only_ be called by the parser at its start/end, and the _same_thread_
+	/// should be performing the parsing.  This should help performance a tad...
+	/// &lt;/summary&gt;
+	public class ParserEventSupport
+	{
+		private object source;
+		private Hashtable listeners;
+
+		private MatchEventArgs matchEvent;
+		private MessageEventArgs messageEvent;
+		private TokenEventArgs tokenEvent;
+		private SemanticPredicateEventArgs semPredEvent;
+		private SyntacticPredicateEventArgs synPredEvent;
+		private TraceEventArgs traceEvent;
+		private NewLineEventArgs newLineEvent;
+
+		private ParserController controller;
+
+		private int ruleDepth = 0;
+		
+		
+		public ParserEventSupport(object source)
+		{
+			matchEvent		= new MatchEventArgs();
+			messageEvent	= new MessageEventArgs();
+			tokenEvent		= new TokenEventArgs();
+			traceEvent		= new TraceEventArgs();
+			semPredEvent	= new SemanticPredicateEventArgs();
+			synPredEvent	= new SyntacticPredicateEventArgs();
+			newLineEvent	= new NewLineEventArgs();
+			listeners		= new Hashtable();
+			this.source		= source;
+		}
+
+		public virtual void checkController()
+		{
+			if (controller != null)
+				controller.checkBreak();
+		}
+
+		public virtual void  addDoneListener(Listener l)
+		{
+			((Parser)source).Done += new TraceEventHandler(l.doneParsing);
+			listeners[l] = l;
+		}
+		public virtual void  addMessageListener(MessageListener l)
+		{
+			((Parser)source).ErrorReported   += new MessageEventHandler(l.reportError);
+			((Parser)source).WarningReported += new MessageEventHandler(l.reportWarning);
+			//messageListeners.Add(l);
+			addDoneListener(l);
+		}
+		public virtual void  addParserListener(ParserListener l)
+		{
+			if (l is ParserController)
+			{
+				((ParserController) l).ParserEventSupport = this;
+				controller = (ParserController) l;
+			}
+			addParserMatchListener(l);
+			addParserTokenListener(l);
+			
+			addMessageListener(l);
+			addTraceListener(l);
+			addSemanticPredicateListener(l);
+			addSyntacticPredicateListener(l);
+		}
+		public virtual void  addParserMatchListener(ParserMatchListener l)
+		{
+			((Parser)source).MatchedToken		+= new MatchEventHandler(l.parserMatch);
+			((Parser)source).MatchedNotToken	+= new MatchEventHandler(l.parserMatchNot);
+			((Parser)source).MisMatchedToken	+= new MatchEventHandler(l.parserMismatch);
+			((Parser)source).MisMatchedNotToken	+= new MatchEventHandler(l.parserMismatchNot);
+			//matchListeners.Add(l);
+			addDoneListener(l);
+		}
+		public virtual void  addParserTokenListener(ParserTokenListener l)
+		{
+			((Parser)source).ConsumedToken	+= new TokenEventHandler(l.parserConsume);
+			((Parser)source).TokenLA		+= new TokenEventHandler(l.parserLA);
+			//tokenListeners.Add(l);
+			addDoneListener(l);
+		}
+		public virtual void  addSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			((Parser)source).SemPredEvaluated	+= new SemanticPredicateEventHandler(l.semanticPredicateEvaluated);
+			//semPredListeners.Add(l);
+			addDoneListener(l);
+		}
+		public virtual void  addSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			((Parser)source).SynPredStarted		+= new SyntacticPredicateEventHandler(l.syntacticPredicateStarted);
+			((Parser)source).SynPredFailed		+= new SyntacticPredicateEventHandler(l.syntacticPredicateFailed);
+			((Parser)source).SynPredSucceeded	+= new SyntacticPredicateEventHandler(l.syntacticPredicateSucceeded);
+			//synPredListeners.Add(l);
+			addDoneListener(l);
+		}
+		public virtual void  addTraceListener(TraceListener l)
+		{
+			((Parser)source).EnterRule	+= new TraceEventHandler(l.enterRule);
+			((Parser)source).ExitRule	+= new TraceEventHandler(l.exitRule);
+			//traceListeners.Add(l);
+			addDoneListener(l);
+		}
+		public virtual void  fireConsume(int c)
+		{
+			TokenEventHandler eventDelegate = (TokenEventHandler)((Parser)source).Events[Parser.LAEventKey];
+			if (eventDelegate != null) 
+			{
+				tokenEvent.setValues(TokenEventArgs.CONSUME, 1, c);
+				eventDelegate(source, tokenEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireDoneParsing()
+		{
+			TraceEventHandler eventDelegate = (TraceEventHandler)((Parser)source).Events[Parser.DoneEventKey];
+			if (eventDelegate != null) 
+			{
+				traceEvent.setValues(TraceEventArgs.DONE_PARSING, 0, 0, 0);
+				eventDelegate(source, traceEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireEnterRule(int ruleNum, int guessing, int data)
+		{
+			ruleDepth++;
+			TraceEventHandler eventDelegate = (TraceEventHandler)((Parser)source).Events[Parser.EnterRuleEventKey];
+			if (eventDelegate != null) 
+			{
+				traceEvent.setValues(TraceEventArgs.ENTER, ruleNum, guessing, data);
+				eventDelegate(source, traceEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireExitRule(int ruleNum, int guessing, int data)
+		{
+			TraceEventHandler eventDelegate = (TraceEventHandler)((Parser)source).Events[Parser.ExitRuleEventKey];
+			if (eventDelegate != null) 
+			{
+				traceEvent.setValues(TraceEventArgs.EXIT, ruleNum, guessing, data);
+				eventDelegate(source, traceEvent);
+			} 
+			checkController();
+
+			ruleDepth--;
+			if (ruleDepth == 0)
+				fireDoneParsing();
+
+		}
+		public virtual void  fireLA(int k, int la)
+		{
+			TokenEventHandler eventDelegate = (TokenEventHandler)((Parser)source).Events[Parser.LAEventKey];
+			if (eventDelegate != null) 
+			{
+				tokenEvent.setValues(TokenEventArgs.LA, k, la);
+				eventDelegate(source, tokenEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(char c, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR, c, c, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(char c, BitSet b, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR_BITSET, c, b, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(char c, string target, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR_RANGE, c, target, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(int c, BitSet b, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.BITSET, c, b, text, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(int n, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.TOKEN, n, n, text, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(string s, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.STRING, 0, s, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatchNot(char c, char n, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MatchNotEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR, c, n, null, guessing, true, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatchNot(int c, int n, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MatchNotEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.TOKEN, c, n, text, guessing, true, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(char c, char n, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR, c, n, null, guessing, false, false);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(char c, BitSet b, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR_BITSET, c, b, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(char c, string target, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR_RANGE, c, target, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(int i, int n, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.TOKEN, i, n, text, guessing, false, false);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(int i, BitSet b, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.BITSET, i, b, text, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(string s, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.STRING, 0, text, s, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatchNot(char v, char c, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MisMatchNotEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR, v, c, null, guessing, true, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatchNot(int i, int n, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((Parser)source).Events[Parser.MisMatchNotEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.TOKEN, i, n, text, guessing, true, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireReportError(System.Exception e)
+		{
+			MessageEventHandler eventDelegate = (MessageEventHandler)((Parser)source).Events[Parser.ReportErrorEventKey];
+			if (eventDelegate != null) 
+			{
+				messageEvent.setValues(MessageEventArgs.ERROR, e.ToString());
+				eventDelegate(source, messageEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireReportError(string s)
+		{
+			MessageEventHandler eventDelegate = (MessageEventHandler)((Parser)source).Events[Parser.ReportErrorEventKey];
+			if (eventDelegate != null) 
+			{
+				messageEvent.setValues(MessageEventArgs.ERROR, s);
+				eventDelegate(source, messageEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireReportWarning(string s)
+		{
+			MessageEventHandler eventDelegate = (MessageEventHandler)((Parser)source).Events[Parser.ReportWarningEventKey];
+			if (eventDelegate != null) 
+			{
+				messageEvent.setValues(MessageEventArgs.WARNING, s);
+				eventDelegate(source, messageEvent);
+			}
+			checkController();
+		}
+		public virtual bool fireSemanticPredicateEvaluated(int type, int condition, bool result, int guessing)
+		{
+			SemanticPredicateEventHandler eventDelegate = (SemanticPredicateEventHandler)((Parser)source).Events[Parser.SemPredEvaluatedEventKey];
+			if (eventDelegate != null) 
+			{
+				semPredEvent.setValues(type, condition, result, guessing);
+				eventDelegate(source, semPredEvent);
+			}
+			checkController();
+
+			return result;
+		}
+		public virtual void  fireSyntacticPredicateFailed(int guessing)
+		{
+			SyntacticPredicateEventHandler eventDelegate = (SyntacticPredicateEventHandler)((Parser)source).Events[Parser.SynPredFailedEventKey];
+			if (eventDelegate != null) 
+			{
+				synPredEvent.setValues(0, guessing);
+				eventDelegate(source, synPredEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireSyntacticPredicateStarted(int guessing)
+		{
+			SyntacticPredicateEventHandler eventDelegate = (SyntacticPredicateEventHandler)((Parser)source).Events[Parser.SynPredStartedEventKey];
+			if (eventDelegate != null) 
+			{
+				synPredEvent.setValues(0, guessing);
+				eventDelegate(source, synPredEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireSyntacticPredicateSucceeded(int guessing)
+		{
+			SyntacticPredicateEventHandler eventDelegate = (SyntacticPredicateEventHandler)((Parser)source).Events[Parser.SynPredSucceededEventKey];
+			if (eventDelegate != null) 
+			{
+				synPredEvent.setValues(0, guessing);
+				eventDelegate(source, synPredEvent);
+			}
+			checkController();
+		}
+		public virtual void  refreshListeners()
+		{
+			Hashtable clonedTable;
+
+			lock(listeners.SyncRoot)
+			{
+				clonedTable = (Hashtable)listeners.Clone();
+			}
+			foreach (DictionaryEntry entry in clonedTable)
+			{
+				if (entry.Value != null)
+				{
+					((Listener) entry.Value).refresh();
+				}
+			}
+		}
+		public virtual void  removeDoneListener(Listener l)
+		{
+			((Parser)source).Done -= new TraceEventHandler(l.doneParsing);
+			listeners.Remove(l);
+		}
+		public virtual void  removeMessageListener(MessageListener l)
+		{
+			((Parser)source).ErrorReported   -= new MessageEventHandler(l.reportError);
+			((Parser)source).WarningReported -= new MessageEventHandler(l.reportWarning);
+			//messageListeners.Remove(l);
+			removeDoneListener(l);
+		}
+		public virtual void  removeParserListener(ParserListener l)
+		{
+			removeParserMatchListener(l);
+			removeMessageListener(l);
+			removeParserTokenListener(l);
+			removeTraceListener(l);
+			removeSemanticPredicateListener(l);
+			removeSyntacticPredicateListener(l);
+		}
+		public virtual void  removeParserMatchListener(ParserMatchListener l)
+		{
+			((Parser)source).MatchedToken		-= new MatchEventHandler(l.parserMatch);
+			((Parser)source).MatchedNotToken	-= new MatchEventHandler(l.parserMatchNot);
+			((Parser)source).MisMatchedToken	-= new MatchEventHandler(l.parserMismatch);
+			((Parser)source).MisMatchedNotToken	-= new MatchEventHandler(l.parserMismatchNot);
+			//matchListeners.Remove(l);
+			removeDoneListener(l);
+		}
+		public virtual void  removeParserTokenListener(ParserTokenListener l)
+		{
+			((Parser)source).ConsumedToken	-= new TokenEventHandler(l.parserConsume);
+			((Parser)source).TokenLA		-= new TokenEventHandler(l.parserLA);
+			//tokenListeners.Remove(l);
+			removeDoneListener(l);
+		}
+		public virtual void  removeSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			((Parser)source).SemPredEvaluated	-= new SemanticPredicateEventHandler(l.semanticPredicateEvaluated);
+			//semPredListeners.Remove(l);
+			removeDoneListener(l);
+		}
+		public virtual void  removeSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			((Parser)source).SynPredStarted		-= new SyntacticPredicateEventHandler(l.syntacticPredicateStarted);
+			((Parser)source).SynPredFailed		-= new SyntacticPredicateEventHandler(l.syntacticPredicateFailed);
+			((Parser)source).SynPredSucceeded	-= new SyntacticPredicateEventHandler(l.syntacticPredicateSucceeded);
+			//synPredListeners.Remove(l);
+			removeDoneListener(l);
+		}
+		public virtual void  removeTraceListener(TraceListener l)
+		{
+			((Parser)source).EnterRule	-= new TraceEventHandler(l.enterRule);
+			((Parser)source).ExitRule	-= new TraceEventHandler(l.exitRule);
+			//traceListeners.Remove(l);
+			removeDoneListener(l);
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserEventSupport.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserListener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserListener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserListener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,8 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface ParserListener : SemanticPredicateListener, ParserMatchListener, MessageListener, ParserTokenListener, TraceListener, SyntacticPredicateListener
+	{
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserListener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserListenerBase.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserListenerBase.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserListenerBase.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,155 @@
+namespace antlr.debug
+{
+	using System;
+	
+	/// &lt;summary&gt;
+	/// Provides an abstract base for implementing &lt;see cref=&quot;ParserListener&quot;/&gt; subclasses.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	///		&lt;param&gt;
+	///		This abstract class is provided to make it easier to create &lt;see cref=&quot;ParserListener&quot;/&gt;s. 
+	///		You should extend this base class rather than creating your own.
+	///		&lt;/param&gt;
+	/// &lt;/remarks&gt;
+	public class ParserListenerBase : ParserListener
+	{
+		/// &lt;summary&gt;
+		/// Handle the &quot;Done&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  doneParsing(object source, TraceEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;EnterRule&quot; event
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  enterRule(object source, TraceEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;ExitRule&quot; event
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  exitRule(object source, TraceEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;Consume&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserConsume(object source, TokenEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;ParserLA&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserLA(object source, TokenEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;Match&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserMatch(object source, MatchEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;MatchNot&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserMatchNot(object source, MatchEventArgs e)
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;MisMatch&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserMismatch(object source, MatchEventArgs e)
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;MisMatchNot&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserMismatchNot(object source, MatchEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;ReportError&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  reportError(object source, MessageEventArgs e)
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;ReportWarning&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  reportWarning(object source, MessageEventArgs e)
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;SemPreEvaluated&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  semanticPredicateEvaluated(object source, SemanticPredicateEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;SynPredFailed&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  syntacticPredicateFailed(object source, SyntacticPredicateEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;SynPredStarted&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  syntacticPredicateStarted(object source, SyntacticPredicateEventArgs e)
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;SynPredSucceeded&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  syntacticPredicateSucceeded(object source, SyntacticPredicateEventArgs e)
+		{
+		}
+
+		public virtual void  refresh()
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserListenerBase.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserMatchEventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserMatchEventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserMatchEventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,93 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class MatchEventArgs : GuessingEventArgs
+	{
+		public MatchEventArgs()
+		{
+		}
+		public MatchEventArgs(int type, int val, object target, string text, int guessing, bool inverse, bool matched)
+		{
+			setValues(type, val, target, text, guessing, inverse, matched);
+		}
+
+		public virtual object Target
+		{
+			get	{ return this.target_;	}
+			set	{ this.target_ = value;	}
+		}
+
+		public virtual string Text
+		{
+			get	{ return this.text_;	}
+			set	{ this.text_ = value;	}
+		}
+
+		public virtual int Value
+		{
+			get	{ return this.val_;		}
+			set	{ this.val_ = value;	}
+		}
+
+		internal bool Inverse
+		{
+			set	{ this.inverse_ = value;	}
+		}
+
+		internal bool Matched
+		{
+			set	{ this.matched_ = value;	}
+		}
+
+		// NOTE: for a mismatch on type STRING, the &quot;text&quot; is used as the lookahead
+		//       value.  Normally &quot;value&quot; is this
+		public enum ParserMatchEnums
+		{
+			TOKEN		= 0,
+			BITSET		= 1,
+			CHAR		= 2,
+			CHAR_BITSET = 3,
+			STRING		= 4,
+			CHAR_RANGE	= 5,
+		}
+		public static int TOKEN = 0;
+		public static int BITSET = 1;
+		public static int CHAR = 2;
+		public static int CHAR_BITSET = 3;
+		public static int STRING = 4;
+		public static int CHAR_RANGE = 5;
+
+		private bool	inverse_;
+		private bool	matched_;
+		private object	target_;
+		private int		val_;
+		private string	text_;
+		
+		
+		public virtual bool isInverse()
+		{
+			return inverse_;
+		}
+		public virtual bool isMatched()
+		{
+			return matched_;
+		}
+		/// &lt;summary&gt;This should NOT be called from anyone other than ParserEventSupport! 
+		/// &lt;/summary&gt;
+		internal void  setValues(int type, int val, object target, string text, int guessing, bool inverse, bool matched)
+		{
+			base.setValues(type, guessing);
+			this.Value = val;
+			this.Target = target;
+			this.Inverse = inverse;
+			this.Matched = matched;
+			this.Text = text;
+		}
+		
+		public override string ToString()
+		{
+			return &quot;ParserMatchEvent [&quot; + (isMatched()?&quot;ok,&quot;:&quot;bad,&quot;) + (isInverse()?&quot;NOT &quot;:&quot;&quot;) + (Type == TOKEN?&quot;token,&quot;:&quot;bitset,&quot;) + Value + &quot;,&quot; + Target + &quot;,&quot; + Guessing + &quot;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserMatchEventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserMatchListener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserMatchListener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserMatchListener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,12 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface ParserMatchListener : Listener
+	{
+		void  parserMatch		(object source, MatchEventArgs e);
+		void  parserMatchNot	(object source, MatchEventArgs e);
+		void  parserMismatch	(object source, MatchEventArgs e);
+		void  parserMismatchNot	(object source, MatchEventArgs e);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserMatchListener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserMatchListenerBase.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserMatchListenerBase.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserMatchListenerBase.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,65 @@
+namespace antlr.debug
+{
+	using System;
+	
+	/// &lt;summary&gt;
+	/// Provides an abstract base for implementing &lt;see cref=&quot;ParserMatchListener&quot;/&gt; subclasses.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	///		&lt;param&gt;
+	///		This abstract class is provided to make it easier to create &lt;see cref=&quot;ParserMatchListener&quot;/&gt;s. 
+	///		You should extend this base class rather than creating your own.
+	///		&lt;/param&gt;
+	/// &lt;/remarks&gt;
+	public abstract class ParserMatchListenerBase : ParserMatchListener
+	{
+		/// &lt;summary&gt;
+		/// Handle the &quot;Done&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  doneParsing(object source, TraceEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;Match&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserMatch(object source, MatchEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;MatchNot&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserMatchNot(object source, MatchEventArgs e)
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;MisMatch&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserMismatch(object source, MatchEventArgs e)
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;MisMatchNot&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserMismatchNot(object source, MatchEventArgs e)
+		{
+		}
+
+		public virtual void  refresh()
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserMatchListenerBase.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserReporter.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserReporter.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserReporter.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,56 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class ParserReporter : Tracer, ParserListener
+	{
+		public virtual void  parserConsume(object source, TokenEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  parserLA(object source, TokenEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  parserMatch(object source, MatchEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  parserMatchNot(object source, MatchEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  parserMismatch(object source, MatchEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  parserMismatchNot(object source, MatchEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  reportError(object source, MessageEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  reportWarning(object source, MessageEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  semanticPredicateEvaluated(object source, SemanticPredicateEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  syntacticPredicateFailed(object source, SyntacticPredicateEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  syntacticPredicateStarted(object source, SyntacticPredicateEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		public virtual void  syntacticPredicateSucceeded(object source, SyntacticPredicateEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserReporter.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserTokenEventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserTokenEventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserTokenEventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,51 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class TokenEventArgs : ANTLREventArgs
+	{
+		public TokenEventArgs()
+		{
+		}
+		public TokenEventArgs(int type, int amount, int val)
+		{
+			setValues(type, amount, val);
+		}
+
+		public virtual int Amount
+		{
+			get	{ return amount;	}
+			set	{ this.amount = value;	}
+		}
+
+		public virtual int Value
+		{
+			get	{ return this.value_;	}
+			set { this.value_ = value;	}
+		}
+
+		private int value_;
+		private int amount;
+
+		public static int LA = 0;
+		public static int CONSUME = 1;
+		
+		
+		/// &lt;summary&gt;This should NOT be called from anyone other than ParserEventSupport! 
+		/// &lt;/summary&gt;
+		internal void  setValues(int type, int amount, int val)
+		{
+			base.setValues(type);
+			this.Amount = amount;
+			this.Value  = val;
+		}
+
+		public override string ToString()
+		{
+			if (Type == LA)
+				return &quot;ParserTokenEvent [LA,&quot; + Amount + &quot;,&quot; + Value + &quot;]&quot;;
+			else
+				return &quot;ParserTokenEvent [consume,1,&quot; + Value + &quot;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserTokenEventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserTokenListener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserTokenListener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserTokenListener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,10 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface ParserTokenListener : Listener
+	{
+		void  parserConsume	(object source, TokenEventArgs e);
+		void  parserLA		(object source, TokenEventArgs e);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserTokenListener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ParserTokenListenerBase.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ParserTokenListenerBase.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ParserTokenListenerBase.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,47 @@
+namespace antlr.debug
+{
+	using System;
+	
+	/// &lt;summary&gt;
+	/// Provides an abstract base for implementing &lt;see cref=&quot;ParserTokenListener&quot;/&gt; subclasses.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	///		&lt;param&gt;
+	///		This abstract class is provided to make it easier to create &lt;see cref=&quot;ParserTokenListener&quot;/&gt;s. 
+	///		You should extend this base class rather than creating your own.
+	///		&lt;/param&gt;
+	/// &lt;/remarks&gt;
+	public abstract class ParserTokenListenerBase : ParserTokenListener
+	{
+		/// &lt;summary&gt;
+		/// Handle the &quot;Done&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  doneParsing(object source, TraceEventArgs e)
+		{
+		}
+
+		public virtual void  refresh()
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;Consume&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserConsume(object source, TokenEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;ParserLA&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  parserLA(object source, TokenEventArgs e)
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ParserTokenListenerBase.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/ScannerEventSupport.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/ScannerEventSupport.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/ScannerEventSupport.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,484 @@
+namespace antlr.debug
+{
+	using System;
+	using System.Reflection;
+	using Hashtable		= System.Collections.Hashtable;
+	using ArrayList		= System.Collections.ArrayList;
+
+	using antlr.collections.impl;
+	
+	
+	/// &lt;summary&gt;A class to assist in firing parser events
+	/// NOTE: I intentionally _did_not_ synchronize the event firing and
+	/// add/remove listener methods.  This is because the add/remove should
+	/// _only_ be called by the parser at its start/end, and the _same_thread_
+	/// should be performing the parsing.  This should help performance a tad...
+	/// &lt;/summary&gt;
+	public class ScannerEventSupport
+	{
+		private object source;
+		private Hashtable listeners;
+		private MatchEventArgs matchEvent;
+		private MessageEventArgs messageEvent;
+		private TokenEventArgs tokenEvent;
+		private SemanticPredicateEventArgs semPredEvent;
+		private SyntacticPredicateEventArgs synPredEvent;
+		private TraceEventArgs traceEvent;
+		private NewLineEventArgs newLineEvent;
+		//private ParserController controller;
+
+		private int ruleDepth = 0;
+		
+		
+		public ScannerEventSupport(object source)
+		{
+			matchEvent		= new MatchEventArgs();
+			messageEvent	= new MessageEventArgs();
+			tokenEvent		= new TokenEventArgs();
+			traceEvent		= new TraceEventArgs();
+			semPredEvent	= new SemanticPredicateEventArgs();
+			synPredEvent	= new SyntacticPredicateEventArgs();
+			newLineEvent	= new NewLineEventArgs();
+			listeners		= new Hashtable();
+			this.source		= source;
+		}
+
+		public virtual void checkController()
+		{
+			//if (controller != null)
+			//	controller.checkBreak();
+		}
+
+		public virtual void  addDoneListener(Listener l)
+		{
+			((CharScanner)source).Done += new TraceEventHandler(l.doneParsing);
+			listeners[l] = l;
+		}
+		public virtual void  addMessageListener(MessageListener l)
+		{
+			((CharScanner)source).ErrorReported   += new MessageEventHandler(l.reportError);
+			((CharScanner)source).WarningReported += new MessageEventHandler(l.reportWarning);
+			addDoneListener(l);
+		}
+		public virtual void  addNewLineListener(NewLineListener l)
+		{
+			((CharScanner)source).HitNewLine   += new NewLineEventHandler(l.hitNewLine);
+			addDoneListener(l);
+		}
+		public virtual void  addParserListener(ParserListener l)
+		{
+			if (l is ParserController)
+			{
+				//((ParserController) l).ParserEventSupport = this;
+				//controller = (ParserController) l;
+			}
+			addParserMatchListener(l);
+			addParserTokenListener(l);
+			
+			addMessageListener(l);
+			addTraceListener(l);
+			addSemanticPredicateListener(l);
+			addSyntacticPredicateListener(l);
+		}
+		public virtual void  addParserMatchListener(ParserMatchListener l)
+		{
+			((CharScanner)source).MatchedChar		+= new MatchEventHandler(l.parserMatch);
+			((CharScanner)source).MatchedNotChar	+= new MatchEventHandler(l.parserMatchNot);
+			((CharScanner)source).MisMatchedChar	+= new MatchEventHandler(l.parserMismatch);
+			((CharScanner)source).MisMatchedNotChar	+= new MatchEventHandler(l.parserMismatchNot);
+			addDoneListener(l);
+		}
+		public virtual void  addParserTokenListener(ParserTokenListener l)
+		{
+			((CharScanner)source).ConsumedChar	+= new TokenEventHandler(l.parserConsume);
+			((CharScanner)source).CharLA		+= new TokenEventHandler(l.parserLA);
+			addDoneListener(l);
+		}
+		public virtual void  addSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			((CharScanner)source).SemPredEvaluated	+= new SemanticPredicateEventHandler(l.semanticPredicateEvaluated);
+			addDoneListener(l);
+		}
+		public virtual void  addSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			((CharScanner)source).SynPredStarted		+= new SyntacticPredicateEventHandler(l.syntacticPredicateStarted);
+			((CharScanner)source).SynPredFailed		+= new SyntacticPredicateEventHandler(l.syntacticPredicateFailed);
+			((CharScanner)source).SynPredSucceeded	+= new SyntacticPredicateEventHandler(l.syntacticPredicateSucceeded);
+			addDoneListener(l);
+		}
+		public virtual void  addTraceListener(TraceListener l)
+		{
+			((CharScanner)source).EnterRule	+= new TraceEventHandler(l.enterRule);
+			((CharScanner)source).ExitRule	+= new TraceEventHandler(l.exitRule);
+			addDoneListener(l);
+		}
+		public virtual void  fireConsume(int c)
+		{
+			TokenEventHandler eventDelegate = (TokenEventHandler)((CharScanner)source).Events[Parser.LAEventKey];
+			if (eventDelegate != null) 
+			{
+				tokenEvent.setValues(TokenEventArgs.CONSUME, 1, c);
+				eventDelegate(source, tokenEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireDoneParsing()
+		{
+			TraceEventHandler eventDelegate = (TraceEventHandler)((CharScanner)source).Events[Parser.DoneEventKey];
+			if (eventDelegate != null) 
+			{
+				traceEvent.setValues(TraceEventArgs.DONE_PARSING, 0, 0, 0);
+				eventDelegate(source, traceEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireEnterRule(int ruleNum, int guessing, int data)
+		{
+			ruleDepth++;
+			TraceEventHandler eventDelegate = (TraceEventHandler)((CharScanner)source).Events[Parser.EnterRuleEventKey];
+			if (eventDelegate != null) 
+			{
+				traceEvent.setValues(TraceEventArgs.ENTER, ruleNum, guessing, data);
+				eventDelegate(source, traceEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireExitRule(int ruleNum, int guessing, int data)
+		{
+			TraceEventHandler eventDelegate = (TraceEventHandler)((CharScanner)source).Events[Parser.ExitRuleEventKey];
+			if (eventDelegate != null) 
+			{
+				traceEvent.setValues(TraceEventArgs.EXIT, ruleNum, guessing, data);
+				eventDelegate(source, traceEvent);
+			} 
+			checkController();
+
+			ruleDepth--;
+			if (ruleDepth == 0)
+				fireDoneParsing();
+
+		}
+		public virtual void  fireLA(int k, int la)
+		{
+			TokenEventHandler eventDelegate = (TokenEventHandler)((CharScanner)source).Events[Parser.LAEventKey];
+			if (eventDelegate != null) 
+			{
+				tokenEvent.setValues(TokenEventArgs.LA, k, la);
+				eventDelegate(source, tokenEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(char c, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR, c, c, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(char c, BitSet b, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR_BITSET, c, b, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(char c, string target, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR_RANGE, c, target, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(int c, BitSet b, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.BITSET, c, b, text, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(int n, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.TOKEN, n, n, text, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatch(string s, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.STRING, 0, s, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatchNot(char c, char n, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MatchNotEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR, c, n, null, guessing, true, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMatchNot(int c, int n, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MatchNotEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.TOKEN, c, n, text, guessing, true, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(char c, char n, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR, c, n, null, guessing, false, false);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(char c, BitSet b, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR_BITSET, c, b, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(char c, string target, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR_RANGE, c, target, null, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(int i, int n, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.TOKEN, i, n, text, guessing, false, false);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(int i, BitSet b, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.BITSET, i, b, text, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatch(string s, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MisMatchEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.STRING, 0, text, s, guessing, false, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatchNot(char v, char c, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MisMatchNotEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.CHAR, v, c, null, guessing, true, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireMismatchNot(int i, int n, string text, int guessing)
+		{
+			MatchEventHandler eventDelegate = (MatchEventHandler)((CharScanner)source).Events[Parser.MisMatchNotEventKey];
+			if (eventDelegate != null) 
+			{
+				matchEvent.setValues(MatchEventArgs.TOKEN, i, n, text, guessing, true, true);
+				eventDelegate(source, matchEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireNewLine(int line)
+		{
+			NewLineEventHandler eventDelegate = (NewLineEventHandler)((CharScanner)source).Events[Parser.NewLineEventKey];
+			if (eventDelegate != null) 
+			{
+				newLineEvent.Line = line;
+				eventDelegate(source, newLineEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireReportError(System.Exception e)
+		{
+			MessageEventHandler eventDelegate = (MessageEventHandler)((CharScanner)source).Events[Parser.ReportErrorEventKey];
+			if (eventDelegate != null) 
+			{
+				messageEvent.setValues(MessageEventArgs.ERROR, e.ToString());
+				eventDelegate(source, messageEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireReportError(string s)
+		{
+			MessageEventHandler eventDelegate = (MessageEventHandler)((CharScanner)source).Events[Parser.ReportErrorEventKey];
+			if (eventDelegate != null) 
+			{
+				messageEvent.setValues(MessageEventArgs.ERROR, s);
+				eventDelegate(source, messageEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireReportWarning(string s)
+		{
+			MessageEventHandler eventDelegate = (MessageEventHandler)((CharScanner)source).Events[Parser.ReportWarningEventKey];
+			if (eventDelegate != null) 
+			{
+				messageEvent.setValues(MessageEventArgs.WARNING, s);
+				eventDelegate(source, messageEvent);
+			}
+			checkController();
+		}
+		public virtual bool fireSemanticPredicateEvaluated(int type, int condition, bool result, int guessing)
+		{
+			SemanticPredicateEventHandler eventDelegate = (SemanticPredicateEventHandler)((CharScanner)source).Events[Parser.SemPredEvaluatedEventKey];
+			if (eventDelegate != null) 
+			{
+				semPredEvent.setValues(type, condition, result, guessing);
+				eventDelegate(source, semPredEvent);
+			}
+			checkController();
+
+			return result;
+		}
+		public virtual void  fireSyntacticPredicateFailed(int guessing)
+		{
+			SyntacticPredicateEventHandler eventDelegate = (SyntacticPredicateEventHandler)((CharScanner)source).Events[Parser.SynPredFailedEventKey];
+			if (eventDelegate != null) 
+			{
+				synPredEvent.setValues(0, guessing);
+				eventDelegate(source, synPredEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireSyntacticPredicateStarted(int guessing)
+		{
+			SyntacticPredicateEventHandler eventDelegate = (SyntacticPredicateEventHandler)((CharScanner)source).Events[Parser.SynPredStartedEventKey];
+			if (eventDelegate != null) 
+			{
+				synPredEvent.setValues(0, guessing);
+				eventDelegate(source, synPredEvent);
+			}
+			checkController();
+		}
+		public virtual void  fireSyntacticPredicateSucceeded(int guessing)
+		{
+			SyntacticPredicateEventHandler eventDelegate = (SyntacticPredicateEventHandler)((CharScanner)source).Events[Parser.SynPredSucceededEventKey];
+			if (eventDelegate != null) 
+			{
+				synPredEvent.setValues(0, guessing);
+				eventDelegate(source, synPredEvent);
+			}
+			checkController();
+		}
+		public virtual void  refreshListeners()
+		{
+			Hashtable clonedTable;
+
+			lock(listeners.SyncRoot)
+			{
+				clonedTable = (Hashtable)listeners.Clone();
+			}
+			foreach (Listener l in clonedTable)
+			{
+				l.refresh();
+			}
+		}
+		public virtual void  removeDoneListener(Listener l)
+		{
+			((CharScanner)source).Done -= new TraceEventHandler(l.doneParsing);
+			listeners.Remove(l);
+		}
+		public virtual void  removeMessageListener(MessageListener l)
+		{
+			((CharScanner)source).ErrorReported   -= new MessageEventHandler(l.reportError);
+			((CharScanner)source).WarningReported -= new MessageEventHandler(l.reportWarning);
+			removeDoneListener(l);
+		}
+		public virtual void  removeNewLineListener(NewLineListener l)
+		{
+			((CharScanner)source).HitNewLine   -= new NewLineEventHandler(l.hitNewLine);
+			removeDoneListener(l);
+		}
+		public virtual void  removeParserListener(ParserListener l)
+		{
+			removeParserMatchListener(l);
+			removeMessageListener(l);
+			removeParserTokenListener(l);
+			removeTraceListener(l);
+			removeSemanticPredicateListener(l);
+			removeSyntacticPredicateListener(l);
+		}
+		public virtual void  removeParserMatchListener(ParserMatchListener l)
+		{
+			((CharScanner)source).MatchedChar		-= new MatchEventHandler(l.parserMatch);
+			((CharScanner)source).MatchedNotChar	-= new MatchEventHandler(l.parserMatchNot);
+			((CharScanner)source).MisMatchedChar	-= new MatchEventHandler(l.parserMismatch);
+			((CharScanner)source).MisMatchedNotChar	-= new MatchEventHandler(l.parserMismatchNot);
+			removeDoneListener(l);
+		}
+		public virtual void  removeParserTokenListener(ParserTokenListener l)
+		{
+			((CharScanner)source).ConsumedChar	-= new TokenEventHandler(l.parserConsume);
+			((CharScanner)source).CharLA		-= new TokenEventHandler(l.parserLA);
+			removeDoneListener(l);
+		}
+		public virtual void  removeSemanticPredicateListener(SemanticPredicateListener l)
+		{
+			((CharScanner)source).SemPredEvaluated	-= new SemanticPredicateEventHandler(l.semanticPredicateEvaluated);
+			removeDoneListener(l);
+		}
+		public virtual void  removeSyntacticPredicateListener(SyntacticPredicateListener l)
+		{
+			((CharScanner)source).SynPredStarted	-= new SyntacticPredicateEventHandler(l.syntacticPredicateStarted);
+			((CharScanner)source).SynPredFailed		-= new SyntacticPredicateEventHandler(l.syntacticPredicateFailed);
+			((CharScanner)source).SynPredSucceeded	-= new SyntacticPredicateEventHandler(l.syntacticPredicateSucceeded);
+			removeDoneListener(l);
+		}
+		public virtual void  removeTraceListener(TraceListener l)
+		{
+			((CharScanner)source).EnterRule	-= new TraceEventHandler(l.enterRule);
+			((CharScanner)source).ExitRule	-= new TraceEventHandler(l.exitRule);
+			removeDoneListener(l);
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/ScannerEventSupport.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/SemanticPredicateEventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/SemanticPredicateEventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/SemanticPredicateEventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,47 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class SemanticPredicateEventArgs : GuessingEventArgs
+	{
+		public SemanticPredicateEventArgs()
+		{
+		}
+		public SemanticPredicateEventArgs(int type) : base(type)
+		{
+		}
+
+		public virtual int Condition
+		{
+			get	{ return this.condition_;	}
+			set	{ this.condition_ = value;	}
+		}
+
+		public virtual bool Result
+		{
+			get	{ return this.result_;	}
+			set	{ this.result_ = value;	}
+		}
+
+		public const int VALIDATING = 0;
+		public const int PREDICTING = 1;
+
+		private int condition_;
+		private bool result_;
+		
+		
+		/// &lt;summary&gt;This should NOT be called from anyone other than ParserEventSupport! 
+		/// &lt;/summary&gt;
+		internal void  setValues(int type, int condition, bool result, int guessing)
+		{
+			base.setValues(type, guessing);
+			this.Condition	= condition;
+			this.Result		= result;
+		}
+
+		public override string ToString()
+		{
+			return &quot;SemanticPredicateEvent [&quot; + Condition + &quot;,&quot; + Result + &quot;,&quot; + Guessing + &quot;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/SemanticPredicateEventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,9 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface SemanticPredicateListener : Listener
+	{
+		void  semanticPredicateEvaluated(object source, SemanticPredicateEventArgs e);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListenerBase.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListenerBase.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListenerBase.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,38 @@
+namespace antlr.debug
+{
+	using System;
+	
+	/// &lt;summary&gt;
+	/// Provides an abstract base for implementing &lt;see cref=&quot;SemanticPredicateListener&quot;/&gt; subclasses.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	///		&lt;param&gt;
+	///		This abstract class is provided to make it easier to create &lt;see cref=&quot;SemanticPredicateListener&quot;/&gt;s. 
+	///		You should extend this base class rather than creating your own.
+	///		&lt;/param&gt;
+	/// &lt;/remarks&gt;
+	public class SemanticPredicateListenerBase : SemanticPredicateListener
+	{
+		/// &lt;summary&gt;
+		/// Handle the &quot;Done&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  doneParsing(object source, TraceEventArgs e)
+		{
+		}
+
+		public virtual void  refresh()
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;SemPreEvaluated&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  semanticPredicateEvaluated(object source, SemanticPredicateEventArgs e)
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/SemanticPredicateListenerBase.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateEventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateEventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateEventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,21 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class SyntacticPredicateEventArgs : GuessingEventArgs
+	{
+		
+		
+		public SyntacticPredicateEventArgs()
+		{
+		}
+		public SyntacticPredicateEventArgs(int type) : base(type)
+		{
+		}
+
+		public override string ToString()
+		{
+			return &quot;SyntacticPredicateEvent [&quot; + Guessing + &quot;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateEventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,11 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface SyntacticPredicateListener : Listener
+	{
+		void  syntacticPredicateFailed		(object source, SyntacticPredicateEventArgs e);
+		void  syntacticPredicateStarted		(object source, SyntacticPredicateEventArgs e);
+		void  syntacticPredicateSucceeded	(object source, SyntacticPredicateEventArgs e);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListenerBase.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListenerBase.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListenerBase.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,56 @@
+namespace antlr.debug
+{
+	using System;
+	
+	/// &lt;summary&gt;
+	/// Provides an abstract base for implementing &lt;see cref=&quot;SyntacticPredicateListener&quot;/&gt; subclasses.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	///		&lt;param&gt;
+	///		This abstract class is provided to make it easier to create &lt;see cref=&quot;SyntacticPredicateListener&quot;/&gt;s. 
+	///		You should extend this base class rather than creating your own.
+	///		&lt;/param&gt;
+	/// &lt;/remarks&gt;
+	public abstract class SyntacticPredicateListenerBase : SyntacticPredicateListener
+	{
+		/// &lt;summary&gt;
+		/// Handle the &quot;Done&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  doneParsing(object source, TraceEventArgs e)
+		{
+		}
+
+		public virtual void  refresh()
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;SynPredFailed&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  syntacticPredicateFailed(object source, SyntacticPredicateEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;SynPredStarted&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  syntacticPredicateStarted(object source, SyntacticPredicateEventArgs e)
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Handle the &quot;SynPredSucceeded&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  syntacticPredicateSucceeded(object source, SyntacticPredicateEventArgs e)
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/SyntacticPredicateListenerBase.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/TraceEventArgs.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/TraceEventArgs.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/TraceEventArgs.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,49 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class TraceEventArgs : GuessingEventArgs
+	{
+		public TraceEventArgs()
+		{
+		}
+		public TraceEventArgs(int type, int ruleNum, int guessing, int data)
+		{
+			setValues(type, ruleNum, guessing, data);
+		}
+
+		public virtual int Data
+		{
+			get	{ return this.data_;	}
+			set	{ this.data_ = value;	}
+		}
+
+		public virtual int RuleNum
+		{
+			get	{ return this.ruleNum_;		}
+			set	{ this.ruleNum_ = value;	}
+		}
+
+		private int ruleNum_;
+		private int data_;
+
+		public static int ENTER = 0;
+		public static int EXIT = 1;
+		public static int DONE_PARSING = 2;
+		
+		
+		/// &lt;summary&gt;This should NOT be called from anyone other than ParserEventSupport! 
+		/// &lt;/summary&gt;
+		internal void  setValues(int type, int ruleNum, int guessing, int data)
+		{
+			base.setValues(type, guessing);
+			RuleNum = ruleNum;
+			Data	= data;
+		}
+
+		public override string ToString()
+		{
+			return &quot;ParserTraceEvent [&quot; + (Type == ENTER?&quot;enter,&quot;:&quot;exit,&quot;) + RuleNum + &quot;,&quot; + Guessing + &quot;]&quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/TraceEventArgs.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/TraceListener.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/TraceListener.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/TraceListener.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,10 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public interface TraceListener : Listener
+	{
+		void  enterRule	(object source, TraceEventArgs e);
+		void  exitRule	(object source, TraceEventArgs e);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/TraceListener.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/TraceListenerBase.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/TraceListenerBase.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/TraceListenerBase.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,47 @@
+namespace antlr.debug
+{
+	using System;
+
+	/// &lt;summary&gt;
+	/// Provides an abstract base for implementing &lt;see cref=&quot;TraceListener&quot;/&gt; subclasses.
+	/// &lt;/summary&gt;
+	/// &lt;remarks&gt;
+	///		&lt;param&gt;
+	///		This abstract class is provided to make it easier to create &lt;see cref=&quot;TraceListener&quot;/&gt;s. 
+	///		You should extend this base class rather than creating your own.
+	///		&lt;/param&gt;
+	/// &lt;/remarks&gt;
+	public abstract class TraceListenerBase : TraceListener
+	{
+		/// &lt;summary&gt;
+		/// Handle the &quot;Done&quot; event.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  doneParsing(object source, TraceEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;EnterRule&quot; event
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  enterRule(object source, TraceEventArgs e)
+		{
+		}
+
+		/// &lt;summary&gt;
+		/// Handle the &quot;ExitRule&quot; event
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;Event source object&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;Event data object&lt;/param&gt;
+		public virtual void  exitRule(object source, TraceEventArgs e)
+		{
+		}
+
+		public virtual void  refresh()
+		{
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/TraceListenerBase.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime/antlr.debug/Tracer.cs
===================================================================
--- trunk/src/antlr-runtime/antlr.debug/Tracer.cs	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime/antlr.debug/Tracer.cs	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,33 @@
+namespace antlr.debug
+{
+	using System;
+	
+	public class Tracer : TraceListenerBase, TraceListener
+	{
+		protected string indentString = &quot;&quot;;
+		// TBD: should be StringBuffer
+		
+		
+		protected internal virtual void  dedent()
+		{
+			if (indentString.Length &lt; 2)
+				indentString = &quot;&quot;;
+			else
+				indentString = indentString.Substring(2);
+		}
+		public override void  enterRule(object source, TraceEventArgs e)
+		{
+			System.Console.Out.WriteLine(indentString + e);
+			indent();
+		}
+		public override void  exitRule(object source, TraceEventArgs e)
+		{
+			dedent();
+			System.Console.Out.WriteLine(indentString + e);
+		}
+		protected internal virtual void  indent()
+		{
+			indentString += &quot;  &quot;;
+		}
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/antlr-runtime/antlr.debug/Tracer.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/antlr-runtime.dll.sources
===================================================================
--- trunk/src/antlr-runtime.dll.sources	2005-06-23 12:35:44 UTC (rev 25)
+++ trunk/src/antlr-runtime.dll.sources	2005-06-24 04:09:17 UTC (rev 26)
@@ -0,0 +1,102 @@
+antlr-runtime/AssemblyInfo.cs
+antlr-runtime/antlr.collections/AST.cs
+antlr-runtime/antlr.debug/InputBufferEventSupport.cs
+antlr-runtime/antlr.debug/TraceListenerBase.cs
+antlr-runtime/antlr.debug/ParserMatchListener.cs
+antlr-runtime/antlr.debug/MessageListener.cs
+antlr-runtime/antlr.debug/Tracer.cs
+antlr-runtime/antlr.debug/SemanticPredicateListenerBase.cs
+antlr-runtime/antlr.debug/NewLineListener.cs
+antlr-runtime/antlr.debug/InputBufferEventArgs.cs
+antlr-runtime/antlr.debug/InputBufferListener.cs
+antlr-runtime/antlr.debug/Listener.cs
+antlr-runtime/antlr.debug/SemanticPredicateEventArgs.cs
+antlr-runtime/antlr.debug/IParserDebugSubject.cs
+antlr-runtime/antlr.debug/MessageEventArgs.cs
+antlr-runtime/antlr.debug/ParserListener.cs
+antlr-runtime/antlr.debug/NewLineEventArgs.cs
+antlr-runtime/antlr.debug/ParserController.cs
+antlr-runtime/antlr.debug/DebuggingCharScanner.cs
+antlr-runtime/antlr.debug/DebuggingInputBuffer.cs
+antlr-runtime/antlr.debug/ParserReporter.cs
+antlr-runtime/antlr.debug/SemanticPredicateListener.cs
+antlr-runtime/antlr.debug/MessageListenerBase.cs
+antlr-runtime/antlr.debug/ScannerEventSupport.cs
+antlr-runtime/antlr.debug/ICharScannerDebugSubject.cs
+antlr-runtime/antlr.debug/SyntacticPredicateEventArgs.cs
+antlr-runtime/antlr.debug/ANTLREventArgs.cs
+antlr-runtime/antlr.debug/SyntacticPredicateListenerBase.cs
+antlr-runtime/antlr.debug/GuessingEventArgs.cs
+antlr-runtime/antlr.debug/TraceListener.cs
+antlr-runtime/antlr.debug/ParserMatchEventArgs.cs
+antlr-runtime/antlr.debug/IDebugSubject.cs
+antlr-runtime/antlr.debug/LLkDebuggingParser.cs
+antlr-runtime/antlr.debug/DebuggingParser.cs
+antlr-runtime/antlr.debug/ParseTreeDebugParser.cs
+antlr-runtime/antlr.debug/ParserListenerBase.cs
+antlr-runtime/antlr.debug/ParserTokenEventArgs.cs
+antlr-runtime/antlr.debug/InputBufferListenerBase.cs
+antlr-runtime/antlr.debug/SyntacticPredicateListener.cs
+antlr-runtime/antlr.debug/ParserTokenListener.cs
+antlr-runtime/antlr.debug/TraceEventArgs.cs
+antlr-runtime/antlr.debug/ParserMatchListenerBase.cs
+antlr-runtime/antlr.debug/InputBufferReporter.cs
+antlr-runtime/antlr.debug/ParserTokenListenerBase.cs
+antlr-runtime/antlr.debug/ParserEventSupport.cs
+antlr-runtime/antlr.collections.impl/BitSet.cs
+antlr-runtime/antlr.collections.impl/ASTArray.cs
+antlr-runtime/SupportClass.cs
+antlr-runtime/antlr/ParseTreeRule.cs
+antlr-runtime/antlr/ASTNULLType.cs
+antlr-runtime/antlr/ANTLRPanicException.cs
+antlr-runtime/antlr/Token.cs
+antlr-runtime/antlr/MismatchedCharException.cs
+antlr-runtime/antlr/CharStreamIOException.cs
+antlr-runtime/antlr/SemanticException.cs
+antlr-runtime/antlr/CommonAST.cs
+antlr-runtime/antlr/TokenStreamRetryException.cs
+antlr-runtime/antlr/IToken.cs
+antlr-runtime/antlr/ParseTree.cs
+antlr-runtime/antlr/FileLineFormatter.cs
+antlr-runtime/antlr/Parser.cs
+antlr-runtime/antlr/TokenCreator.cs
+antlr-runtime/antlr/CommonASTWithHiddenTokens.cs
+antlr-runtime/antlr/NoViableAltForCharException.cs
+antlr-runtime/antlr/CharQueue.cs
+antlr-runtime/antlr/CharScanner.cs
+antlr-runtime/antlr/TokenWithIndex.cs
+antlr-runtime/antlr/TokenStreamException.cs
+antlr-runtime/antlr/CommonToken.cs
+antlr-runtime/antlr/CommonHiddenStreamToken.cs
+antlr-runtime/antlr/TokenStreamRewriteEngine.cs
+antlr-runtime/antlr/StringUtils.cs
+antlr-runtime/antlr/BaseAST.cs
+antlr-runtime/antlr/ParserSharedInputState.cs
+antlr-runtime/antlr/ByteBuffer.cs
+antlr-runtime/antlr/CharBuffer.cs
+antlr-runtime/antlr/MismatchedTokenException.cs
+antlr-runtime/antlr/TokenStreamBasicFilter.cs
+antlr-runtime/antlr/ASTPair.cs
+antlr-runtime/antlr/IHiddenStreamToken.cs
+antlr-runtime/antlr/DumpASTVisitor.cs
+antlr-runtime/antlr/TokenBuffer.cs
+antlr-runtime/antlr/InputBuffer.cs
+antlr-runtime/antlr/LLkParser.cs
+antlr-runtime/antlr/TokenStreamIOException.cs
+antlr-runtime/antlr/RecognitionException.cs
+antlr-runtime/antlr/TokenStreamRecognitionException.cs
+antlr-runtime/antlr/CharStreamException.cs
+antlr-runtime/antlr/TokenStreamSelector.cs
+antlr-runtime/antlr/ASTVisitor.cs
+antlr-runtime/antlr/TokenStream.cs
+antlr-runtime/antlr/NoViableAltException.cs
+antlr-runtime/antlr/DefaultFileLineFormatter.cs
+antlr-runtime/antlr/ASTNodeCreator.cs
+antlr-runtime/antlr/LexerSharedInputState.cs
+antlr-runtime/antlr/TreeParser.cs
+antlr-runtime/antlr/TokenQueue.cs
+antlr-runtime/antlr/TokenStreamHiddenTokenFilter.cs
+antlr-runtime/antlr/ParseTreeToken.cs
+antlr-runtime/antlr/TreeParserSharedInputState.cs
+antlr-runtime/antlr/ASTFactory.cs
+antlr-runtime/antlr/ANTLRException.cs

Added: trunk/src/nmodule.snk
===================================================================
(Binary files differ)


Property changes on: trunk/src/nmodule.snk
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000010.html">[nmodule-commits] r25 - tags
</A></li>
	<LI>Next message: <A HREF="000012.html">[nmodule-commits] r27 - in trunk: . src/NModule.Core.Loader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11">[ date ]</a>
              <a href="thread.html#11">[ thread ]</a>
              <a href="subject.html#11">[ subject ]</a>
              <a href="author.html#11">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/nmodule-commits">More information about the nmodule-commits
mailing list</a><br>
</body></html>
