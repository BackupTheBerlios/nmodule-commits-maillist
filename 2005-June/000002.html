<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [nmodule-commits] r10 - in trunk: . NModule.Dependency.Parser
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/nmodule-commits/2005-June/index.html" >
   <LINK REL="made" HREF="mailto:nmodule-commits%40lists.berlios.de?Subject=Re%3A%20%5Bnmodule-commits%5D%20r10%20-%20in%20trunk%3A%20.%20NModule.Dependency.Parser&In-Reply-To=%3C200506040539.j545dSAU014394%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000001.html">
   <LINK REL="Next"  HREF="000003.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[nmodule-commits] r10 - in trunk: . NModule.Dependency.Parser</H1>
    <B>Michael Tindal at BerliOS</B> 
    <A HREF="mailto:nmodule-commits%40lists.berlios.de?Subject=Re%3A%20%5Bnmodule-commits%5D%20r10%20-%20in%20trunk%3A%20.%20NModule.Dependency.Parser&In-Reply-To=%3C200506040539.j545dSAU014394%40sheep.berlios.de%3E"
       TITLE="[nmodule-commits] r10 - in trunk: . NModule.Dependency.Parser">urilith at sheep.berlios.de
       </A><BR>
    <I>Sat Jun  4 07:39:28 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000001.html">[nmodule-commits] r9 - trunk
</A></li>
        <LI>Next message: <A HREF="000003.html">[nmodule-commits] r18 - in trunk: . Documentation src src/NModule.Core.Loader src/NModule.Core.Module src/NModule.Dependency.Parser
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2">[ date ]</a>
              <a href="thread.html#2">[ thread ]</a>
              <a href="subject.html#2">[ subject ]</a>
              <a href="author.html#2">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: urilith
Date: 2005-06-04 07:39:11 +0200 (Sat, 04 Jun 2005)
New Revision: 10

Added:
   trunk/NModule.Dependency.Parser/DepConstraint.cs
   trunk/NModule.Dependency.Parser/DepLexer.cs
   trunk/NModule.Dependency.Parser/DepNode.cs
   trunk/NModule.Dependency.Parser/DepOps.cs
   trunk/NModule.Dependency.Parser/DepParser.cs
   trunk/NModule.Dependency.Parser/DepParserTokenTypes.cs
   trunk/NModule.Dependency.Parser/DepParserTokenTypes.txt
   trunk/NModule.Dependency.Parser/DepVersion.cs
   trunk/NModule.Dependency.Parser/antlr.astframe.dll
   trunk/NModule.Dependency.Parser/antlr.runtime.dll
   trunk/NModule.Dependency.Parser/build.sh
   trunk/NModule.Dependency.Parser/nmodule-dep.g.old
   trunk/NModuleTest.cs
   trunk/build.sh
Modified:
   trunk/
   trunk/ChangeLog
   trunk/NModule.Dependency.Parser/nmodule-dep.g
Log:
 <A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">r50 at dreamshadow</A>:  urilith | 2005-06-04 00:38:55 -0500
 Sat Jun 04, 2005 Michael Tindal (<A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">mtindal at paradoxpoint.com</A>) -0500
 M NModule.Dependency.Parser/nmodule-dep.g
   * Grammar now generates dependency trees :)
 A NModule.Dependency.Parser/DepConstraint.cs
   * Constraint class. Contains the name and version of constraints placed on a bottom-level operator node.
 A NModule.Dependency.Parser/DepLexer.cs
   * Lexer class generated by antlr from nmodule-dep.g.
 A NModule.Dependency.Parser/DepNode.cs
   * Node class. Represents a dependency node. Contains information on the node, constraint if
 A NModule.Dependency.Parser/DepOps.cs
   * DepOps enum. Enumeration containing the current operators.
 A NModule.Dependency.Parser/DepParser.cs
   * Parser class generated by antlr from nmodule-dep.g.
 A NModule.Dependency.Parser/DepParserTokenTypes.cs
   * Token file generated by antlr from nmodule-dep.g.
 A NModule.Dependency.Parser/DepParserTokenTypes.txt
   * Token file generated by antlr from nmodule-dep.g.
 A NModule.Dependency.Parser/DepVersion.cs
   * DepVersion class. Contains properties for each version component for easy comparison.
 A NModule.Dependency.Parser/antlr.astframe.dll
   * Antlr runtime files.
 A NModule.Dependency.Parser/antlr.runtime.dll
   * Antlr runtime files.
 A NModule.Dependency.Parser/build.sh
   * Script to simply my life building the parser until I write up the nant build files.
 A + NModule.Dependency.Parser/nmodule-dep.g.old
   * The old grammar, kept around until I can ensure the new grammar is 100% bug-free.
 A NModuleTest.cs
   * Test file for the new grammar.
 A build.sh
   * Build file to simply building the test file until I write up the nant build files.
 



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - b743595e-7af7-0310-b020-feacd67de632:/local/nmodule/trunk:45
   + b743595e-7af7-0310-b020-feacd67de632:/local/nmodule/trunk:50

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/ChangeLog	2005-06-04 05:39:11 UTC (rev 10)
@@ -1,3 +1,35 @@
+Sat Jun 04, 2005 Michael Tindal (<A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">mtindal at paradoxpoint.com</A>) -0500
+M   NModule.Dependency.Parser/nmodule-dep.g
+  * Grammar now generates dependency trees :)
+A   NModule.Dependency.Parser/DepConstraint.cs
+  * Constraint class.  Contains the name and version of constraints placed on a bottom-level operator node.
+A   NModule.Dependency.Parser/DepLexer.cs
+  * Lexer class generated by antlr from nmodule-dep.g.
+A   NModule.Dependency.Parser/DepNode.cs
+  * Node class.  Represents a dependency node.  Contains information on the node, constraint if 
+A   NModule.Dependency.Parser/DepOps.cs
+  * DepOps enum.  Enumeration containing the current operators.
+A   NModule.Dependency.Parser/DepParser.cs
+  * Parser class generated by antlr from nmodule-dep.g.
+A   NModule.Dependency.Parser/DepParserTokenTypes.cs
+  * Token file generated by antlr from nmodule-dep.g.
+A   NModule.Dependency.Parser/DepParserTokenTypes.txt
+  * Token file generated by antlr from nmodule-dep.g.
+A   NModule.Dependency.Parser/DepVersion.cs
+  * DepVersion class.  Contains properties for each version component for easy comparison.
+A   NModule.Dependency.Parser/antlr.astframe.dll
+  * Antlr runtime files.
+A   NModule.Dependency.Parser/antlr.runtime.dll
+  * Antlr runtime files.
+A   NModule.Dependency.Parser/build.sh
+  * Script to simply my life building the parser until I write up the nant build files.
+A + NModule.Dependency.Parser/nmodule-dep.g.old
+  * The old grammar, kept around until I can ensure the new grammar is 100% bug-free.
+A   NModuleTest.cs
+  * Test file for the new grammar.
+A   build.sh
+  * Build file to simply building the test file until I write up the nant build files.
+
 Wed Jun 01, 2005 Michael Tindal (<A HREF="https://lists.berlios.de/mailman/listinfo/nmodule-commits">mtindal at paradoxpoint.com</A>) -0500
 M   AUTHORS
   * Fix my e-mail address.

Added: trunk/NModule.Dependency.Parser/DepConstraint.cs
===================================================================
--- trunk/NModule.Dependency.Parser/DepConstraint.cs	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/DepConstraint.cs	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,64 @@
+using System;
+using System.Collections;
+
+namespace NModule.Dependency.Parser
+{
+	public class DepConstraint
+	{
+		private DepVersion _version;
+		private string _name;
+
+		public DepConstraint()
+		{
+			_name = &quot;&quot;;
+			_version = null;
+		}
+
+		public DepVersion Version
+		{
+			get
+			{
+				return _version;
+			}
+			set
+			{
+				_version = value;
+			}
+		}
+
+		public string Name
+		{
+			get
+			{
+				return _name;
+			}
+			set
+			{
+				_name = value;
+			}
+		}
+
+		public string VersionTmp
+		{
+			set
+			{
+				_version = VersionParse(value);
+			}
+		}
+
+		protected DepVersion VersionParse(string v)
+		{
+			// Here we go :)
+			DepVersion ver = new DepVersion();
+			string[] vparts = v.Split('.');
+			ver.Major = Int32.Parse(vparts[0]);
+			ver.Minor = Int32.Parse(vparts[1]);
+			if (vparts.Length &gt; 2)
+				ver.Build = Int32.Parse(vparts[2]);
+			if (vparts.Length &gt; 3)
+				ver.Build = Int32.Parse(vparts[3]);
+			return ver;
+		}
+	}
+}
+

Added: trunk/NModule.Dependency.Parser/DepLexer.cs
===================================================================
--- trunk/NModule.Dependency.Parser/DepLexer.cs	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/DepLexer.cs	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,714 @@
+// $ANTLR 2.7.5 (20050516): &quot;nmodule-dep.g&quot; -&gt; &quot;DepLexer.cs&quot;$
+
+namespace NModule.Dependency.Parser
+{
+	// Generate header specific to lexer CSharp file
+	using System;
+	using Stream                          = System.IO.Stream;
+	using TextReader                      = System.IO.TextReader;
+	using Hashtable                       = System.Collections.Hashtable;
+	using Comparer                        = System.Collections.Comparer;
+	
+	using TokenStreamException            = antlr.TokenStreamException;
+	using TokenStreamIOException          = antlr.TokenStreamIOException;
+	using TokenStreamRecognitionException = antlr.TokenStreamRecognitionException;
+	using CharStreamException             = antlr.CharStreamException;
+	using CharStreamIOException           = antlr.CharStreamIOException;
+	using ANTLRException                  = antlr.ANTLRException;
+	using CharScanner                     = antlr.CharScanner;
+	using InputBuffer                     = antlr.InputBuffer;
+	using ByteBuffer                      = antlr.ByteBuffer;
+	using CharBuffer                      = antlr.CharBuffer;
+	using Token                           = antlr.Token;
+	using IToken                          = antlr.IToken;
+	using CommonToken                     = antlr.CommonToken;
+	using SemanticException               = antlr.SemanticException;
+	using RecognitionException            = antlr.RecognitionException;
+	using NoViableAltForCharException     = antlr.NoViableAltForCharException;
+	using MismatchedCharException         = antlr.MismatchedCharException;
+	using TokenStream                     = antlr.TokenStream;
+	using LexerSharedInputState           = antlr.LexerSharedInputState;
+	using BitSet                          = antlr.collections.impl.BitSet;
+	
+	public 	class DepLexer : antlr.CharScanner	, TokenStream
+	 {
+		public const int EOF = 1;
+		public const int NULL_TREE_LOOKAHEAD = 3;
+		public const int LPAREN = 4;
+		public const int NOTO = 5;
+		public const int RPAREN = 6;
+		public const int AND = 7;
+		public const int OR = 8;
+		public const int XOR = 9;
+		public const int OPT = 10;
+		public const int EQ = 11;
+		public const int NEQ = 12;
+		public const int LTE = 13;
+		public const int LS = 14;
+		public const int GTE = 15;
+		public const int GT = 16;
+		public const int LD = 17;
+		public const int CLASS = 18;
+		public const int VER = 19;
+		public const int INT = 20;
+		public const int DOT = 21;
+		public const int ID_START_LETTER = 22;
+		public const int ID_LETTER = 23;
+		public const int ID = 24;
+		public const int WS = 25;
+		
+		public DepLexer(Stream ins) : this(new ByteBuffer(ins))
+		{
+		}
+		
+		public DepLexer(TextReader r) : this(new CharBuffer(r))
+		{
+		}
+		
+		public DepLexer(InputBuffer ib)		 : this(new LexerSharedInputState(ib))
+		{
+		}
+		
+		public DepLexer(LexerSharedInputState state) : base(state)
+		{
+			initialize();
+		}
+		private void initialize()
+		{
+			caseSensitiveLiterals = true;
+			setCaseSensitive(true);
+			literals = new Hashtable(100, (float) 0.4, null, Comparer.Default);
+		}
+		
+		override public IToken nextToken()			//throws TokenStreamException
+		{
+			IToken theRetToken = null;
+tryAgain:
+			for (;;)
+			{
+				IToken _token = null;
+				int _ttype = Token.INVALID_TYPE;
+				resetText();
+				try     // for char stream error handling
+				{
+					try     // for lexical error handling
+					{
+						switch ( cached_LA1 )
+						{
+						case '(':
+						{
+							mLPAREN(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case ')':
+						{
+							mRPAREN(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case '&amp;':
+						{
+							mAND(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case '|':
+						{
+							mOR(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case '^':
+						{
+							mXOR(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case '=':
+						{
+							mEQ(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case '?':
+						{
+							mOPT(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case '#':
+						{
+							mLD(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case '0':  case '1':  case '2':  case '3':
+						case '4':  case '5':  case '6':  case '7':
+						case '8':  case '9':
+						{
+							mVER(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case 'A':  case 'B':  case 'C':  case 'D':
+						case 'E':  case 'F':  case 'G':  case 'H':
+						case 'I':  case 'J':  case 'K':  case 'L':
+						case 'M':  case 'N':  case 'O':  case 'P':
+						case 'Q':  case 'R':  case 'S':  case 'T':
+						case 'U':  case 'V':  case 'W':  case 'X':
+						case 'Y':  case 'Z':  case '_':  case 'a':
+						case 'b':  case 'c':  case 'd':  case 'e':
+						case 'f':  case 'g':  case 'h':  case 'i':
+						case 'j':  case 'k':  case 'l':  case 'm':
+						case 'n':  case 'o':  case 'p':  case 'q':
+						case 'r':  case 's':  case 't':  case 'u':
+						case 'v':  case 'w':  case 'x':  case 'y':
+						case 'z':
+						{
+							mCLASS(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						case '\t':  case '\n':  case '\r':  case ' ':
+						{
+							mWS(true);
+							theRetToken = returnToken_;
+							break;
+						}
+						default:
+							if ((cached_LA1=='!') &amp;&amp; (cached_LA2=='!'))
+							{
+								mNOTO(true);
+								theRetToken = returnToken_;
+							}
+							else if ((cached_LA1=='!') &amp;&amp; (cached_LA2=='=')) {
+								mNEQ(true);
+								theRetToken = returnToken_;
+							}
+							else if ((cached_LA1=='&lt;') &amp;&amp; (cached_LA2=='=')) {
+								mLTE(true);
+								theRetToken = returnToken_;
+							}
+							else if ((cached_LA1=='&lt;') &amp;&amp; (cached_LA2=='&lt;')) {
+								mLS(true);
+								theRetToken = returnToken_;
+							}
+							else if ((cached_LA1=='&gt;') &amp;&amp; (cached_LA2=='=')) {
+								mGTE(true);
+								theRetToken = returnToken_;
+							}
+							else if ((cached_LA1=='&gt;') &amp;&amp; (cached_LA2=='&gt;')) {
+								mGT(true);
+								theRetToken = returnToken_;
+							}
+						else
+						{
+							if (cached_LA1==EOF_CHAR) { uponEOF(); returnToken_ = makeToken(Token.EOF_TYPE); }
+				else {throw new NoViableAltForCharException(cached_LA1, getFilename(), getLine(), getColumn());}
+						}
+						break; }
+						if ( null==returnToken_ ) goto tryAgain; // found SKIP token
+						_ttype = returnToken_.Type;
+						_ttype = testLiteralsTable(_ttype);
+						returnToken_.Type = _ttype;
+						return returnToken_;
+					}
+					catch (RecognitionException e) {
+							throw new TokenStreamRecognitionException(e);
+					}
+				}
+				catch (CharStreamException cse) {
+					if ( cse is CharStreamIOException ) {
+						throw new TokenStreamIOException(((CharStreamIOException)cse).io);
+					}
+					else {
+						throw new TokenStreamException(cse.Message);
+					}
+				}
+			}
+		}
+		
+	public void mLPAREN(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = LPAREN;
+		
+		match('(');
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mRPAREN(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = RPAREN;
+		
+		match(')');
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mNOTO(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = NOTO;
+		
+		match(&quot;!!&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mAND(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = AND;
+		
+		match(&quot;&amp;&amp;&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mOR(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = OR;
+		
+		match(&quot;||&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mXOR(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = XOR;
+		
+		match(&quot;^^&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mEQ(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = EQ;
+		
+		match(&quot;==&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mNEQ(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = NEQ;
+		
+		match(&quot;!=&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mLTE(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = LTE;
+		
+		match(&quot;&lt;=&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mLS(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = LS;
+		
+		match(&quot;&lt;&lt;&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mGTE(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = GTE;
+		
+		match(&quot;&gt;=&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mGT(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = GT;
+		
+		match(&quot;&gt;&gt;&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mOPT(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = OPT;
+		
+		match(&quot;??&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mLD(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = LD;
+		
+		match(&quot;##&quot;);
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	protected void mINT(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = INT;
+		
+		{ // ( ... )+
+			int _cnt49=0;
+			for (;;)
+			{
+				if (((cached_LA1 &gt;= '0' &amp;&amp; cached_LA1 &lt;= '9')))
+				{
+					matchRange('0','9');
+				}
+				else
+				{
+					if (_cnt49 &gt;= 1) { goto _loop49_breakloop; } else { throw new NoViableAltForCharException(cached_LA1, getFilename(), getLine(), getColumn());; }
+				}
+				
+				_cnt49++;
+			}
+_loop49_breakloop:			;
+		}    // ( ... )+
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mVER(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = VER;
+		
+		mINT(false);
+		{    // ( ... )*
+			for (;;)
+			{
+				if ((cached_LA1=='.'))
+				{
+					mDOT(false);
+					mINT(false);
+				}
+				else
+				{
+					goto _loop52_breakloop;
+				}
+				
+			}
+_loop52_breakloop:			;
+		}    // ( ... )*
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	protected void mDOT(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = DOT;
+		
+		match('.');
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	protected void mID_START_LETTER(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = ID_START_LETTER;
+		
+		switch ( cached_LA1 )
+		{
+		case 'a':  case 'b':  case 'c':  case 'd':
+		case 'e':  case 'f':  case 'g':  case 'h':
+		case 'i':  case 'j':  case 'k':  case 'l':
+		case 'm':  case 'n':  case 'o':  case 'p':
+		case 'q':  case 'r':  case 's':  case 't':
+		case 'u':  case 'v':  case 'w':  case 'x':
+		case 'y':  case 'z':
+		{
+			{
+				matchRange('a','z');
+			}
+			break;
+		}
+		case 'A':  case 'B':  case 'C':  case 'D':
+		case 'E':  case 'F':  case 'G':  case 'H':
+		case 'I':  case 'J':  case 'K':  case 'L':
+		case 'M':  case 'N':  case 'O':  case 'P':
+		case 'Q':  case 'R':  case 'S':  case 'T':
+		case 'U':  case 'V':  case 'W':  case 'X':
+		case 'Y':  case 'Z':
+		{
+			{
+				matchRange('A','Z');
+			}
+			break;
+		}
+		case '_':
+		{
+			{
+				match('_');
+			}
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltForCharException(cached_LA1, getFilename(), getLine(), getColumn());
+		}
+		 }
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	protected void mID_LETTER(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = ID_LETTER;
+		
+		switch ( cached_LA1 )
+		{
+		case 'A':  case 'B':  case 'C':  case 'D':
+		case 'E':  case 'F':  case 'G':  case 'H':
+		case 'I':  case 'J':  case 'K':  case 'L':
+		case 'M':  case 'N':  case 'O':  case 'P':
+		case 'Q':  case 'R':  case 'S':  case 'T':
+		case 'U':  case 'V':  case 'W':  case 'X':
+		case 'Y':  case 'Z':  case '_':  case 'a':
+		case 'b':  case 'c':  case 'd':  case 'e':
+		case 'f':  case 'g':  case 'h':  case 'i':
+		case 'j':  case 'k':  case 'l':  case 'm':
+		case 'n':  case 'o':  case 'p':  case 'q':
+		case 'r':  case 's':  case 't':  case 'u':
+		case 'v':  case 'w':  case 'x':  case 'y':
+		case 'z':
+		{
+			mID_START_LETTER(false);
+			break;
+		}
+		case '0':  case '1':  case '2':  case '3':
+		case '4':  case '5':  case '6':  case '7':
+		case '8':  case '9':
+		{
+			{
+				matchRange('0','9');
+			}
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltForCharException(cached_LA1, getFilename(), getLine(), getColumn());
+		}
+		 }
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	protected void mID(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = ID;
+		
+		mID_START_LETTER(false);
+		{    // ( ... )*
+			for (;;)
+			{
+				if ((tokenSet_0_.member(cached_LA1)))
+				{
+					mID_LETTER(false);
+				}
+				else
+				{
+					goto _loop62_breakloop;
+				}
+				
+			}
+_loop62_breakloop:			;
+		}    // ( ... )*
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mCLASS(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = CLASS;
+		
+		mID(false);
+		{    // ( ... )*
+			for (;;)
+			{
+				if ((cached_LA1=='.'))
+				{
+					mDOT(false);
+					mID(false);
+				}
+				else
+				{
+					goto _loop65_breakloop;
+				}
+				
+			}
+_loop65_breakloop:			;
+		}    // ( ... )*
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	public void mWS(bool _createToken) //throws RecognitionException, CharStreamException, TokenStreamException
+{
+		int _ttype; IToken _token=null; int _begin=text.Length;
+		_ttype = WS;
+		
+		{
+			switch ( cached_LA1 )
+			{
+			case ' ':
+			{
+				match(' ');
+				break;
+			}
+			case '\r':
+			{
+				match('\r');
+				match('\n');
+				break;
+			}
+			case '\n':
+			{
+				match('\n');
+				break;
+			}
+			case '\t':
+			{
+				match('\t');
+				break;
+			}
+			default:
+			{
+				throw new NoViableAltForCharException(cached_LA1, getFilename(), getLine(), getColumn());
+			}
+			 }
+		}
+		_ttype = Token.SKIP;
+		if (_createToken &amp;&amp; (null == _token) &amp;&amp; (_ttype != Token.SKIP))
+		{
+			_token = makeToken(_ttype);
+			_token.setText(text.ToString(_begin, text.Length-_begin));
+		}
+		returnToken_ = _token;
+	}
+	
+	
+	private static long[] mk_tokenSet_0_()
+	{
+		long[] data = { 287948901175001088L, 576460745995190270L, 0L, 0L};
+		return data;
+	}
+	public static readonly BitSet tokenSet_0_ = new BitSet(mk_tokenSet_0_());
+	
+}
+}


Property changes on: trunk/NModule.Dependency.Parser/DepLexer.cs
___________________________________________________________________
Name: svn:mime-type
   + text/cpp

Added: trunk/NModule.Dependency.Parser/DepNode.cs
===================================================================
--- trunk/NModule.Dependency.Parser/DepNode.cs	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/DepNode.cs	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,73 @@
+using System;
+using System.Collections;
+
+namespace NModule.Dependency.Parser
+{
+
+	public class DepNode
+	{
+		private DepConstraint _constraint;
+		private DepOps _op;
+		private DepNode _parent;
+		private ArrayList _children;
+
+		public DepNode()
+		{
+			_parent = null;
+			_children = new ArrayList();
+		}
+
+		public DepNode(DepNode parent)
+		{
+			_parent = parent;
+			_children = new ArrayList();
+		}
+
+		public DepNode Parent
+		{
+			get
+			{
+				return _parent;
+			}
+		}
+
+		public ArrayList Children
+		{
+			get
+			{
+				return _children;
+			}
+		}
+
+		public DepNode CreateNewChild()
+		{
+			DepNode child = new DepNode(this);
+			_children.Add(child);
+			return child;
+		}
+
+		public DepOps DepOp
+		{
+			get
+			{
+				return _op;
+			}
+			set
+			{
+				_op = value;
+			}
+		}
+
+		public DepConstraint Constraint
+		{
+			get
+			{
+				return _constraint;
+			}
+			set
+			{
+				_constraint = value;
+			}
+		}
+	}
+}

Added: trunk/NModule.Dependency.Parser/DepOps.cs
===================================================================
--- trunk/NModule.Dependency.Parser/DepOps.cs	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/DepOps.cs	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,5 @@
+namespace NModule.Dependency.Parser
+{
+
+	public enum DepOps { Not, And, Or, Xor, Opt, Equal, NotEqual, LessThanEqual, LessThan, GreaterThanEqual, GreaterThan, Loaded };
+}

Added: trunk/NModule.Dependency.Parser/DepParser.cs
===================================================================
--- trunk/NModule.Dependency.Parser/DepParser.cs	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/DepParser.cs	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,627 @@
+// $ANTLR 2.7.5 (20050516): &quot;nmodule-dep.g&quot; -&gt; &quot;DepParser.cs&quot;$
+
+namespace NModule.Dependency.Parser
+{
+	// Generate the header common to all output files.
+	using System;
+	
+	using TokenBuffer              = antlr.TokenBuffer;
+	using TokenStreamException     = antlr.TokenStreamException;
+	using TokenStreamIOException   = antlr.TokenStreamIOException;
+	using ANTLRException           = antlr.ANTLRException;
+	using LLkParser = antlr.LLkParser;
+	using Token                    = antlr.Token;
+	using IToken                   = antlr.IToken;
+	using TokenStream              = antlr.TokenStream;
+	using RecognitionException     = antlr.RecognitionException;
+	using NoViableAltException     = antlr.NoViableAltException;
+	using MismatchedTokenException = antlr.MismatchedTokenException;
+	using SemanticException        = antlr.SemanticException;
+	using ParserSharedInputState   = antlr.ParserSharedInputState;
+	using BitSet                   = antlr.collections.impl.BitSet;
+	
+	public 	class DepParser : antlr.LLkParser
+	{
+		public const int EOF = 1;
+		public const int NULL_TREE_LOOKAHEAD = 3;
+		public const int LPAREN = 4;
+		public const int NOTO = 5;
+		public const int RPAREN = 6;
+		public const int AND = 7;
+		public const int OR = 8;
+		public const int XOR = 9;
+		public const int OPT = 10;
+		public const int EQ = 11;
+		public const int NEQ = 12;
+		public const int LTE = 13;
+		public const int LS = 14;
+		public const int GTE = 15;
+		public const int GT = 16;
+		public const int LD = 17;
+		public const int CLASS = 18;
+		public const int VER = 19;
+		public const int INT = 20;
+		public const int DOT = 21;
+		public const int ID_START_LETTER = 22;
+		public const int ID_LETTER = 23;
+		public const int ID = 24;
+		public const int WS = 25;
+		
+		
+		protected void initialize()
+		{
+			tokenNames = tokenNames_;
+		}
+		
+		
+		protected DepParser(TokenBuffer tokenBuf, int k) : base(tokenBuf, k)
+		{
+			initialize();
+		}
+		
+		public DepParser(TokenBuffer tokenBuf) : this(tokenBuf,3)
+		{
+		}
+		
+		protected DepParser(TokenStream lexer, int k) : base(lexer,k)
+		{
+			initialize();
+		}
+		
+		public DepParser(TokenStream lexer) : this(lexer,3)
+		{
+		}
+		
+		public DepParser(ParserSharedInputState state) : base(state,3)
+		{
+			initialize();
+		}
+		
+	public void expr(
+		DepNode root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		
+		try {      // for error handling
+			cexpr(root, true);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_0_);
+		}
+	}
+	
+	public void cexpr(
+		DepNode parent,bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		
+		try {      // for error handling
+			if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==NOTO))
+			{
+				notexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==AND)) {
+				andexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==OR)) {
+				orexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==XOR)) {
+				xorexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==OPT)) {
+				optexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; ((LA(2) &gt;= EQ &amp;&amp; LA(2) &lt;= LD))) {
+				oexpr(parent, root);
+			}
+			else
+			{
+				throw new NoViableAltException(LT(1), getFilename());
+			}
+			
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void notexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Not;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(NOTO);
+			{ // ( ... )+
+				int _cnt6=0;
+				for (;;)
+				{
+					if ((LA(1)==LPAREN) &amp;&amp; ((LA(2) &gt;= EQ &amp;&amp; LA(2) &lt;= LD)) &amp;&amp; (LA(3)==CLASS))
+					{
+						oexpr(child, false);
+					}
+					else if ((LA(1)==LPAREN) &amp;&amp; (tokenSet_2_.member(LA(2))) &amp;&amp; (LA(3)==LPAREN||LA(3)==CLASS)) {
+						{
+							DepNode nchild = parent.CreateNewChild();
+							cexpr(nchild, true);
+						}
+					}
+					else
+					{
+						if (_cnt6 &gt;= 1) { goto _loop6_breakloop; } else { throw new NoViableAltException(LT(1), getFilename());; }
+					}
+					
+					_cnt6++;
+				}
+_loop6_breakloop:				;
+			}    // ( ... )+
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void andexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.And;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(AND);
+			{ // ( ... )+
+				int _cnt10=0;
+				for (;;)
+				{
+					if ((LA(1)==LPAREN) &amp;&amp; ((LA(2) &gt;= EQ &amp;&amp; LA(2) &lt;= LD)) &amp;&amp; (LA(3)==CLASS))
+					{
+						oexpr(child, false);
+					}
+					else if ((LA(1)==LPAREN) &amp;&amp; (tokenSet_2_.member(LA(2))) &amp;&amp; (LA(3)==LPAREN||LA(3)==CLASS)) {
+						{
+							DepNode nchild = parent.CreateNewChild();
+							cexpr(nchild, true);
+						}
+					}
+					else
+					{
+						if (_cnt10 &gt;= 1) { goto _loop10_breakloop; } else { throw new NoViableAltException(LT(1), getFilename());; }
+					}
+					
+					_cnt10++;
+				}
+_loop10_breakloop:				;
+			}    // ( ... )+
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void orexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Or;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(OR);
+			{ // ( ... )+
+				int _cnt14=0;
+				for (;;)
+				{
+					if ((LA(1)==LPAREN) &amp;&amp; ((LA(2) &gt;= EQ &amp;&amp; LA(2) &lt;= LD)) &amp;&amp; (LA(3)==CLASS))
+					{
+						oexpr(child, false);
+					}
+					else if ((LA(1)==LPAREN) &amp;&amp; (tokenSet_2_.member(LA(2))) &amp;&amp; (LA(3)==LPAREN||LA(3)==CLASS)) {
+						{
+							DepNode nchild = parent.CreateNewChild();
+							cexpr(nchild, true);
+						}
+					}
+					else
+					{
+						if (_cnt14 &gt;= 1) { goto _loop14_breakloop; } else { throw new NoViableAltException(LT(1), getFilename());; }
+					}
+					
+					_cnt14++;
+				}
+_loop14_breakloop:				;
+			}    // ( ... )+
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void xorexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Xor;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(XOR);
+			{ // ( ... )+
+				int _cnt18=0;
+				for (;;)
+				{
+					if ((LA(1)==LPAREN) &amp;&amp; ((LA(2) &gt;= EQ &amp;&amp; LA(2) &lt;= LD)) &amp;&amp; (LA(3)==CLASS))
+					{
+						oexpr(child, false);
+					}
+					else if ((LA(1)==LPAREN) &amp;&amp; (tokenSet_2_.member(LA(2))) &amp;&amp; (LA(3)==LPAREN||LA(3)==CLASS)) {
+						{
+							DepNode nchild = parent.CreateNewChild();
+							cexpr(nchild, true);
+						}
+					}
+					else
+					{
+						if (_cnt18 &gt;= 1) { goto _loop18_breakloop; } else { throw new NoViableAltException(LT(1), getFilename());; }
+					}
+					
+					_cnt18++;
+				}
+_loop18_breakloop:				;
+			}    // ( ... )+
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void optexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Opt;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(OPT);
+			{ // ( ... )+
+				int _cnt22=0;
+				for (;;)
+				{
+					if ((LA(1)==LPAREN) &amp;&amp; ((LA(2) &gt;= EQ &amp;&amp; LA(2) &lt;= LD)) &amp;&amp; (LA(3)==CLASS))
+					{
+						oexpr(child, false);
+					}
+					else if ((LA(1)==LPAREN) &amp;&amp; (tokenSet_2_.member(LA(2))) &amp;&amp; (LA(3)==LPAREN||LA(3)==CLASS)) {
+						{
+							DepNode nchild = parent.CreateNewChild();
+							cexpr(nchild, true);
+						}
+					}
+					else
+					{
+						if (_cnt22 &gt;= 1) { goto _loop22_breakloop; } else { throw new NoViableAltException(LT(1), getFilename());; }
+					}
+					
+					_cnt22++;
+				}
+_loop22_breakloop:				;
+			}    // ( ... )+
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void oexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		
+		try {      // for error handling
+			if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==EQ))
+			{
+				eqexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==NEQ)) {
+				neqexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==LTE)) {
+				lteexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==LS)) {
+				ltexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==GTE)) {
+				gteexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==GT)) {
+				gtexpr(parent, root);
+			}
+			else if ((LA(1)==LPAREN) &amp;&amp; (LA(2)==LD)) {
+				ldexpr(parent, root);
+			}
+			else
+			{
+				throw new NoViableAltException(LT(1), getFilename());
+			}
+			
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void eqexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Equal;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(EQ);
+			iexpr(child);
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void neqexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.NotEqual;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(NEQ);
+			iexpr(child);
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void lteexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.LessThanEqual;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(LTE);
+			iexpr(child);
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void ltexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.LessThan;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(LS);
+			iexpr(child);
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void gteexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.GreaterThanEqual;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(GTE);
+			iexpr(child);
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void gtexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.GreaterThan;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(GT);
+			iexpr(child);
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void ldexpr(
+		DepNode parent, bool root
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Loaded;
+		
+		try {      // for error handling
+			match(LPAREN);
+			match(LD);
+			iexpr(child);
+			match(RPAREN);
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_1_);
+		}
+	}
+	
+	public void iexpr(
+		DepNode node
+	) //throws RecognitionException, TokenStreamException
+{
+		
+		IToken  c = null;
+		IToken  v = null;
+		node.Constraint = new DepConstraint();
+		
+		try {      // for error handling
+			c = LT(1);
+			match(CLASS);
+			{
+				switch ( LA(1) )
+				{
+				case VER:
+				{
+					v = LT(1);
+					match(VER);
+					node.Constraint.VersionTmp=v.getText();
+					break;
+				}
+				case RPAREN:
+				{
+					break;
+				}
+				default:
+				{
+					throw new NoViableAltException(LT(1), getFilename());
+				}
+				 }
+			}
+			node.Constraint.Name=c.getText();
+		}
+		catch (RecognitionException ex)
+		{
+			reportError(ex);
+			recover(ex,tokenSet_3_);
+		}
+	}
+	
+	private void initializeFactory()
+	{
+	}
+	
+	public static readonly string[] tokenNames_ = new string[] {
+		@&quot;&quot;&quot;&lt;0&gt;&quot;&quot;&quot;,
+		@&quot;&quot;&quot;EOF&quot;&quot;&quot;,
+		@&quot;&quot;&quot;&lt;2&gt;&quot;&quot;&quot;,
+		@&quot;&quot;&quot;NULL_TREE_LOOKAHEAD&quot;&quot;&quot;,
+		@&quot;&quot;&quot;LPAREN&quot;&quot;&quot;,
+		@&quot;&quot;&quot;NOTO&quot;&quot;&quot;,
+		@&quot;&quot;&quot;RPAREN&quot;&quot;&quot;,
+		@&quot;&quot;&quot;AND&quot;&quot;&quot;,
+		@&quot;&quot;&quot;OR&quot;&quot;&quot;,
+		@&quot;&quot;&quot;XOR&quot;&quot;&quot;,
+		@&quot;&quot;&quot;OPT&quot;&quot;&quot;,
+		@&quot;&quot;&quot;EQ&quot;&quot;&quot;,
+		@&quot;&quot;&quot;NEQ&quot;&quot;&quot;,
+		@&quot;&quot;&quot;LTE&quot;&quot;&quot;,
+		@&quot;&quot;&quot;LS&quot;&quot;&quot;,
+		@&quot;&quot;&quot;GTE&quot;&quot;&quot;,
+		@&quot;&quot;&quot;GT&quot;&quot;&quot;,
+		@&quot;&quot;&quot;LD&quot;&quot;&quot;,
+		@&quot;&quot;&quot;CLASS&quot;&quot;&quot;,
+		@&quot;&quot;&quot;VER&quot;&quot;&quot;,
+		@&quot;&quot;&quot;INT&quot;&quot;&quot;,
+		@&quot;&quot;&quot;DOT&quot;&quot;&quot;,
+		@&quot;&quot;&quot;ID_START_LETTER&quot;&quot;&quot;,
+		@&quot;&quot;&quot;ID_LETTER&quot;&quot;&quot;,
+		@&quot;&quot;&quot;ID&quot;&quot;&quot;,
+		@&quot;&quot;&quot;WS&quot;&quot;&quot;
+	};
+	
+	private static long[] mk_tokenSet_0_()
+	{
+		long[] data = { 2L, 0L};
+		return data;
+	}
+	public static readonly BitSet tokenSet_0_ = new BitSet(mk_tokenSet_0_());
+	private static long[] mk_tokenSet_1_()
+	{
+		long[] data = { 82L, 0L};
+		return data;
+	}
+	public static readonly BitSet tokenSet_1_ = new BitSet(mk_tokenSet_1_());
+	private static long[] mk_tokenSet_2_()
+	{
+		long[] data = { 262048L, 0L};
+		return data;
+	}
+	public static readonly BitSet tokenSet_2_ = new BitSet(mk_tokenSet_2_());
+	private static long[] mk_tokenSet_3_()
+	{
+		long[] data = { 64L, 0L};
+		return data;
+	}
+	public static readonly BitSet tokenSet_3_ = new BitSet(mk_tokenSet_3_());
+	
+}
+}


Property changes on: trunk/NModule.Dependency.Parser/DepParser.cs
___________________________________________________________________
Name: svn:mime-type
   + text/cpp

Added: trunk/NModule.Dependency.Parser/DepParserTokenTypes.cs
===================================================================
--- trunk/NModule.Dependency.Parser/DepParserTokenTypes.cs	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/DepParserTokenTypes.cs	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,33 @@
+// $ANTLR 2.7.5 (20050516): &quot;nmodule-dep.g&quot; -&gt; &quot;DepParser.cs&quot;$
+
+namespace NModule.Dependency.Parser
+{
+	public class DepParserTokenTypes
+	{
+		public const int EOF = 1;
+		public const int NULL_TREE_LOOKAHEAD = 3;
+		public const int LPAREN = 4;
+		public const int NOTO = 5;
+		public const int RPAREN = 6;
+		public const int AND = 7;
+		public const int OR = 8;
+		public const int XOR = 9;
+		public const int OPT = 10;
+		public const int EQ = 11;
+		public const int NEQ = 12;
+		public const int LTE = 13;
+		public const int LS = 14;
+		public const int GTE = 15;
+		public const int GT = 16;
+		public const int LD = 17;
+		public const int CLASS = 18;
+		public const int VER = 19;
+		public const int INT = 20;
+		public const int DOT = 21;
+		public const int ID_START_LETTER = 22;
+		public const int ID_LETTER = 23;
+		public const int ID = 24;
+		public const int WS = 25;
+		
+	}
+}


Property changes on: trunk/NModule.Dependency.Parser/DepParserTokenTypes.cs
___________________________________________________________________
Name: svn:mime-type
   + text/cpp

Added: trunk/NModule.Dependency.Parser/DepParserTokenTypes.txt
===================================================================
--- trunk/NModule.Dependency.Parser/DepParserTokenTypes.txt	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/DepParserTokenTypes.txt	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,24 @@
+// $ANTLR 2.7.5 (20050516): nmodule-dep.g -&gt; DepParserTokenTypes.txt$
+DepParser    // output token vocab name
+LPAREN=4
+NOTO=5
+RPAREN=6
+AND=7
+OR=8
+XOR=9
+OPT=10
+EQ=11
+NEQ=12
+LTE=13
+LS=14
+GTE=15
+GT=16
+LD=17
+CLASS=18
+VER=19
+INT=20
+DOT=21
+ID_START_LETTER=22
+ID_LETTER=23
+ID=24
+WS=25


Property changes on: trunk/NModule.Dependency.Parser/DepParserTokenTypes.txt
___________________________________________________________________
Name: svn:mime-type
   + text/cpp

Added: trunk/NModule.Dependency.Parser/DepVersion.cs
===================================================================
--- trunk/NModule.Dependency.Parser/DepVersion.cs	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/DepVersion.cs	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,15 @@
+namespace NModule.Dependency.Parser
+{
+	public class DepVersion
+	{
+		public DepVersion()
+		{
+			Major = Minor = Build = Patch = 0;
+		}
+
+		public int Major;
+		public int Minor;
+		public int Build;
+		public int Patch;
+	}
+}

Added: trunk/NModule.Dependency.Parser/antlr.astframe.dll
===================================================================
(Binary files differ)


Property changes on: trunk/NModule.Dependency.Parser/antlr.astframe.dll
___________________________________________________________________
Name: svn:mime-type
   + application/x-ms-dos-executable

Added: trunk/NModule.Dependency.Parser/antlr.runtime.dll
===================================================================
(Binary files differ)


Property changes on: trunk/NModule.Dependency.Parser/antlr.runtime.dll
___________________________________________________________________
Name: svn:mime-type
   + application/x-ms-dos-executable

Added: trunk/NModule.Dependency.Parser/build.sh
===================================================================
--- trunk/NModule.Dependency.Parser/build.sh	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/build.sh	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1 @@
+mcs -target:library -out:NModule.Dependency.Parser.dll -r:./antlr.runtime.dll AssemblyInfo.cs DepConstraint.cs DepLexer.cs DepNode.cs DepOps.cs DepParser.cs DepParserTokenTypes.cs DepVersion.cs MyClass.cs


Property changes on: trunk/NModule.Dependency.Parser/build.sh
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/NModule.Dependency.Parser/nmodule-dep.g
===================================================================
--- trunk/NModule.Dependency.Parser/nmodule-dep.g	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/nmodule-dep.g	2005-06-04 05:39:11 UTC (rev 10)
@@ -7,29 +7,100 @@
 class DepParser extends Parser;
 
 options {
-	buildAST=true;
 	k=3;
 }
 
-expr: 
-	cexpr
+// Rebuild this to generate the dep tree
+expr[DepNode root]
+	: cexpr[root, true]
 	;
-	
-cexpr:
-    LPAREN! ((NOTO^|AND^|OR^|XOR^|OPT^) (oexpr|cexpr)+) RPAREN!
-    | oexpr
+
+// LPAREN! ((NOTO^|AND^|OR^|XOR^|OPT^) (oexpr|cexpr)+) RPAREN!
+cexpr[DepNode parent,bool root]
+		: notexpr[parent, root]
+		| andexpr[parent, root]
+		| orexpr[parent, root]
+		| xorexpr[parent, root]
+		| optexpr[parent, root]
+    | oexpr[parent, root]
     ;
 
-oexpr:
-	LPAREN! ((EQ^|NEQ^|LTE^|LS^|GTE^|GT^|LD^) iexpr) RPAREN!
+notexpr[DepNode parent, bool root]
+{ DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Not; }
+	: LPAREN! NOTO (oexpr[child, false]|({DepNode nchild = parent.CreateNewChild(); } cexpr[nchild, true]))+ RPAREN!
 	;
+
+andexpr[DepNode parent, bool root]
+{ DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.And; }
+	: LPAREN! AND (oexpr[child, false]|({DepNode nchild = parent.CreateNewChild(); } cexpr[nchild, true]))+ RPAREN!
+	;
+
+orexpr[DepNode parent, bool root]
+{ DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Or; }
+	: LPAREN! OR (oexpr[child, false]|({DepNode nchild = parent.CreateNewChild(); } cexpr[nchild, true]))+ RPAREN!
+	;
+
+xorexpr[DepNode parent, bool root]
+{ DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Xor; }
+	: LPAREN! XOR (oexpr[child, false]|({DepNode nchild = parent.CreateNewChild(); } cexpr[nchild, true]))+ RPAREN!
+	;
+
+
+optexpr[DepNode parent, bool root]
+{ DepNode child = !(root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Opt; }
+	: LPAREN! OPT (oexpr[child, false]|({DepNode nchild = parent.CreateNewChild(); } cexpr[nchild, true]))+ RPAREN!
+	;
+
+// LPAREN! ((EQ^|NEQ^|LTE^|LS^|GTE^|GT^|LD^) iexpr) RPAREN!
+oexpr[DepNode parent, bool root]
+	: eqexpr[parent, root]
+	| neqexpr[parent, root]
+	| lteexpr[parent, root]
+	| ltexpr[parent, root]
+	| gteexpr[parent, root]
+	| gtexpr[parent, root]
+	| ldexpr[parent, root]
+	;
 	
-iexpr: CLASS ( VER )?;
+eqexpr[DepNode parent, bool root]
+{ DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Equal; }
+	: LPAREN! EQ iexpr[child] RPAREN!
+	;
 
-{	
-	public class DepNode
-	{
-		public enum DepOp { NOT, AND, OR, XOR, OPT, EQ, NEQ, LTE, LT, GTE, GT, LD };
+neqexpr[DepNode parent, bool root]
+{ DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.NotEqual; }
+	: LPAREN! NEQ iexpr[child] RPAREN!
+	;
+
+lteexpr[DepNode parent, bool root]
+{ DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.LessThanEqual; }
+	: LPAREN! LTE iexpr[child] RPAREN!
+	;
+
+ltexpr[DepNode parent, bool root]
+{ DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.LessThan; }
+	: LPAREN! LS iexpr[child] RPAREN!
+	;
+
+gteexpr[DepNode parent, bool root]
+{ DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.GreaterThanEqual; }
+	: LPAREN! GTE iexpr[child] RPAREN!
+	;
+
+gtexpr[DepNode parent, bool root]
+{ DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.GreaterThan; }
+	: LPAREN! GT iexpr[child] RPAREN!
+	;
+
+ldexpr[DepNode parent, bool root]
+{ DepNode child = (!root)? parent.CreateNewChild() : parent; child.DepOp = DepOps.Loaded; }
+	: LPAREN! LD iexpr[child] RPAREN!
+	;
+
+
+iexpr[DepNode node]
+{ node.Constraint = new DepConstraint(); }
+	: c:CLASS ( v:VER { node.Constraint.VersionTmp=v.getText(); } )? { node.Constraint.Name=c.getText(); };
 		
 class DepLexer extends Lexer;
 
@@ -74,6 +145,7 @@
 ID_START_LETTER: 
     ('a' .. 'z')
 	| ('A' .. 'Z')
+	| ('_')
 	;
 
 protected

Added: trunk/NModule.Dependency.Parser/nmodule-dep.g.old
===================================================================
--- trunk/NModule.Dependency.Parser/nmodule-dep.g.old	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModule.Dependency.Parser/nmodule-dep.g.old	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,98 @@
+options
+{
+	language=&quot;CSharp&quot;; 
+	namespace=&quot;NModule.Dependency.Parser&quot;;
+}
+  
+class DepParser extends Parser;
+
+options {
+	buildAST=true;
+	k=3;
+}
+
+expr: 
+	cexpr
+	;
+	
+cexpr:
+    LPAREN! ((NOTO^|AND^|OR^|XOR^|OPT^) (oexpr|cexpr)+) RPAREN!
+    | oexpr
+    ;
+
+oexpr:
+	LPAREN! ((EQ^|NEQ^|LTE^|LS^|GTE^|GT^|LD^) iexpr) RPAREN!
+	;
+	
+iexpr: CLASS ( VER )?;
+
+{	
+	public class DepNode
+	{
+		public enum DepOp { NOT, AND, OR, XOR, OPT, EQ, NEQ, LTE, LT, GTE, GT, LD };
+		
+class DepLexer extends Lexer;
+
+options
+{
+	k=2;
+	charVocabulary='\u0000' .. '\u007F';
+}
+
+// Parentheses
+LPAREN: '(' ;
+RPAREN: ')' ;
+
+// Combination Operators
+NOTO: &quot;!!&quot; ;
+AND: &quot;&amp;&amp;&quot; ;
+OR: &quot;||&quot; ;
+XOR: &quot;^^&quot; ;
+
+// Dependency Operators
+EQ: &quot;==&quot; ;
+NEQ: &quot;!=&quot; ;
+LTE: &quot;&lt;=&quot; ;
+LS: &quot;&lt;&lt;&quot; ;
+GTE: &quot;&gt;=&quot; ;
+GT: &quot;&gt;&gt;&quot; ;
+OPT: &quot;??&quot; ;
+LD: &quot;##&quot; ;
+
+// Version
+protected
+INT: ('0' .. '9')+;
+
+VER: INT (DOT INT)*;
+
+// Dot operator
+protected
+DOT: '.' ;
+
+// Basic Identifier
+protected
+ID_START_LETTER: 
+    ('a' .. 'z')
+	| ('A' .. 'Z')
+	;
+
+protected
+ID_LETTER: 
+  ID_START_LETTER
+	| ('0' .. '9')
+	;
+	
+protected
+ID: ID_START_LETTER ( ID_LETTER )* ;
+
+// Class
+CLASS: ID ( DOT ID )* ;
+
+// Whitespace
+WS: ( ' '
+    | '\r' '\n'
+    | '\n'
+    | '\t'
+    )
+    {$setType(Token.SKIP);}
+    ;

Added: trunk/NModuleTest.cs
===================================================================
--- trunk/NModuleTest.cs	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/NModuleTest.cs	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1,46 @@
+using System;
+using NModule.Dependency.Parser;
+using antlr.collections;
+
+namespace NModule
+{
+	public class NModuleTest
+	{
+		public static void PrintTree(DepNode root, int indent)
+		{
+			for(int i = 0; i &lt; indent; i++)
+				Console.Write(&quot;  &quot;);
+	
+			Console.Write(&quot;op = {0}, &quot;, root.DepOp.ToString());
+
+			if (root.Constraint != null)
+			{
+				Console.Write(&quot;name = {0}&quot;, root.Constraint.Name);
+				if (root.Constraint.Version != null)
+				{
+					DepVersion ver = root.Constraint.Version;
+					Console.WriteLine(&quot;, version = {0}.{1}.{2}.{3}&quot;, ver.Major, ver.Minor, ver.Build, ver.Patch);
+				}
+				else
+					Console.WriteLine();
+			}
+			else
+				Console.WriteLine();
+
+			foreach(DepNode child in root.Children)
+				PrintTree(child, indent + 1);
+		}
+
+	       	public static void Main(string[] args)
+	        {
+			DepNode root = new DepNode();
+
+        	        DepLexer lexer = new DepLexer(Console.OpenStandardInput());
+                	DepParser parser = new DepParser(lexer);
+	                parser.expr(root);
+                	PrintTree(root, 0);
+	        }
+	}
+}
+
+

Added: trunk/build.sh
===================================================================
--- trunk/build.sh	2005-06-01 20:47:09 UTC (rev 9)
+++ trunk/build.sh	2005-06-04 05:39:11 UTC (rev 10)
@@ -0,0 +1 @@
+mcs -lib:./NModule.Dependency.Parser -target:exe -out:NModuleTest.exe -r:NModule.Dependency.Parser.dll -r:antlr.runtime.dll NModuleTest.cs


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000001.html">[nmodule-commits] r9 - trunk
</A></li>
	<LI>Next message: <A HREF="000003.html">[nmodule-commits] r18 - in trunk: . Documentation src src/NModule.Core.Loader src/NModule.Core.Module src/NModule.Dependency.Parser
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2">[ date ]</a>
              <a href="thread.html#2">[ thread ]</a>
              <a href="subject.html#2">[ subject ]</a>
              <a href="author.html#2">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/nmodule-commits">More information about the nmodule-commits
mailing list</a><br>
</body></html>
